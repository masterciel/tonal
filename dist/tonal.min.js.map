{"version":3,"file":"tonal.min.js","sources":["../packages/core/pitch/node_modules/note-parser/index.js","../packages/core/pitch/node_modules/interval-notation/index.js","../packages/core/encoding/index.js","../packages/core/pitch/index.js","../packages/core/transpose/index.js","../packages/tonal/distance/index.js","../packages/core/array/index.js","../packages/core/harmonizer/index.js","../packages/tonal/note/node_modules/note-parser/index.js","../packages/core/midi/node_modules/note-parser/index.js","../packages/core/midi/index.js","../packages/core/freq/index.js","../packages/tonal/note/index.js","../packages/tonal/interval/node_modules/interval-notation/index.js","../packages/tonal/interval/index.js","../packages/core/pcset/index.js","../packages/core/range/index.js","../packages/core/notation/index.js","../packages/extensions/key/index.js","../packages/core/dictionary/index.js","../packages/tonal/scale/index.js","../packages/tonal/chord/node_modules/note-parser/index.js","../packages/tonal/chord/index.js","../packages/extensions/progression/index.js","../packages/incubator/sonority/index.js","../packages/incubator/pitchset/index.js","../packages/core/tonal/index.js"],"sourcesContent":["'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n","// shorthand tonal notation (with quality after number)\nvar IVL_TNL = '([-+]?)(\\\\d+)(d{1,4}|m|M|P|A{1,4})'\n// standard shorthand notation (with quality before number)\nvar IVL_STR = '(AA|A|P|M|m|d|dd)([-+]?)(\\\\d+)'\nvar COMPOSE = '(?:(' + IVL_TNL + ')|(' + IVL_STR + '))'\nvar IVL_REGEX = new RegExp('^' + COMPOSE + '$')\n\n/**\n * Parse a string with an interval in shorthand notation (https://en.wikipedia.org/wiki/Interval_(music)#Shorthand_notation)\n * and returns an object with interval properties.\n *\n * @param {String} str - the string with the interval\n * @param {Boolean} strict - (Optional) if its false, it doesn't check if the\n * interval is valid or not. For example, parse('P2') returns null\n * (because a perfect second is not a valid interval), but\n * parse('P2', false) it returns { num: 2, dir: 1, q: 'P'... }\n * @return {Object} an object properties or null if not valid interval string\n * The returned object contains:\n * - `num`: the interval number\n * - `q`: the interval quality string (M is major, m is minor, P is perfect...)\n * - `simple`: the simplified number (from 1 to 7)\n * - `dir`: the interval direction (1 ascending, -1 descending)\n * - `type`: the interval type (P is perfectable, M is majorable)\n * - `alt`: the alteration, a numeric representation of the quality\n * - `oct`: the number of octaves the interval spans. 0 for simple intervals.\n * - `size`: the size of the interval in semitones\n * @example\n * var parse = require('interval-notation').parse\n * parse('M3')\n * // => { num: 3, q: 'M', dir: 1, simple: 3,\n * //      type: 'M', alt: 0, oct: 0, size: 4 }\n */\nexport function parse (str, strict) {\n  if (typeof str !== 'string') return null\n  var m = IVL_REGEX.exec(str)\n  if (!m) return null\n  var i = { num: +(m[3] || m[8]), q: m[4] || m[6] }\n  i.dir = (m[2] || m[7]) === '-' ? -1 : 1\n  var step = (i.num - 1) % 7\n  i.simple = step + 1\n  i.type = TYPES[step]\n  i.alt = qToAlt(i.type, i.q)\n  i.oct = Math.floor((i.num - 1) / 7)\n  i.size = i.dir * (SIZES[step] + i.alt + 12 * i.oct)\n  if (strict !== false) {\n    if (i.type === 'M' && i.q === 'P') return null\n  }\n  return i\n}\nvar SIZES = [0, 2, 4, 5, 7, 9, 11]\n\nvar TYPES = 'PMMPPMM'\n/**\n * Get the type of interval. Can be perfectavle ('P') or majorable ('M')\n * @param {Integer} num - the interval number\n * @return {String} `P` if it's perfectable, `M` if it's majorable.\n */\nexport function type (num) {\n  return TYPES[(num - 1) % 7]\n}\n\nfunction dirStr (dir) { return dir === -1 ? '-' : '' }\nfunction num (simple, oct) { return simple + 7 * oct }\n\n/**\n * Build a shorthand interval notation string from properties.\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.shorthand(3, 0, 0, 1) // => 'M3'\n * interval.shorthand(3, -1, 0, -1) // => 'm-3'\n * interval.shorthand(3, 1, 1, 1) // => 'A10'\n */\nexport function shorthand (simple, alt, oct, dir) {\n  return altToQ(simple, alt) + dirStr(dir) + num(simple, oct)\n}\n/**\n * Build a special shorthand interval notation string from properties.\n * The special shorthand interval notation changes the order or the standard\n * shorthand notation so instead of 'M-3' it returns '-3M'.\n *\n * The standard shorthand notation has a string 'A4' (augmented four) that can't\n * be differenciate from 'A4' (the A note in 4th octave), so the purpose of this\n * notation is avoid collisions\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.build(3, 0, 0, 1) // => '3M'\n * interval.build(3, -1, 0, -1) // => '-3m'\n * interval.build(3, 1, 1, 1) // => '10A'\n */\nexport function build (simple, alt, oct, dir) {\n  return dirStr(dir) + num(simple, oct) + altToQ(simple, alt)\n}\n\n/**\n * Get an alteration number from an interval quality string.\n * It accepts the standard `dmMPA` but also sharps and flats.\n *\n * @param {Integer|String} num - the interval number or a string representing\n * the interval type ('P' or 'M')\n * @param {String} quality - the quality string\n * @return {Integer} the interval alteration\n * @example\n * qToAlt('M', 'm') // => -1 (for majorables, 'm' is -1)\n * qToAlt('P', 'A') // => 1 (for perfectables, 'A' means 1)\n * qToAlt('M', 'P') // => null (majorables can't be perfect)\n */\nexport function qToAlt (num, q) {\n  var t = typeof num === 'number' ? type(num) : num\n  if (q === 'M' && t === 'M') return 0\n  if (q === 'P' && t === 'P') return 0\n  if (q === 'm' && t === 'M') return -1\n  if (/^A+$/.test(q)) return q.length\n  if (/^d+$/.test(q)) return t === 'P' ? -q.length : -q.length - 1\n  return null\n}\n\nfunction fillStr (s, n) { return Array(Math.abs(n) + 1).join(s) }\n/**\n * Get interval quality from interval type and alteration\n *\n * @function\n * @param {Integer|String} num - the interval number of the the interval\n * type ('M' for majorables, 'P' for perfectables)\n * @param {Integer} alt - the interval alteration\n * @return {String} the quality string\n * @example\n * altToQ('M', 0) // => 'M'\n */\nexport function altToQ (num, alt) {\n  var t = typeof num === 'number' ? type(Math.abs(num)) : num\n  if (alt === 0) return t === 'M' ? 'M' : 'P'\n  else if (alt === -1 && t === 'M') return 'm'\n  else if (alt > 0) return fillStr('A', alt)\n  else if (alt < 0) return fillStr('d', t === 'P' ? alt : alt + 1)\n  else return null\n}\n\n","/**\n * Functions to encoding and decoding pitches into fifths/octaves notation.\n *\n * This functions are very low level and it's probably you wont need them.\n * @private\n * @module encoding\n */\n\nfunction isNum(n) {\n  return typeof n === \"number\";\n}\n\n// Map from letter step to number of fifths starting from 'C':\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n// Given a number of fifths, return the octaves they span\nfunction fOcts(f) {\n  return Math.floor(f * 7 / 12);\n}\n// Get the number of octaves it span each step\nvar FIFTH_OCTS = FIFTHS.map(fOcts);\n\n/**\n * Given a note's step, alteration and octave returns the fiths/octave\n * note encoding.\n * @param {number} step - the step number (0 = C, 1 = D, ...)\n * @param {number} alteration - the note alteration (..., -1 = 'b', 0 = '', 1 = '#', ...)\n * @param {number} octave - the note octave\n * @return {Array} the [fifths, octave] representation of that note\n */\nexport function encode(step, alt, oct) {\n  var f = FIFTHS[step] + 7 * alt;\n  if (!isNum(oct)) return [f];\n  var o = oct - FIFTH_OCTS[step] - 4 * alt;\n  return [f, o];\n}\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f) {\n  var i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for ['F', 'C', 'G', 'D', 'A', 'E', 'B'] we have:\nvar STEPS = [3, 0, 4, 1, 5, 2, 6];\n\n/**\n * Decode a encoded pitch\n * @param {Number} fifths - the number of fifths\n * @param {Number} octs - the number of octaves to compensate the fifhts\n * @return {Array} in the form [step, alt, oct]\n */\nexport function decode(f, o) {\n  var step = STEPS[unaltered(f)];\n  var alt = Math.floor((f + 1) / 7);\n  if (!isNum(o)) return [step, alt];\n  var oct = o + 4 * alt + FIFTH_OCTS[step];\n  return [step, alt, oct];\n}\n","/**\n * Functions to deal with pitches (either notes or intervals).\n *\n * This functions are very low level and more developer friendly of this functions\n * are exposed in the note and interval packages. It's unlikely you need them.\n * That's why __this module is NOT exported in the tonal package__.\n *\n * @private\n * @module pitch\n */\nimport { parse as noteParse, build as noteStr } from \"note-parser\";\nimport { parse as ivlParse, altToQ } from \"interval-notation\";\nimport { encode as enc, decode as dec } from \"tonal-encoding\";\n\n/**\n * Create a pitch\n * @param {Integer} fifths - the number of fifths from C or from P1\n * @param {Integer} focts - the number of encoded octaves\n * @param {Integer} dir - (Optional) Only required for intervals. Can be 1 or -1\n * @return {Pitch}\n */\nexport function pitch(fifths, focts, dir) {\n  return dir ? [\"tnlp\", [fifths, focts], dir] : [\"tnlp\", [fifths, focts]];\n}\n/**\n * Test if an object is a pitch\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isPitch(p) {\n  return Array.isArray(p) && p[0] === \"tnlp\";\n}\n/**\n * Encode a pitch\n * @param {Integer} step\n * @param {Integer} alt\n * @param {Integer} oct\n * @param {Integer} dir - (Optional)\n */\nexport function encode(s, a, o, dir) {\n  return dir ? [\"tnlp\", enc(s, a, o), dir] : [\"tnlp\", enc(s, a, o)];\n}\n\n/**\n * Decode a pitch\n * @param {Pitch} the pitch\n * @return {Array} An array with [step, alt, oct]\n */\nexport function decode(p) {\n  return dec.apply(null, p[1]);\n}\n\n/**\n * Get pitch type\n * @param {Pitch}\n * @return {String} 'ivl' or 'note' or null if not a pitch\n */\nexport function pType(p) {\n  return !isPitch(p) ? null : p[2] ? \"ivl\" : \"note\";\n}\n/**\n * Test if is a pitch note (with or without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isNotePitch(p) {\n  return pType(p) === \"note\";\n}\n/**\n * Test if is an interval\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isIvlPitch(p) {\n  return pType(p) === \"ivl\";\n}\n/**\n * Test if is a pitch class (a pitch note without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isPC(p) {\n  return isPitch(p) && p[1].length === 1;\n}\n\n/**\n * Get direction of a pitch (even for notes)\n * @param {Pitch}\n * @return {Integer} 1 or -1\n */\nexport function dir(p) {\n  return p[2] === -1 ? -1 : 1;\n}\n\n/**\n * Get encoded fifths from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nexport function fifths(p) {\n  return p[2] === -1 ? -p[1][0] : p[1][0];\n}\n/**\n * Get encoded octaves from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nexport function focts(p) {\n  return p[2] === -1 ? -p[1][1] : p[1][1];\n}\n/**\n * Get height of a pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nexport function height(p) {\n  return fifths(p) * 7 + focts(p) * 12;\n}\n\n/**\n * Get chroma of a pitch. The chroma is a number between 0 and 11 to represent\n * the position of a pitch inside an octave. Is the numeric equivlent of a\n * pitch class.\n *\n * @param {Pitch}\n * @return {Integer}\n */\nexport function chr(p) {\n  var f = fifths(p);\n  return 7 * f - 12 * Math.floor(f * 7 / 12);\n}\n\n// memoize parsers\nfunction memoize(fn) {\n  var cache = {};\n  return function(str) {\n    if (typeof str !== \"string\") return null;\n    return cache[str] || (cache[str] = fn(str));\n  };\n}\n\n/**\n * Parse a note\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid note string\n */\nexport var parseNote = memoize(function(s) {\n  var p = noteParse(s);\n  return p ? encode(p.step, p.alt, p.oct) : null;\n});\n\n/**\n * Parse an interval\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid interval string\n */\nexport var parseIvl = memoize(function(s) {\n  var p = ivlParse(s);\n  if (!p) return null;\n  return p ? encode(p.simple - 1, p.alt, p.oct, p.dir) : null;\n});\n\n/**\n * Parse a note or an interval\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid pitch string\n */\nexport function parsePitch(s) {\n  return parseNote(s) || parseIvl(s);\n}\n\n/**\n * Ensure the given object is a note pitch. If is a string, it will be\n * parsed. If not a note pitch or valid note string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nexport function asNotePitch(p) {\n  return isNotePitch(p) ? p : parseNote(p);\n}\n/**\n * Ensure the given object is a interval pitch. If is a string, it will be\n * parsed. If not a interval pitch or valid interval string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nexport function asIvlPitch(p) {\n  return isIvlPitch(p) ? p : parseIvl(p);\n}\n/**\n * Ensure the given object is a pitch. If is a string, it will be\n * parsed. If not a pitch or valid pitch string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nexport function asPitch(p) {\n  return isPitch(p) ? p : parsePitch(p);\n}\n\n/**\n * Convert a note pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nexport function strNote(p) {\n  if (!isNotePitch(p)) return null;\n  return noteStr.apply(null, decode(p));\n}\n\n/**\n * Convert a interval pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nexport function strIvl(p) {\n  if (!isIvlPitch(p)) return null;\n  // decode to [step, alt, oct]\n  var d = decode(p);\n  // d = [step, alt, oct]\n  var num = d[0] + 1 + 7 * d[2];\n  return p[2] * num + altToQ(num, d[1]);\n}\n\n/**\n * Convert a pitch to string representation (either notes or intervals)\n * @param {Pitch}\n * @return {String}\n */\nexport function strPitch(p) {\n  return strNote(p) || strIvl(p);\n}\n\n// A function that creates a decorator\n// The returned function can _decorate_ other functions to parse and build\n// string representations\nfunction decorator(is, parse, str) {\n  return function(fn) {\n    return function(v) {\n      var i = is(v);\n      // if the value is in pitch notation no conversion\n      if (i) return fn(v);\n      // else parse the pitch\n      var p = parse(v);\n      // if parsed, apply function and back to string\n      return p ? str(fn(p)) : null;\n    };\n  };\n}\n\n/**\n * Decorate a function to work internally with note pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a note pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nexport var noteFn = decorator(isNotePitch, parseNote, strNote);\n/**\n * Decorate a function to work internally with interval pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a interval pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nexport var ivlFn = decorator(isIvlPitch, parseIvl, strIvl);\n/**\n * Decorate a function to work internally with pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nexport var pitchFn = decorator(isPitch, parsePitch, strPitch);\n","/**\n * This module deals with note transposition. Just two functions: `transpose`\n * to transpose notes by any interval (or intervals by intervals) and `trFifths`\n * to transpose notes by fifths.\n *\n * @example\n * var tonal = require('tonal')\n * tonal.transpose('C3', 'P5') // => 'G3'\n * tonal.transpose('m2', 'P4') // => '5d'\n * tonal.trFifths('C', 2) // => 'D'\n *\n * @module transpose\n */\nimport {\n  pitch,\n  pType,\n  fifths,\n  focts,\n  height,\n  isPC,\n  asPitch,\n  isIvlPitch,\n  strPitch\n} from \"tonal-pitch\";\n\nfunction trBy(i, p) {\n  var t = pType(p);\n  if (!t) return null;\n  var f = fifths(i) + fifths(p);\n  if (isPC(p)) return [\"tnlp\", [f]];\n  var o = focts(i) + focts(p);\n  if (t === \"note\") return [\"tnlp\", [f, o]];\n  var d = height(i) + height(p) < 0 ? -1 : 1;\n  return [\"tnlp\", [d * f, d * o], d];\n}\n\n/**\n * Transpose notes. Can be used to add intervals. At least one of the parameter\n * is expected to be an interval. If not, it returns null.\n *\n * @param {String|Pitch} a - a note or interval\n * @param {String|Pitch} b - a note or interavl\n * @return {String|Pitch} the transposed pitch or null if not valid parameters\n * @example\n * var _ = require('tonal')\n * // transpose a note by an interval\n * _.transpose('d3', '3M') // => 'F#3'\n * // transpose intervals\n * _.transpose('3m', '5P') // => '7m'\n * // it works with pitch classes\n * _.transpose('d', '3M') // => 'F#'\n * // order or parameters is irrelevant\n * _.transpose('3M', 'd3') // => 'F#3'\n * // can be partially applied\n * _.map(_.transpose('3M'), 'c d e f g') // => ['E', 'F#', 'G#', 'A', 'B']\n */\nexport function transpose(a, b) {\n  if (arguments.length === 1)\n    return function(b) {\n      return transpose(a, b);\n    };\n  var pa = asPitch(a);\n  var pb = asPitch(b);\n  var r = isIvlPitch(pa) ? trBy(pa, pb) : isIvlPitch(pb) ? trBy(pb, pa) : null;\n  return a === pa && b === pb ? r : strPitch(r);\n}\n\n/**\n * Transpose a tonic a number of perfect fifths. It can be partially applied.\n *\n * @function\n * @param {Pitch|String} tonic\n * @param {Integer} number - the number of times\n * @return {String|Pitch} the transposed note\n * @example\n * import { trFifths } from 'tonal-transpose'\n * [0, 1, 2, 3, 4].map(trFifths('C')) // => ['C', 'G', 'D', 'A', 'E']\n * // or using tonal\n * tonal.trFifths('G4', 1) // => 'D5'\n */\nexport function trFifths(t, n) {\n  if (arguments.length > 1) return trFifths(t)(n);\n  return function(n) {\n    return transpose(t, pitch(n, 0, 1));\n  };\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-distance.svg)](https://www.npmjs.com/package/tonal-distance)\n * [![tonal](https://img.shields.io/badge/tonal-distance-yellow.svg)](https://github.com/danigb/tonal/tree/master/packages/tonal/distance)\n * \n * Transpose notes by intervals and find distances between notes\n *\n * @example\n * // using ES6 import\n * import { interval, semitones, transpose } from 'tonal-distance'\n * semitones('C' ,'D') // => 2\n * interval('C4', 'G4') // => '5P'\n * transpose('C4', 'P5') // => 'G4'\n *\n * // included in tonal facade\n * const tonal = require('tonal');\n * tonal.distance.transpose('C4', 'P5')\n * tonal.distance.transposeBy('P5', 'C4')\n * \n * @module distance\n */\nimport {\n  isPC,\n  fifths,\n  focts,\n  pitch,\n  height,\n  pType,\n  strPitch,\n  asPitch,\n  strIvl\n} from \"tonal-pitch\";\n\nfunction trBy(i, p) {\n  var t = pType(p);\n  if (!t) return null;\n  var f = fifths(i) + fifths(p);\n  if (isPC(p)) return [\"tnlp\", [f]];\n  var o = focts(i) + focts(p);\n  if (t === \"note\") return [\"tnlp\", [f, o]];\n  var d = height(i) + height(p) < 0 ? -1 : 1;\n  return [\"tnlp\", [d * f, d * o], d];\n}\n\n/**\n * Transpose a note by an interval. The note can be a pitch class.\n * \n * This function can be partially applied.\n * \n * @param {String} note\n * @param {String} interval\n * @return {String} the transposed note\n * @example\n * import { tranpose } from 'tonal-distance'\n * transpose('d3', '3M') // => 'F#3'\n * // it works with pitch classes\n * transpose('D', '3M') // => 'F#'\n * // can be partially applied\n * ['C', 'D', 'E', 'F', 'G'].map(transpose('M3)) // => ['E', 'F#', 'G#', 'A', 'B']\n */\nexport function transpose(note, interval) {\n  if (arguments.length === 1) return i => transpose(note, i);\n  var n = asPitch(note);\n  var i = asPitch(interval);\n  return n && i ? strPitch(trBy(i, n)) : null;\n}\n\n/**\n * The same as transpose with the arguments inverted.\n * \n * Can be partially applied.\n * \n * @param {String} note\n * @param {String} interval\n * @return {String} the transposed note\n * @example\n * import { tranposeBy } from 'tonal-distance'\n * transposeBy('3m', '5P') // => '7m'\n */\nexport function transposeBy(interval, note) {\n  if (arguments.length === 1) return n => transposeBy(interval, n);\n  return transpose(note, interval);\n}\n\n/**\n * Add two intervals \n * \n * Can be partially applied.\n * \n * @param {String} interval1\n * @param {String} interval2\n * @return {String} the resulting interval\n * @example\n * import { add } from 'tonal-distance'\n * add('3m', '5P') // => '7m'\n */\nexport function add(ivl1, ivl2) {\n  if (arguments.length === 1) return i2 => transposeBy(ivl1, i2);\n  var p1 = asPitch(ivl1);\n  var p2 = asPitch(ivl2);\n  return p1 && p2 ? strPitch(trBy(p1, p2)) : null;\n}\n\n/**\n * Transpose a note by a number of perfect fifths. \n * \n * It can be partially applied.\n *\n * @function\n * @param {String} note\n * @param {Integer} times - the number of times\n * @return {String} the transposed note\n * @example\n * import { trFifths } from 'tonal-transpose'\n * [0, 1, 2, 3, 4].map(trFifths('C')) // => ['C', 'G', 'D', 'A', 'E']\n * // or using tonal\n * tonal.trFifths('G4', 1) // => 'D5'\n */\nexport function trFifths(t, n) {\n  if (arguments.length > 1) return trFifths(t)(n);\n  return function(n) {\n    return transpose(t, pitch(n, 0, 1));\n  };\n}\n\n// substract two pitches\nfunction substr(a, b) {\n  if (!a || !b || a[1].length !== b[1].length) return null;\n  var f = fifths(b) - fifths(a);\n  if (isPC(a)) return pitch(f, -Math.floor(f * 7 / 12), 1);\n  var o = focts(b) - focts(a);\n  var d = height(b) - height(a) < 0 ? -1 : 1;\n  return pitch(d * f, d * o, d);\n}\n\n/**\n * Find the interval between two pitches. It works with pitch classes \n * (both must be pitch classes and the interval is always ascending)\n * \n * Can be partially applied\n *\n * @param {String} from - distance from\n * @param {String} to - distance to\n * @return {String} the interval distance\n *\n * @example\n * import { interval } from 'tonal-distance'\n * interval('C2', 'C3') // => 'P8'\n * interval('G', 'B') // => 'M3'\n * \n * // or use tonal\n * var tonal = require('tonal')\n * tonal.distance.interval('M2', 'P5') // => 'P4'\n */\nexport function interval(from, to) {\n  if (arguments.length === 1) return to => interval(from, to);\n  var pa = asPitch(from);\n  var pb = asPitch(to);\n  var i = substr(pa, pb);\n  // if a and b are in array notation, no conversion back\n  return strIvl(i);\n}\n\n/**\n * Subtract two intervals\n * \n * @param {String} minuend\n * @param {String} subtrahend\n * @return {String} interval diference\n */\nexport function subtract(ivl1, ivl2) {\n  return interval(ivl2, ivl1);\n}\n\n/**\n * Get the distance between two notes in semitones\n * @param {String|Pitch} from - first note\n * @param {String|Pitch} to - last note\n * @return {Integer} the distance in semitones or null if not valid notes\n * @example\n * import { semitones } from 'tonal-distance'\n * semitones('C3', 'A2') // => -3\n * // or use tonal\n * tonal.distance.semitones('C3', 'G3') // => 7\n */\nexport function semitones(a, b) {\n  var i = substr(asPitch(a), asPitch(b));\n  return i ? height(i) : null;\n}\n","/**\n * This module implements utility functions related to array manipulation, like:\n * `map`, `filter`, `shuffle`, `sort`, `rotate`, `select`\n *\n * All the functions are _functional friendly_ with target object as last\n * parameter and currified. The sorting functions understand about pitch\n * heights and interval sizes.\n *\n * One key feature of tonal is that you can represent lists with arrays or\n * with space separated string of elements. This module implements that\n * functionallity.\n *\n * @module array\n */\nimport { asPitch, isPitch, strPitch, pitch, fifths, focts } from \"tonal-pitch\";\nimport { transpose as tr } from \"tonal-transpose\";\nimport { semitones } from \"tonal-distance\";\n\nfunction split(sep) {\n  return function(o) {\n    return o === undefined\n      ? []\n      : Array.isArray(o)\n        ? o\n        : typeof o === \"string\" ? o.trim().split(sep) : [o];\n  };\n}\n\n// utility\nvar isArr = Array.isArray;\nfunction hasVal(e) {\n  return e || e === 0;\n}\n\n/**\n * Convert anything to array. Speifically, split string separated by spaces,\n * commas or bars. If you give it an actual array, it returns it without\n * modification.\n *\n * This function __always__ returns an array (null or undefined values are converted\n * to empty arrays)\n *\n * Thanks to this function, the rest of the functions of this module accepts\n * strings as an array parameter.\n *\n * @function\n * @param {*} source - the thing to get an array from\n * @return {Array} the object as an array\n *\n * @example\n * import { asArr } from 'tonal-arrays'\n * asArr('C D E F G') // => ['C', 'D', 'E', 'F', 'G']\n * asArr('A, B, c') // => ['A', 'B', 'c']\n * asArr('1 | 2 | x') // => ['1', '2', 'x']\n */\nexport var asArr = split(/\\s*\\|\\s*|\\s*,\\s*|\\s+/);\n\n/**\n * Return a new array with the elements mapped by a function.\n * Basically the same as the JavaScript standard `array.map` but with\n * two enhacements:\n *\n * - Arrays can be expressed as strings (see [asArr])\n * - This function can be partially applied. This is useful to create _mapped_\n * versions of single element functions. For an excellent introduction of\n * the adventages [read this](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html)\n *\n * @param {Function} fn - the function\n * @param {Array|String} arr - the array to be mapped\n * @return {Array}\n * @example\n * var arr = require('tonal-arr')\n * var toUp = arr.map(function(e) { return e.toUpperCase() })\n * toUp('a b c') // => ['A', 'B', 'C']\n *\n * @example\n * var tonal = require('tonal')\n * tonal.map(tonal.transpose('M3'), 'C D E') // => ['E', 'F#', 'G#']\n */\nexport function map(fn, list) {\n  return arguments.length > 1\n    ? map(fn)(list)\n    : function(l) {\n        return asArr(l).map(fn);\n      };\n}\n\n/**\n * Return a copy of the array with the null values removed\n * @param {String|Array} list\n * @return {Array}\n * @example\n * tonal.compact(['a', 'b', null, 'c']) // => ['a', 'b', 'c']\n */\nexport function compact(arr) {\n  return asArr(arr).filter(hasVal);\n}\n\n/**\n * Filter an array with a function. Again, almost the same as JavaScript standard\n * filter function but:\n *\n * - It accepts strings as arrays\n * - Can be partially applied\n *\n * @param {Function} fn\n * @param {String|Array} arr\n * @return {Array}\n * @example\n * t.filter(t.noteName, 'a b c x bb') // => [ 'a', 'b', 'c', 'bb' ]\n */\nexport function filter(fn, list) {\n  return arguments.length > 1\n    ? filter(fn)(list)\n    : function(l) {\n        return asArr(l).filter(fn);\n      };\n}\n\n// a custom height function that\n// - returns -Infinity for non-pitch objects\n// - assumes pitch classes has octave -100 (so are sorted before that notes)\nfunction objHeight(p) {\n  if (!p) return -Infinity;\n  var f = fifths(p) * 7;\n  var o = focts(p) || -Math.floor(f / 12) - 100;\n  return f + o * 12;\n}\n\n// ascending comparator\nfunction ascComp(a, b) {\n  return objHeight(a) - objHeight(b);\n}\n// descending comparator\nfunction descComp(a, b) {\n  return -ascComp(a, b);\n}\n\n/**\n * Sort a list of notes or intervals in ascending or descending pitch order.\n * It removes from the list any thing is not a pitch (a note or interval)\n *\n * Note this function returns a __copy__ of the array, it does NOT modify\n * the original.\n *\n * @param {Array|String} list - the list of notes or intervals\n * @param {Boolean|Function} comp - (Optional) comparator.\n * Ascending pitch by default. Pass a `false` to order descending\n * or a custom comparator function (that receives pitches in array notation).\n * Note that any other value is ignored.\n * @example\n * array.sort('D E C') // => ['C', 'D', 'E']\n * array.sort('D E C', false) // => ['E', 'D', 'C']\n * // if is not a note, it wil be removed\n * array.sort('g h f i c') // => ['C', 'F', 'G']\n */\nexport function sort(list, comp) {\n  var fn =\n    arguments.length === 1 || comp === true\n      ? ascComp\n      : comp === false ? descComp : typeof comp === \"function\" ? comp : ascComp;\n  // if the list is an array, make a copy\n  list = Array.isArray(list) ? list.slice() : asArr(list);\n  return listFn(function(arr) {\n    return arr.sort(fn).filter(hasVal);\n  }, list);\n}\n\n/**\n * Randomizes the order of the specified array using the Fisher–Yates shuffle.\n *\n * @function\n * @param {Array|String} arr - the array\n * @return {Array} the shuffled array\n *\n * @example\n * import { shuffle } from 'tonal-arrays'\n * @example\n * var tonal = require('tonal')\n * tonal.shuffle('C D E F')\n */\nexport var shuffle = listFn(function(arr) {\n  var i, t;\n  var m = arr.length;\n  while (m) {\n    i = (Math.random() * m--) | 0;\n    t = arr[m];\n    arr[m] = arr[i];\n    arr[i] = t;\n  }\n  return arr;\n});\n\nfunction trOct(n) {\n  return tr(pitch(0, n, 1));\n}\n\n/**\n * Rotates a list a number of times. It's completly agnostic about the\n * contents of the list.\n * @param {Integer} times - the number of rotations\n * @param {Array|String} list - the list to be rotated\n * @return {Array} the rotated array\n */\nexport function rotate(times, list) {\n  var arr = asArr(list);\n  var len = arr.length;\n  var n = (times % len + len) % len;\n  return arr.slice(n, len).concat(arr.slice(0, n));\n}\n\n/**\n * Rotates an ascending list of pitches n times keeping the ascending property.\n * This functions assumes the list is an ascending list of pitches, and\n * transposes the them to ensure they are ascending after rotation.\n * It can be used, for example, to invert chords.\n *\n * @param {Integer} times - the number of rotations\n * @param {Array|String} list - the list to be rotated\n * @return {Array} the rotated array\n */\nexport function rotateAsc(times, list) {\n  return listFn(function(arr) {\n    var len = arr.length;\n    var n = (times % len + len) % len;\n    var head = arr.slice(n, len);\n    var tail = arr.slice(0, n);\n    // See if the first note of tail is lower than the last of head\n    var s = semitones(head[len - n - 1], tail[0]);\n    if (s < 0) {\n      var octs = Math.floor(s / 12);\n      if (times < 0) head = head.map(trOct(octs));\n      else tail = tail.map(trOct(-octs));\n    }\n    return head.concat(tail);\n  }, list);\n}\n\n/**\n * Select elements from a list.\n *\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} list - the list of pitches\n * @return {Array} the selected elements (with nulls if not valid index)\n *\n * @example\n * import { select } from 'tonal-array'\n * select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n * select('-1 0 1 2 3', 'C D') // => [ null, null, 'C', 'D', null ]\n */\nexport function select(nums, list) {\n  if (arguments.length === 1) {\n    return function(l) {\n      return select(nums, l);\n    };\n  }\n  var arr = asArr(list);\n  return asArr(nums).map(function(n) {\n    return arr[n - 1] || null;\n  });\n}\n\n// http://stackoverflow.com/questions/9960908/permutations-in-javascript\n/**\n * Get all permutations of a list\n * @param {Array|Strng} list - the list\n * @return {Array<Array>} an array with all the permutations\n */\nexport function permutations(list) {\n  list = asArr(list);\n  if (list.length === 0) return [[]];\n  return permutations(list.slice(1)).reduce(function(acc, perm) {\n    return acc.concat(\n      list.map(function(e, pos) {\n        var newPerm = perm.slice();\n        newPerm.splice(pos, 0, list[0]);\n        return newPerm;\n      })\n    );\n  }, []);\n}\n\n// #### Transform lists in array notation\nfunction asPitchStr(p) {\n  return strPitch(p) || p;\n}\nfunction listToStr(v) {\n  return isPitch(v) ? strPitch(v) : isArr(v) ? v.map(asPitchStr) : v;\n}\n\n/**\n * Decorates a function to so it's first parameter is an array of pitches in\n * array notation. Also, if the return value is a pitch or an array of pitches\n * in array notation, it convert backs to strings.\n *\n * @private\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n * @example\n * import { listFn } from 'tonal-arrays'\n * var octUp = listFn((p) => { p[2] = p[2] + 1; return p[2] })\n * octUp('C2 D2 E2') // => ['C3', 'D3', 'E3']\n */\nfunction listFn(fn, list) {\n  if (arguments.length === 1) {\n    return function(l) {\n      return listFn(fn, l);\n    };\n  }\n  var arr = asArr(list).map(asPitch);\n  var res = fn(arr);\n  return listToStr(res);\n}\n","/**\n * Functions to transpose o calculate distances from a collection of notes.\n *\n * A useful concept is _harmonizer_: a function that _harmonizes_ notes. It can\n * be created by partially applying the `harmonize` function (see examples)\n *\n * @example\n * var harmonizer = require('tonal-harmonizer')\n * harmonizer.harmonize('1P 3M 5P', 'C') // => ['C', 'E', 'G']\n * var maj7 = harmonizer.harmonize('1P 3M 5P 7M')\n * maj7('D4') // =>  ['D4', 'F#4', 'A4', 'C#5']\n * harmonizer.harmonics('C E G') // => ['1P', '3M', '5P']\n *\n * @example\n * // in tonal this functions are NOT namespaced\n * var tonal = require('tonal')\n * tonal.harmonize('1P 3M 5P', 'G')\n *\n * @example\n * // using ES6 import syntax\n * import { harmonize } from 'tonal-harmonizer'\n * harmonize(...)\n *\n * @module harmonizer\n */\nimport { transpose as tr } from \"tonal-transpose\";\nimport { interval } from \"tonal-distance\";\nimport { asArr, map, compact } from \"tonal-array\";\n\n/**\n * Given a list of notes, return the distance from the first note to the rest.\n * @param {Array|String} notes - the list of notes\n * @return {Array} the intervals relative to the first note\n * @example\n * harmonizer.harmonics('C E G') // => ['1P', '3M', '5P']\n *\n * @example\n * // in tonal this functions are NOT namespaced\n * tonal.harmonics(tonal.scale('C major')) // => ['1P', ...]\n */\nexport function harmonics(list) {\n  var a = asArr(list);\n  return a.length ? compact(a.map(interval(a[0]))) : a;\n}\n\n/**\n * Given a list of notes, return the intervallic structure: the distance from\n * one to the next.\n *\n * Notice that the number of intervals is one less that the number of notes.\n *\n * @param {Array|String} notes - the list of notes\n * @return {Array} the intervals relative to the previous\n * @example\n * harmonizer.intervallic('c e g') // => ['3M', '3m']\n * harmonizer.intervallic('e g c') // => ['3m', '4P']\n * harmonizer.intervallic('c') // => []\n */\nexport function intervallic(notes) {\n  var dist = [];\n  notes = asArr(notes);\n  for (var i = 1; i < notes.length; i++) {\n    dist.push(interval(notes[i - 1], notes[i]));\n  }\n  return dist;\n}\n\n/**\n * Given a list of intervals and a tonic, return that tonic transposed\n * to that intervals.\n *\n * It's currified and, calling with only one parameter, returns an harmonizer,\n * a function that harmonizes any note (see example)\n *\n * @function\n * @param {String|Array} list - the list of intervals\n * @param {String|Pitch} note - the note to be harmonized\n * @return {Array} the resulting notes\n * @example\n * harmonizer.harmonize('P1 M3 P5 M7', 'C') // => ['C', 'E', 'G', 'B']\n * @example\n * // harmonizer with partial application\n * var maj7 = harmonize.harmonizer('P1 M3 P5 M7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n * @example\n * // in tonal this function is NOT namespaced\n * var C = tonal.harmonizer('C D E')\n * C('M3') // => ['E', 'G#', 'B']\n */\nexport function harmonize(list, pitch) {\n  if (arguments.length > 1) return harmonize(list)(pitch);\n  return function(tonic) {\n    return compact(map(tr(tonic || \"P1\"), list));\n  };\n}\n","'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n","'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n","/**\n * A midi note number is a number representation of a note pitch. It can be\n * integers so it's equal tempered tuned, or float to indicate it's not\n * tuned into equal temepered scale.\n *\n * This module contains functions to convert to and from midi notes.\n *\n * @example\n * var midi = require('tonal-midi')\n * midi.toMidi('A4') // => 69\n * midi.note(69) // => 'A4'\n * midi.note(61) // => 'Db4'\n * midi.note(61, true) // => 'C#4'\n *\n * @module midi\n */\n\nimport { midi } from \"note-parser\";\n\n/**\n * Convert the given note to a midi note number. If you pass a midi number it\n * will returned as is.\n *\n * @param {Array|String|Number} note - the note to get the midi number from\n * @return {Integer} the midi number or null if not valid pitch\n * @example\n * midi.toMidi('C4') // => 60\n * midi.toMidi(60) // => 60\n * midi.toMidi('60') // => 60\n */\nexport function toMidi(val) {\n  if (Array.isArray(val) && val.length === 2)\n    return val[0] * 7 + val[1] * 12 + 12;\n  return midi(val);\n}\n\nvar FLATS = \"C Db D Eb E F Gb G Ab A Bb B\".split(\" \");\nvar SHARPS = \"C C# D D# E F F# G G# A A# B\".split(\" \");\n\n/**\n * Given a midi number, returns a note name. The altered notes will have\n * flats unless explicitly set with the optional `useSharps` parameter.\n *\n * @function\n * @param {Integer} midi - the midi note number\n * @param {Boolean} useSharps - (Optional) set to true to use sharps instead of flats\n * @return {String} the note name\n * @example\n * var midi = require('tonal-midi')\n * midi.note(61) // => 'Db4'\n * midi.note(61, true) // => 'C#4'\n * // it rounds to nearest note\n * midi.note(61.7) // => 'D4'\n */\nexport function note(num, sharps) {\n  if (num === true || num === false)\n    return function(m) {\n      return note(m, num);\n    };\n  num = Math.round(num);\n  var pcs = sharps === true ? SHARPS : FLATS;\n  var pc = pcs[num % 12];\n  var o = Math.floor(num / 12) - 1;\n  return pc + o;\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-freq.svg)](https://www.npmjs.com/package/tonal-freq)\n * [![tonal](https://img.shields.io/badge/tonal-freq-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-freq` is a collection of functions to perform calculations related to frequencies.\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * var freq = require('tonal-freq')\n * freq.toFreq('A4') // => 440\n * freq.note(440) // => 'A4'\n * freq.noteAndDetune(320) // => ['C4', 200]\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-freq](https://nodei.co/npm/tonal-freq.png?mini=true)](https://npmjs.org/package/tonal-freq/)\n *\n * ## API Documentation\n *\n * @module freq\n */\nimport { toMidi as noteToMidi, note as midiToNote } from \"tonal-midi\";\n\n// decorate a function to round the numeric result to a max\nfunction round(m, fn) {\n  m = m || m === 0 ? Math.pow(10, m) : false;\n  return function(v) {\n    v = fn(v);\n    return v === null ? null : m ? Math.round(v * m) / m : v;\n  };\n}\n\n/**\n * Return the equal tempered frequency of a note.\n *\n * This function can be partially applied if note parameter is not present.\n * @function\n * @param {Float} ref - the tuning reference\n * @param {Integer} maxDecimals - (Optional) the maximum number of decimals (all by default)\n * @param {String|Pitch} note - the note to get the frequency from\n * @return {Number} the frequency\n * @example\n * eqTempFreq(444, 4, 'C3')\n * const toFreq = eqTempFreq(444, 2)\n * toFreq('A3') // => 222\n */\nexport function eqTempFreq(ref, max, note) {\n  if (arguments.length > 2) return eqTempFreq(ref, max)(note);\n  return round(max, function(p) {\n    var m = noteToMidi(p);\n    return m ? Math.pow(2, (m - 69) / 12) * ref : null;\n  });\n}\n\n/**\n * Get the frequency of note with 2 decimals precission using A4 440Hz tuning\n *\n * This is an alias for: `eqTempFreq(440, 2, <note>)`\n *\n * @function\n * @param {Number|String} note - the note name or midi number\n * @return {Float} the frequency in herzs\n * @example\n * freq.toFreq('A4') // => 440\n * freq.toFreq('C4') // => 261.63\n */\nexport var toFreq = eqTempFreq(440, 2);\n\n/**\n * Get the midi note from a frequency in equal temperament scale. You can\n * specify the number of decimals of the midi number.\n *\n * @param {Float} tuning - (Optional) the reference A4 tuning (440Hz by default)\n * @param {Number} freq - the frequency\n * @return {Number} the midi number\n */\nexport function eqTempFreqToMidi(ref, max, freq) {\n  if (arguments.length > 2) return eqTempFreqToMidi(ref, max)(freq);\n  return round(max, function(freq) {\n    return 12 * (Math.log(freq) - Math.log(ref)) / Math.log(2) + 69;\n  });\n}\n\n/**\n * Get midi number from frequency with two decimals of precission.\n *\n * This is an alisas for: `eqTempFreqToMidi(440, 2, <freq>)`\n *\n * @function\n * @param {Float} freq\n * @return {Number} midi number\n * @example\n * freq.toMidi(361) // => 59.96\n */\nexport var toMidi = eqTempFreqToMidi(440, 2);\n\n/**\n * Get note name from frequency using an equal temperament scale with 440Hz\n * as reference\n *\n * @param {Float} freq\n * @param {Boolean} useSharps - (Optional) set to true to use sharps instead of flats\n * @return {String} note name\n * @example\n * freq.note(440) // => 'A4'\n */\nexport function note(freq, useSharps) {\n  return midiToNote(toMidi(freq), useSharps);\n}\n\n/**\n * Get difference in cents between two frequencies. The frequencies can be\n * expressed with hertzs or midi numbers or note names\n * @param {Float|Integer|String} base\n * @param {Float|Integer|String} freq\n * @return {Integer} The difference in cents\n * @example\n * import { cents } from 'tonal-freq'\n * cents('C4', 261) // => -4\n */\nexport function cents(base, freq) {\n  var b = toFreq(base) || base;\n  var f = toFreq(freq) || freq;\n  return Math.round(1200 * (Math.log(f / b) / Math.log(2)));\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-note.svg)](https://www.npmjs.com/package/tonal-note)\n * [![tonal](https://img.shields.io/badge/tonal-note-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-note` is a collection of functions to manipulate musical notes in scientific notation\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * import * as note from 'tonal-note'\n * // or var note = require('tonal-note')\n * note.name('bb2') // => 'Bb2'\n * note.chroma('bb2') // => 10\n * note.enharmonics('C#6') // => [ 'B##5', 'C#6', 'Db6' ]\n * note.simplify('B#3') // => 'C4'\n *\n * // using ES6 import syntax\n * import { name } from 'tonal-note'\n * ['c', 'db3', '2', 'g+', 'gx4'].map(name)\n * // => ['C', 'Db3', null, null, 'G##4']\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-note](https://nodei.co/npm/tonal-note.png?mini=true)](https://npmjs.org/package/tonal-note/)\n *\n * ## API Documentation\n *\n * @module note\n */\nimport { build, parse } from \"note-parser\";\nimport { fifths, asNotePitch, strNote, parseIvl, decode } from \"tonal-pitch\";\nimport { transpose as tr } from \"tonal-transpose\";\nimport { toMidi, note as midiToNote } from \"tonal-midi\";\nimport { toFreq } from \"tonal-freq\";\n\nvar cache = {};\nfunction parseNote(name) {\n  if (typeof name !== \"string\") return null;\n  return cache[name] || (cache[name] = parse(name));\n}\n\n/**\n * Get the note midi number\n * (an alias of tonal-midi `toMidi` function)\n *\n * @function\n * @param {Array|String|Number} note - the note to get the midi number from\n * @return {Integer} the midi number or null if not valid pitch\n * @example\n * note.midi('C4') // => 60\n * @see midi.toMidi\n */\nexport var midi = toMidi;\n\n/**\n * Get the note name of a given midi note number\n * (an alias of tonal-midi `note` function)\n *\n * @function\n * @param {Integer} midi - the midi note number\n * @param {Boolean} useSharps - (Optional) set to true to use sharps instead of flats\n * @return {String} the note name\n * @example\n * note.fromMidi(60) // => 'C4'\n * @see midi.note\n */\nexport var fromMidi = midiToNote;\n\n/**\n * Get the frequency of a note\n * (an alias of the tonal-note package `toFreq` function)\n *\n * @function\n * @param {Array|String|Number} note - the note to get the frequency\n * @return {Number} the frequency\n * @example\n * note.freq('A4') // => 440\n * @see freq.toFreq\n */\nexport var freq = toFreq;\n\n/**\n * Return the chroma of a note. The chroma is the numeric equivalent to the\n * pitch class, where 0 is C, 1 is C# or Db, 2 is D... 11 is B\n *\n * @param {String|Pitch} note\n * @return {Integer} the chroma\n * @example\n * var note = require('tonal-note')\n * note.chroma('Cb') // => 11\n * ['C', 'D', 'E', 'F'].map(note.chroma) // => [0, 2, 4, 5]\n */\nexport function chroma(n) {\n  var p = parseNote(n);\n  return p ? p.chroma : null;\n}\n\n/**\n * Given a note (as string or as array notation) returns a string\n * with the note name in scientific notation or null\n * if not valid note\n *\n * Can be used to test if a string is a valid note name.\n *\n * @function\n * @param {Pitch|String}\n * @return {String}\n *\n * @example\n * var note = require('tonal-note')\n * note.name('cb2') // => 'Cb2'\n * ['c', 'db3', '2', 'g+', 'gx4'].map(note.name) // => ['C', 'Db3', null, null, 'G##4']\n */\nexport function name(n) {\n  var p = asNotePitch(n);\n  return p ? strNote(p) : null;\n}\n\n/**\n * @deprecated\n * An alias for note. Get the name of a note in scientific notation\n * @function\n */\nexport function note(n) {\n  console.warn(\"note.note() is deprecated. Use note.name()\");\n  return name(n);\n}\n\n/**\n * @deprecated\n * Get note properties. It returns an object with the following properties:\n *\n * - step: 0 for C, 6 for B. Do not confuse with chroma\n * - alt: 0 for not accidentals, positive sharps, negative flats\n * - oct: the octave number or undefined if a pitch class\n *\n * @param {String|Pitch} note - the note\n * @return {Object} the object with note properties or null if not valid note\n * @example\n * note.props('Db3') // => { step: 1, alt: -1, oct: 3 }\n * note.props('C#') // => { step: 0, alt: 1, oct: undefined }\n */\nexport function props(n) {\n  console.warn(\n    \"note.props() is deprecated. Use: note.step(), note.alt() or note.oct()\"\n  );\n  var p = asNotePitch(n);\n  if (!p) return null;\n  var d = decode(p);\n  return { step: d[0], alt: d[1], oct: d[2] };\n}\n\n/**\n * @deprecated\n * Given a note properties object, return the string representation if\n * scientific notation\n *\n * @param {Object} noteProps - an object with the following attributes:\n * @return {String} the note name\n *\n * - step: a number from 0 to 6 meaning note step letter from 'C' to 'B'\n * - alt: the accidentals as number (0 no accidentals, 1 is '#', 2 is '##', -2 is 'bb')\n * - oct: (Optional) the octave. If not present (or undefined) it returns a pitch class\n *\n * @example\n * note.fromProps({ step: 1, alt: -1, oct: 5 }) // => 'Db5'\n * note.fromProps({ step: 0, alt: 1 }) // => 'C#'\n */\nexport function fromProps(props) {\n  console.warn(\"note.fromProps() is deprecated. See npm package note-parser.\");\n  return props ? build(props.step, props.alt, props.oct) : null;\n}\n\nfunction getProp(name) {\n  return function(n) {\n    var p = props(n);\n    return p ? p[name] : null;\n  };\n}\n\n/**\n * Get the octave of the given pitch\n *\n * @function\n * @param {String|Pitch} note - the note\n * @return {Integer} the octave, undefined if its a pitch class or null if\n * not a valid note\n * @example\n * note.oct('C#4') // => 4\n * note.oct('C') // => undefined\n * note.oct('blah') // => undefined\n */\nexport var oct = getProp(\"oct\");\n\n/**\n * Get the note step: a number equivalent of the note letter. 0 means C and\n * 6 means B. This is different from `chroma` (see example)\n *\n * @function\n * @param {String|Pitch} note - the note\n * @return {Integer} a number between 0 and 6 or null if not a note\n * @example\n * note.step('C') // => 0\n * note.step('Cb') // => 0\n * // usually what you need is chroma\n * note.chroma('Cb') // => 6\n */\nexport var step = getProp(\"step\");\n\n/**\n * @deprecated\n * Get the note step in fifths from 'C'. One property of the perfect fifth\n * interval is that you can obtain any pitch class by transposing 'C' a\n * number of times. This function return that number.\n * @param {String|Pitch} note - the note (can be a pitch class)\n * @return {Integer} the number of fifths to reach that pitch class from 'C'\n */\nexport function pcFifths(note) {\n  console.warn(\"Deprecated. Do you really need this?\");\n  var p = asNotePitch(note);\n  return p ? fifths(p) : null;\n}\n\n/**\n * Get the note alteration: a number equivalent to the accidentals. 0 means\n * no accidentals, negative numbers are for flats, positive for sharps\n *\n * @function\n * @param {String|Pitch} note - the note\n * @return {Integer} the alteration\n * @example\n * note.alt('C') // => 0\n * note.alt('C#') // => 1\n * note.alt('Cb') // => -1\n */\nexport var alt = getProp(\"alt\");\n\n/**\n * Get pitch class of a note. The note can be a string or a pitch array.\n *\n * @function\n * @param {String|Pitch}\n * @return {String} the pitch class\n * @example\n * tonal.pc('Db3') // => 'Db'\n * tonal.map(tonal.pc, 'db3 bb6 fx2') // => [ 'Db', 'Bb', 'F##']\n */\nexport function pc(n) {\n  var p = asNotePitch(n);\n  return p ? strNote([p[0], [fifths(p)]]) : null;\n}\n\nvar ASC = parseIvl(\"2d\");\nvar DESC = parseIvl(\"-2d\");\n\n/**\n * Get the enharmonics of a note. It returns an array of three elements: the\n * below enharmonic, the note, and the upper enharmonic\n *\n * @param {String} note - the note to get the enharmonics from\n * @return {Array} an array of pitches ordered by distance to the given one\n *\n * @example\n * var note = require('tonal-note')\n * note.enharmonics('C') // => ['B#', 'C', 'Dbb']\n * note.enharmonics('A') // => ['G##', 'A', 'Bbb']\n * note.enharmonics('C#4') // => ['B##3', 'C#4' 'Db4']\n * note.enharmonics('Db') // => ['C#', 'Db', 'Ebbb'])\n */\nexport function enharmonics(pitch) {\n  console.warn(\"Deprecated. Use find() from tonal-enhramonics\");\n  var notes = [];\n  notes.push(tr(DESC, pitch));\n  if (notes[0] === null) return null;\n  notes.push(pitch);\n  notes.push(tr(ASC, pitch));\n  return notes;\n}\n\n/**\n * Get a simpler enharmonic note name from a note if exists\n *\n * @param {String} note - the note to simplify\n * @return {String} the simplfiied note (if not found, return same note)\n *\n * @example\n * var note = require('tonal-note')\n * note.simplify('B#3') // => 'C4'\n */\nexport function simplify(pitch) {\n  console.warn(\"Deprecated. Use simplify() from tonal-enhramonics\");\n  return enharmonics(pitch).reduce(function(simple, next) {\n    if (!simple) return next;\n    return simple.length > next.length ? next : simple;\n  }, null);\n}\n","// shorthand tonal notation (with quality after number)\nvar IVL_TNL = '([-+]?)(\\\\d+)(d{1,4}|m|M|P|A{1,4})'\n// standard shorthand notation (with quality before number)\nvar IVL_STR = '(AA|A|P|M|m|d|dd)([-+]?)(\\\\d+)'\nvar COMPOSE = '(?:(' + IVL_TNL + ')|(' + IVL_STR + '))'\nvar IVL_REGEX = new RegExp('^' + COMPOSE + '$')\n\n/**\n * Parse a string with an interval in shorthand notation (https://en.wikipedia.org/wiki/Interval_(music)#Shorthand_notation)\n * and returns an object with interval properties.\n *\n * @param {String} str - the string with the interval\n * @param {Boolean} strict - (Optional) if its false, it doesn't check if the\n * interval is valid or not. For example, parse('P2') returns null\n * (because a perfect second is not a valid interval), but\n * parse('P2', false) it returns { num: 2, dir: 1, q: 'P'... }\n * @return {Object} an object properties or null if not valid interval string\n * The returned object contains:\n * - `num`: the interval number\n * - `q`: the interval quality string (M is major, m is minor, P is perfect...)\n * - `simple`: the simplified number (from 1 to 7)\n * - `dir`: the interval direction (1 ascending, -1 descending)\n * - `type`: the interval type (P is perfectable, M is majorable)\n * - `alt`: the alteration, a numeric representation of the quality\n * - `oct`: the number of octaves the interval spans. 0 for simple intervals.\n * - `size`: the size of the interval in semitones\n * @example\n * var parse = require('interval-notation').parse\n * parse('M3')\n * // => { num: 3, q: 'M', dir: 1, simple: 3,\n * //      type: 'M', alt: 0, oct: 0, size: 4 }\n */\nexport function parse (str, strict) {\n  if (typeof str !== 'string') return null\n  var m = IVL_REGEX.exec(str)\n  if (!m) return null\n  var i = { num: +(m[3] || m[8]), q: m[4] || m[6] }\n  i.dir = (m[2] || m[7]) === '-' ? -1 : 1\n  var step = (i.num - 1) % 7\n  i.simple = step + 1\n  i.type = TYPES[step]\n  i.alt = qToAlt(i.type, i.q)\n  i.oct = Math.floor((i.num - 1) / 7)\n  i.size = i.dir * (SIZES[step] + i.alt + 12 * i.oct)\n  if (strict !== false) {\n    if (i.type === 'M' && i.q === 'P') return null\n  }\n  return i\n}\nvar SIZES = [0, 2, 4, 5, 7, 9, 11]\n\nvar TYPES = 'PMMPPMM'\n/**\n * Get the type of interval. Can be perfectavle ('P') or majorable ('M')\n * @param {Integer} num - the interval number\n * @return {String} `P` if it's perfectable, `M` if it's majorable.\n */\nexport function type (num) {\n  return TYPES[(num - 1) % 7]\n}\n\nfunction dirStr (dir) { return dir === -1 ? '-' : '' }\nfunction num (simple, oct) { return simple + 7 * oct }\n\n/**\n * Build a shorthand interval notation string from properties.\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.shorthand(3, 0, 0, 1) // => 'M3'\n * interval.shorthand(3, -1, 0, -1) // => 'm-3'\n * interval.shorthand(3, 1, 1, 1) // => 'A10'\n */\nexport function shorthand (simple, alt, oct, dir) {\n  return altToQ(simple, alt) + dirStr(dir) + num(simple, oct)\n}\n/**\n * Build a special shorthand interval notation string from properties.\n * The special shorthand interval notation changes the order or the standard\n * shorthand notation so instead of 'M-3' it returns '-3M'.\n *\n * The standard shorthand notation has a string 'A4' (augmented four) that can't\n * be differenciate from 'A4' (the A note in 4th octave), so the purpose of this\n * notation is avoid collisions\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.build(3, 0, 0, 1) // => '3M'\n * interval.build(3, -1, 0, -1) // => '-3m'\n * interval.build(3, 1, 1, 1) // => '10A'\n */\nexport function build (simple, alt, oct, dir) {\n  return dirStr(dir) + num(simple, oct) + altToQ(simple, alt)\n}\n\n/**\n * Get an alteration number from an interval quality string.\n * It accepts the standard `dmMPA` but also sharps and flats.\n *\n * @param {Integer|String} num - the interval number or a string representing\n * the interval type ('P' or 'M')\n * @param {String} quality - the quality string\n * @return {Integer} the interval alteration\n * @example\n * qToAlt('M', 'm') // => -1 (for majorables, 'm' is -1)\n * qToAlt('P', 'A') // => 1 (for perfectables, 'A' means 1)\n * qToAlt('M', 'P') // => null (majorables can't be perfect)\n */\nexport function qToAlt (num, q) {\n  var t = typeof num === 'number' ? type(num) : num\n  if (q === 'M' && t === 'M') return 0\n  if (q === 'P' && t === 'P') return 0\n  if (q === 'm' && t === 'M') return -1\n  if (/^A+$/.test(q)) return q.length\n  if (/^d+$/.test(q)) return t === 'P' ? -q.length : -q.length - 1\n  return null\n}\n\nfunction fillStr (s, n) { return Array(Math.abs(n) + 1).join(s) }\n/**\n * Get interval quality from interval type and alteration\n *\n * @function\n * @param {Integer|String} num - the interval number of the the interval\n * type ('M' for majorables, 'P' for perfectables)\n * @param {Integer} alt - the interval alteration\n * @return {String} the quality string\n * @example\n * altToQ('M', 0) // => 'M'\n */\nexport function altToQ (num, alt) {\n  var t = typeof num === 'number' ? type(Math.abs(num)) : num\n  if (alt === 0) return t === 'M' ? 'M' : 'P'\n  else if (alt === -1 && t === 'M') return 'm'\n  else if (alt > 0) return fillStr('A', alt)\n  else if (alt < 0) return fillStr('d', t === 'P' ? alt : alt + 1)\n  else return null\n}\n\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-interval.svg)](https://www.npmjs.com/package/tonal-interval)\n * [![tonal](https://img.shields.io/badge/tonal-interval-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-interval` is a collection of functions to create and manipulate music intervals.\n *\n * The intervals are strings in shorthand notation. Two variations are supported:\n *\n * - standard shorthand notation: type and number, for example: 'M3', 'd-4'\n * - inverse shorthand notation: number and then type, for example: '3M', '-4d'\n *\n * The problem with the standard shorthand notation is that some strings can be\n * parsed as notes or intervals, for example: 'A4' can be note A in 4th octave\n * or an augmented four. To remove ambiguity, the prefered notation in tonal is the\n * inverse shortand notation.\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * import * as interval from 'tonal-interval'\n * // or var interval = require('tonal-interval')\n * interval.semitones('4P') // => 5\n * interval.invert('3m') // => '6M'\n * interval.simplify('9m') // => '2m'\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-interval](https://nodei.co/npm/tonal-interval.png?mini=true)](https://npmjs.org/package/tonal-interval/)\n *\n * ## API Documentation\n *\n * @module interval\n */\nimport { build } from \"interval-notation\";\nimport {\n  asIvlPitch,\n  ivlFn,\n  chr,\n  dir,\n  strIvl,\n  encode,\n  decode,\n  height\n} from \"tonal-pitch\";\n\n/**\n * Get interval name. Can be used to test if it's an interval. It accepts intervals\n * as pitch or string in shorthand notation or tonal notation. It returns always\n * intervals in tonal notation.\n *\n * @param {String|Pitch} interval - the interval string or array\n * @return {String} the interval name or null if not valid interval\n * @example\n * interval.toInterval('m-3') // => '-3m'\n * interval.toInterval('3') // => null\n */\nexport function toInterval(ivl) {\n  var i = asIvlPitch(ivl);\n  return i ? strIvl(i) : null;\n}\n\n/**\n * Get the number of the interval (same as value, but always positive)\n *\n * @param {String|Pitch} interval - the interval\n * @return {Integer} the positive interval number (P1 is 1, m2 is 2, ...)\n * @example\n * interval.num('m2') // => 2\n * interval.num('P9') // => 9\n * interval.num('P-4') // => 4\n */\nexport function num(ivl) {\n  var p = props(ivl);\n  return p ? p.num : null;\n}\n\n/**\n * Get the interval value (the interval number, but positive or negative\n * depending the interval direction)\n *\n * @param {String|Pitch} interval - the interval\n * @return {Integer} the positive interval number (P1 is 1, m-2 is -2, ...)\n * @example\n * interval.num('m2') // => 2\n * interval.num('m9') // => 9\n * interval.num('P-4') // => -4\n * interval.num('m-9') // => -9\n */\nexport function value(ivl) {\n  var p = props(ivl);\n  return p ? p.num * p.dir : null;\n}\n\n/**\n * Get interval properties. It returns an object with:\n *\n * - num: the interval number (always positive)\n * - alt: the interval alteration (0 for perfect in perfectables, or 0 for major in _majorables_)\n * - dir: the interval direction (1 ascending, -1 descending)\n *\n * @param {String|Pitch} interval - the interval\n * @return {Array} the interval in the form [number, alt]\n * @example\n * interval.parse('m2') // => { num: 2, alt: -1, dir: 1 }\n * interval.parse('m9') // => { num: 9, alt: -1, dir: 1 }\n * interval.parse('P-4') // => { num: 4, alt: 0, dir: -1}\n * interval.parse('m-9') // => { num: 9, alt: -1, dir: -1 }\n */\nexport function props(ivl) {\n  var i = asIvlPitch(ivl);\n  if (!i) return null;\n  var d = decode(i);\n  return { num: d[0] + 1 + d[2] * 7, alt: d[1], dir: i[2] };\n}\n\n/**\n * Given a interval property object, get the interval name\n *\n * @param {Object} props - the interval property object\n *\n * - num: the interval number\n * - alt: the interval alteration\n * - dir: the direction\n * @return {String} the interval name\n */\nexport function fromProps(props) {\n  if (!props || props.num < 1) return null;\n  var octs = Math.floor(props.num / 8);\n  var simple = props.num - 7 * octs;\n  return build(simple, props.alt || 0, octs, props.dir);\n}\n\n/**\n * Get size in semitones of an interval\n * @param {String|Pitch} ivl\n * @return {Integer} the number of semitones or null if not an interval\n * @example\n * import { semitones } from 'tonal-interval'\n * semitones('P4') // => 5\n * // or using tonal\n * tonal.semitones('P5') // => 7\n */\nexport function semitones(ivl) {\n  var i = asIvlPitch(ivl);\n  return i ? height(i) : null;\n}\n\n// interval numbers\nvar IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];\n// interval qualities\nvar IQ = \"P m M m M P d P m M m M\".split(\" \");\n\n/**\n * Get interval name from semitones number. Since there are several interval\n * names for the same number, the name it's arbitraty, but deterministic.\n * @param {Integer} num - the number of semitones (can be negative)\n * @return {String} the interval name\n * @example\n * import { fromSemitones } from 'tonal-interval'\n * fromSemitones(7) // => '5P'\n * // or using tonal\n * tonal.fromSemitones(-7) // => '-5P'\n */\nexport function fromSemitones(num) {\n  var d = num < 0 ? -1 : 1;\n  var n = Math.abs(num);\n  var c = n % 12;\n  var o = Math.floor(n / 12);\n  return d * (IN[c] + 7 * o) + IQ[c];\n}\n\nvar CLASSES = [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1];\n/**\n * Get the [interval class](https://en.wikipedia.org/wiki/Interval_class)\n * number of a given interval.\n *\n * In musical set theory, an interval class is the shortest distance in\n * pitch class space between two unordered pitch classes\n *\n * As paramter you can pass an interval in shorthand notation, an interval in\n * array notation or the number of semitones of the interval\n *\n * @param {String|Integer} interval - the interval or the number of semitones\n * @return {Integer} A value between 0 and 6\n *\n * @example\n * interval.ic('P8') // => 0\n * interval.ic('m6') // => 4\n * ['P1', 'M2', 'M3', 'P4', 'P5', 'M6', 'M7'].map(ic) // => [0, 2, 4, 5, 5, 3, 1]\n */\nexport function ic(ivl) {\n  var i = asIvlPitch(ivl);\n  var s = i ? chr(i) : Math.round(ivl);\n  return isNaN(s) ? null : CLASSES[Math.abs(s) % 12];\n}\n\nvar TYPES = \"PMMPPMM\";\n/**\n * Get interval type. Can be perfectable (1, 4, 5) or majorable (2, 3, 6, 7)\n * It does NOT return the actual quality.\n *\n * @param {String|Pitch} interval\n * @return {String} 'P' for perfectables, 'M' for majorables or null if not\n * valid interval\n * @example\n * interval.type('5A') // => 'P'\n */\nexport function type(ivl) {\n  var i = asIvlPitch(ivl);\n  return i ? TYPES[decode(i)[0]] : null;\n}\n\n/**\n * Get the inversion (https://en.wikipedia.org/wiki/Inversion_(music)#Intervals)\n * of an interval.\n *\n * @function\n * @param {String|Pitch} interval - the interval to invert in interval shorthand\n * notation or interval array notation\n * @return {String|Pitch} the inverted interval\n *\n * @example\n * interval.invert('3m') // => '6M'\n * interval.invert('2M') // => '7m'\n */\nexport var invert = ivlFn(function(i) {\n  var d = decode(i);\n  // d = [step, alt, oct]\n  var step = (7 - d[0]) % 7;\n  var alt = TYPES[d[0]] === \"P\" ? -d[1] : -(d[1] + 1);\n  return encode(step, alt, d[2], dir(i));\n});\n\n/**\n * Get the simplified version of an interval.\n *\n * @function\n * @param {String|Array} interval - the interval to simplify\n * @return {String|Array} the simplified interval\n *\n * @example\n * interval.simplify('9M') // => '2M'\n * ['8P', '9M', '10M', '11P', '12P', '13M', '14M', '15P'].map(interval.simplify)\n * // => [ '8P', '2M', '3M', '4P', '5P', '6M', '7M', '8P' ]\n * interval.simplify('2M') // => '2M'\n * interval.simplify('-2M') // => '7m'\n */\nexport var simplify = ivlFn(function(i) {\n  // decode to [step, alt, octave]\n  var dec = decode(i);\n  // if it's not 8 reduce the octaves to 0\n  if (dec[0] !== 0 || dec[2] !== 1) dec[2] = 0;\n  // encode back\n  return encode(dec[0], dec[1], dec[2], dir(i));\n});\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-pcset.svg?style=flat-square)](https://www.npmjs.com/package/tonal-pcset)\n * [![tonal](https://img.shields.io/badge/tonal-pcset-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-pcset` is a collection of functions to work with pitch class sets, oriented\n * to make comparations (isEqual, isSubset, isSuperset)\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * You can install via npm: `npm i --save tonal-pcset`\n *\n * ```js\n * var pcset = require('tonal-pcset')\n * pcset.isEqual('c2 d5 e6', 'c6 e3 d1') // => true\n * ```\n *\n * ## API documentation\n *\n * @module pcset\n */\nimport { chr, asPitch } from \"tonal-pitch\";\nimport { pc } from \"tonal-note\";\nimport { map, asArr, rotate, compact } from \"tonal-array\";\nimport { transpose } from \"tonal-transpose\";\n\nfunction chrToInt(set) {\n  return parseInt(chroma(set), 2);\n}\nfunction pitchChr(p) {\n  p = asPitch(p);\n  return p ? chr(p) : null;\n}\n\n/**\n * Get chroma of a pitch class set. A chroma identifies each set uniquely.\n * It's a 12-digit binary each presenting one semitone of the octave.\n *\n * Note that this function accepts a chroma as parameter and return it\n * without modification.\n *\n * @param {Array|String} set - the pitch class set\n * @return {String} a binary representation of the pitch class set\n * @example\n * pcset.chroma('C D E') // => '1010100000000'\n */\nexport function chroma(set) {\n  if (isChroma(set)) return set;\n  var b = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  map(pitchChr, set).forEach(function(i) {\n    b[i] = 1;\n  });\n  return b.join(\"\");\n}\n\n/**\n * @deprecated\n * @see collection.pcset\n * Given a list of notes, return the pitch class names of the set\n * starting with the first note of the list\n * @param {String|Array} notes - the pitch class set notes\n * @return {Array} an array of pitch class sets\n */\nexport function notes(notes) {\n  // FIXME: move to collection\n  console.warn(\"pcset.notes deprecated. Use collection.pcset\");\n  var pcs = map(pc, notes);\n  if (!pcs.length) return pcs;\n  var tonic = pcs[0];\n  // since the first note of the chroma is always C, we have to rotate it\n  var rotated = rotate(pitchChr(tonic), chroma(pcs).split(\"\")).join(\"\");\n  return fromChroma(rotated, tonic);\n}\n\n/**\n * Given a a list of notes or a pcset chroma, produce the rotations\n * of the chroma discarding the ones that starts with '0'\n *\n * This is used, for example, to get all the modes of a scale.\n *\n * @param {Array|String} set - the list of notes or pitchChr of the set\n * @param {Boolean} normalize - (Optional, true by default) remove all\n * the rotations that starts with '0'\n * @return {Array<String>} an array with all the modes of the chroma\n *\n * @example\n * pcset.modes('C E G')\n */\nexport function modes(set, normalize) {\n  normalize = normalize !== false;\n  var binary = chroma(set).split(\"\");\n  return compact(\n    binary.map(function(_, i) {\n      var r = rotate(i, binary);\n      return normalize && r[0] === \"0\" ? null : r.join(\"\");\n    })\n  );\n}\n/**\n * @deprecated\n * @see modes\n */\nexport function chromaModes(set, norm) {\n  console.warn(\"pcset.chromaModes deprecated. Renamed to pcset.modes\");\n  return modes(set, norm);\n}\n\nvar REGEX = /^[01]{12}$/;\n\n/**\n * Test if the given string is a pitch class set chroma.\n * @param {String} chroma - the pitch class set chroma\n * @return {Boolean} true if its a valid pcset chroma\n * @example\n * pcset.isChroma('101010101010') // => true\n * pcset.isChroma('101001') // => false\n */\nexport function isChroma(set) {\n  return REGEX.test(set);\n}\n\nvar IVLS = \"1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M\".split(\" \");\n/**\n * Given a pcset (notes or chroma) return it's intervals\n * @param {String|Array} pcset - the pitch class set (notes or chroma)\n * @return {Array} intervals or empty array if not valid pcset\n * @example\n * pcset.intervals('1010100000000') => ['C', 'D', 'E']\n */\nexport function intervals(set) {\n  return compact(\n    chroma(set)\n      .split(\"\")\n      .map(function(d, i) {\n        return d === \"1\" ? IVLS[i] : null;\n      })\n  );\n}\n\n/**\n * @deprecated\n * @see intervals\n * Given a pitch class set in binary notation it returns the intervals or notes\n * (depending on the tonic)\n * @param {String} binary - the pitch class set in binary representation\n * @param {String|Pitch} tonic - the pitch class set tonic\n * @return {Array} a list of notes or intervals\n * @example\n * pcset.fromChroma('101010101010', 'C') // => ['C', 'D', 'E', 'Gb', 'Ab', 'Bb']\n */\nexport function fromChroma(binary, tonic) {\n  console.warn(\n    \"pcset.fromChroma is deprecated. Use pcset.intervals().map(...)\"\n  );\n  if (arguments.length === 1)\n    return function(t) {\n      return fromChroma(binary, t);\n    };\n  if (!tonic) tonic = \"P1\";\n  return intervals(binary).map(transpose(tonic));\n}\n\n/**\n * Test if two pitch class sets are identical\n *\n * @param {Array|String} set1 - one of the pitch class sets\n * @param {Array|String} set2 - the other pitch class set\n * @return {Boolean} true if they are equal\n * @example\n * pcset.isEqual('c2 d3', 'c5 d2') // => true\n */\nexport function isEqual(s1, s2) {\n  if (arguments.length === 1)\n    return function(s) {\n      return isEqual(s1, s);\n    };\n  return chroma(s1) === chroma(s2);\n}\nexport function equal(a, b) {\n  console.warn(\"pcset.equal is deprecated. Use pcset.isEqual\");\n  return isEqual(a, b);\n}\n\n/**\n * Test if a pitch class set is a subset of another\n *\n * @param {Array|String} set - the base set to test against\n * @param {Array|String} test - the set to test\n * @return {Boolean} true if the test set is a subset of the set\n * @example\n * pcset.subset('c d e', 'C2 D4 D5 C6') // => true\n */\nexport function isSubset(set, test) {\n  if (arguments.length === 1)\n    return function(t) {\n      return isSubset(set, t);\n    };\n  test = chrToInt(test);\n  return (test & chrToInt(set)) === test;\n}\nexport function subset(a, b) {\n  console.warn(\"pcset.subset is deprecated. Use pcset.isSubset\");\n  return isSubset(a, b);\n}\n\n/**\n * Test if a pitch class set is a superset\n *\n * @param {Array|String} set - the base set to test against\n * @param {Array|String} test - the set to test\n * @return {Boolean} true if the test set is a superset of the set\n * @example\n * pcset.isSuperset('c d e', 'C2 D4 F4 D5 E5 C6') // => true\n */\nexport function isSuperset(set, test) {\n  if (arguments.length === 1)\n    return function(t) {\n      return isSuperset(set, t);\n    };\n  test = chrToInt(test);\n  return (test | chrToInt(set)) === test;\n}\nexport function superset(a, b) {\n  console.warn(\"pcset.superset is deprecated. Use pcset.isSuperset\");\n  return isSuperset(a, b);\n}\n\n/**\n * Test if a given pitch class set includes a note\n * @param {Array|String} set - the base set to test against\n * @param {String|Pitch} note - the note to test\n * @return {Boolean} true if the note is included in the pcset\n * @example\n * pcset.includes('c d e', 'C4') // =A true\n * pcset.includes('c d e', 'C#4') // =A false\n */\nexport function includes(set, note) {\n  if (arguments.length > 1) return includes(set)(note);\n  set = chroma(set);\n  return function(note) {\n    return set[pitchChr(note)] === \"1\";\n  };\n}\n\n/**\n * Filter a list with a pitch class set\n *\n * @param {Array|String} set - the pitch class set notes\n * @param {Array|String} notes - the note list to be filtered\n * @return {Array} the filtered notes\n *\n * @example\n * pcset.filter('c d e', 'c2 c#2 d2 c3 c#3 d3') // => [ 'c2', 'd2', 'c3', 'd3' ])\n * pcset.filter('c2', 'c2 c#2 d2 c3 c#3 d3') // => [ 'c2', 'c3' ])\n */\nexport function filter(set, notes) {\n  if (arguments.length === 1)\n    return function(n) {\n      return filter(set, n);\n    };\n  return asArr(notes).filter(includes(set));\n}\n","/**\n * A collection of functions to create note ranges.\n *\n * @example\n * var range = require('tonal-range')\n * // ascending chromatic range\n * range.chromatic(['C4', 'E4']) // => ['C4', 'Db4', 'D4', 'Eb4', 'E4']\n * // descending chromatic range\n * range.chromatic(['E4', 'C4']) // => ['E4', 'Eb4', 'D4', 'Db4', 'C4']\n * // combining ascending and descending in complex ranges\n * range.chromatic(['C2', 'E2', 'D2']) // => ['C2', 'Db2', 'D2', 'Eb2', 'E2', 'Eb2', 'D2']\n * // numeric (midi note numbers) range\n * range.numeric('C4 E4 Bb3') // => [60, 61, 62, 63, 64]\n * // complex numeric range\n * range.numeric('C4 E4 Bb3') // => [60, 61, 62, 63, 64, 63, 62, 61, 60, 59, 58]\n * // create a scale range\n * range.pitchSet('c e g a', 'c2 c3 c2') // => [ 'C2', 'E2', 'G2', 'A2', 'C3', 'A2', 'G2', 'E2', 'C2' ] *\n g\n * @module range\n */\nimport { asArr, map } from \"tonal-array\";\nimport { trFifths } from \"tonal-transpose\";\nimport { toMidi, note } from \"tonal-midi\";\nimport { filter } from \"tonal-pcset\";\n\nfunction isNum(n) {\n  return typeof n === \"number\";\n}\n// convert notes to midi if needed\nfunction asNum(n) {\n  return isNum(n) ? n : toMidi(n);\n}\n// ascending range\nfunction ascR(b, n) {\n  for (var a = []; n--; a[n] = n + b);\n  return a;\n}\n// descending range\nfunction descR(b, n) {\n  for (var a = []; n--; a[n] = b - n);\n  return a;\n}\n// create a range between a and b\nfunction ran(a, b) {\n  return a === null || b === null\n    ? []\n    : a < b ? ascR(a, b - a + 1) : descR(a, a - b + 1);\n}\n\n/**\n * Create a numeric range. You supply a list of notes or numbers and it will\n * be conected to create complex ranges.\n *\n * @param {String|Array} list - the list of notes or numbers used\n * @return {Array} an array of numbers or empty array if not vald parameters\n *\n * @example\n * range.numeric([\"C5\", \"C4']) // => [ 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60 ]\n * // it works midi notes\n * range.numeric([10, 5]) // => [ 10, 9, 8, 7, 6, 5 ]\n * // complex range\n * range.numeric('C4 E4 Bb3') // => [60, 61, 62, 63, 64, 63, 62, 61, 60, 59, 58]\n * // can be expressed with a string or array\n * range.numeric('C2 C4 C2') === range.numeric(['C2', 'C4', 'C2'])\n */\nexport function numeric(list) {\n  return asArr(list)\n    .map(asNum)\n    .reduce(function(r, n, i) {\n      if (i === 1) return ran(r, n);\n      var last = r[r.length - 1];\n      return r.concat(ran(last, n).slice(1));\n    });\n}\n\n/**\n * Create a range of chromatic notes. The altered notes will use flats.\n *\n * @function\n * @param {String|Array} list - the list of notes or midi note numbers\n * @return {Array} an array of note names\n * @example\n * tonal.chromatic('C2 E2 D2') // => ['C2', 'Db2', 'D2', 'Eb2', 'E2', 'Eb2', 'D2']\n * // with sharps\n * tonal.chromatic('C2 C3', true) // => [ 'C2', 'C#2', 'D2', 'D#2', 'E2', 'F2', 'F#2', 'G2', 'G#2', 'A2', 'A#2', 'B2', 'C3' ]\n */\nexport function chromatic(list, sharps) {\n  return map(note(sharps === true), numeric(list));\n}\n\n/**\n * Create a range with a cycle of fifths\n * @function\n * @param {String|Pitch} tonic - the tonic note or pitch class\n * @param {Array|String} range - the range array\n * @return {Array} a range of cycle of fifths starting with the tonic\n * @example\n * range.fifths('C', [0, 6]) // => [ 'C', 'G', 'D', 'A', 'E', 'B', 'F#' ])\n */\nexport function fifths(tonic, range) {\n  return numeric(range).map(trFifths(tonic));\n}\n\n/**\n * Create a pitch set (scale or chord) range. Given a pitch set (a collection\n * of pitch classes), and a range array, it returns a range in notes.\n *\n * @param {String|Array|Function} scale - the scale to use or a function to\n * convert from midi numbers to note names\n * @param {String|Array} range - a list of notes or midi numbers\n * @return {Array} the scale range, an empty array if not valid source or\n * null if not valid start or end\n * @example\n * range.pitchSet('C D E F G A B', ['C3', 'C2'])\n * // => [ 'C3', 'B2', 'A2', 'G2', 'F2', 'E2', 'D2', 'C2' ]\n */\nexport function pitchSet(set, range) {\n  if (arguments.length === 1)\n    return function(l) {\n      return pitchSet(set, l);\n    };\n\n  return filter(set, chromatic(range));\n}\n","/**\n * Functions related to music notation in strings. Things like parse accidentals,\n * or convert from step to note letter.\n *\n * Glossary:\n *\n * - step: the number from 0 to 6 representing the letters from C to B\n * - letter: a valid note letter (from A to G)\n * - alteration: a number indicating the sharps (positive) or flats (negative)\n * - accidentals: a string with sharps (#) or flats (b)\n *\n * @example\n * var notation = require('tonal-notation')\n * notation.toAcc('3') // => '###'\n * notation.toAcc('-3') // => 'bbb'\n * notation.toAlt('###') // => 3\n * @module notation\n */\n\n/**\n * Given a letter, return step\n * @param {String} letter - the letter\n * @return {Integer} the step number (from 0 to 6)\n */\nexport function toStep(l) {\n  var s = \"CDEFGAB\".indexOf(l.toUpperCase());\n  return s < 0 ? null : s;\n}\n\n/**\n * Test if a number is a valid step number (a number from 0 to 6)\n * @param {Integer} step - the step number\n * @return {Boolean} true if it's a valid step number, false otherwise\n */\nexport function isStep(d) {\n  return !(d < 0 || d > 6);\n}\n\n/**\n * Given a step, return a letter\n * @param {Integer} step - the step number\n * @return {String} the note letter or null if not valid step number\n */\nexport function toLetter(s) {\n  return isStep(s) ? \"CDEFGAB\".charAt(s) : null;\n}\n\n// ACCIDENTALS\n// ===========\n\n/**\n * Test if a string are all flats (`b`) chars\n * @param {String} str - the string to test\n * @return {Boolean} true if all charaters are `b`, false otherwise\n */\nexport function areFlats(s) {\n  return /^b+$/.test(s);\n}\n/**\n * Test if a string are all sharps (`#`) chars\n * @param {String} str - the string to test\n * @return {Boolean} true if all charaters are `#`, false otherwise\n */\nexport function areSharps(s) {\n  return /^#+$/.test(s);\n}\n\n/**\n * Given an accidentals string return its alteration, the number\n * of semitones (positive for sharps, negative for flats, 0 for none)\n * @param {String} accidentals - the string to parse\n * @return {Integer} the alteration number of null if not a valid accidental strings\n * @example\n * toAlt('###') // => 3\n * toAlt('bbb') // => -3\n */\nexport function toAlt(s) {\n  return s === \"\"\n    ? 0\n    : areFlats(s) ? -s.length : areSharps(s) ? s.length : null;\n}\n\nfunction fillStr(s, num) {\n  return Array(num + 1).join(s);\n}\n\n/**\n * Given an alteration number, returns the accidentals string\n * @param {Integer} alteration - the number of semitones (positive and negative\n * values are accepted for sharps and flats)\n * @return {String} the accidental string\n * @example\n * toAcc(3) // => '###'\n * toAcc(-3) // => 'bbb'\n */\nexport function toAcc(n) {\n  return !n ? \"\" : n < 0 ? fillStr(\"b\", -n) : fillStr(\"#\", n);\n}\n","/**\n * _Key_ refers to the tonal system based on the major and minor scales. This is\n * is the most common tonal system, but tonality can be present in music\n * based in other scales or concepts.\n *\n * This is a collection of functions related to keys.\n *\n * @example\n * var key = require('tonal-key')\n * key.scale('E mixolydian') // => [ 'E', 'F#', 'G#', 'A', 'B', 'C#', 'D' ]\n * key.relative('minor', 'C major') // => 'A minor'\n *\n * @module key\n */\n\nimport { areFlats, areSharps, toAcc } from \"tonal-notation\";\nimport { trFifths } from \"tonal-transpose\";\nimport { pc, pcFifths } from \"tonal-note\";\nimport { numeric } from \"tonal-range\";\nimport { rotate } from \"tonal-array\";\nimport { harmonics, harmonize } from \"tonal-harmonizer\";\n\n// Order matters: use an array\nvar MODES = [\n  \"ionian\",\n  \"dorian\",\n  \"phrygian\",\n  \"lydian\",\n  \"mixolydian\",\n  \"aeolian\",\n  \"locrian\",\n  \"major\",\n  \"minor\"\n];\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5, 0, 3];\nvar SCALES = [0, 1, 2, 3, 4, 5, 6, 0, 5].map(function(n) {\n  return harmonics(rotate(n, [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"]));\n});\n\n// PRIVATE\n// Given a tonic, mode pair, return the key string\nfunction toKey(t, m) {\n  return !t ? m : t + \" \" + m;\n}\n// Given the alterations, return the major key\nfunction majorKey(n) {\n  return toKey(trFifths(\"C\", n), \"major\");\n}\n// given the mode name, return the alterations\nfunction modeNum(mode) {\n  return FIFTHS[MODES.indexOf(mode)];\n}\n// given a string, return the valid mode it represents or null\nfunction validMode(m) {\n  m = m.trim().toLowerCase();\n  return MODES.indexOf(m) === -1 ? null : m;\n}\n\n/**\n * Return the key properties, an object with { tonic, mode }\n *\n * @param {String} name - the key name\n * @return {Key} the key properties object or null if not a valid key\n * @example\n * var key = require('tonal-key')\n * key.props('C3 dorian') // => { tonic: 'C', mode: 'dorian' }\n * key.props('dorian') // => { tonic: false, mode: 'dorian' }\n * key.props('Ab bebop') // => null\n * key.props('blah') // => null\n */\nexport function props(str) {\n  if (typeof str !== \"string\") return null;\n  var ndx = str.indexOf(\" \");\n  var key;\n  if (ndx === -1) {\n    var p = pc(str);\n    key = p\n      ? { tonic: p, mode: \"major\" }\n      : { tonic: false, mode: validMode(str) };\n  } else {\n    key = { tonic: pc(str.slice(0, ndx)), mode: validMode(str.slice(ndx + 1)) };\n  }\n  return key.mode ? key : null;\n}\n\n/**\n * Test if a given name is a valid key name\n *\n * @param {String} name\n * @param {Boolean}\n * @example\n * key.isKeyName('C major') // => true\n * key.isKeyName('major') // => true\n * key.isKeyName('Bb bebop') // => false\n */\nexport function isKeyName(name) {\n  return props(name) !== null;\n}\n\n/**\n * Get the tonic of a key\n *\n * @param {String} key - the key\n * @return {String} the tonic or false is no tonic, or null if its not a valid key\n * @example\n * key.tonic('c3 major') // => 'C'\n * key.tonic('minor') // => false\n * key.tonic('bebop') // null\n */\nexport function tonic(key) {\n  return (props(key) || key || {}).tonic || null;\n}\n\n/**\n * Get the mode of a key. It can be used to test if its a valid key mode.\n *\n * @param {String}\n * @return {Boolean}\n * @example\n * key.mode('A dorian') // => 'dorian'\n * key.mode('DORIAN') // => 'dorian'\n * key.mode('mixophrygian') // => null\n */\nexport function mode(key) {\n  return (props(key) || key || {}).mode || null;\n}\n\n/**\n * Get relative of a key. Two keys are relative when the have the same\n * key signature (for example C major and A minor)\n *\n * It can be partially applied.\n *\n * @param {String} mode - the relative destination\n * @param {String} key - the key source\n * @example\n * key.relative('dorian', 'B major') // => 'C# dorian'\n * // partial application\n * var minor = key.relative('minor')\n * minor('C major') // => 'A minor'\n * minor('E major') // => 'C# minor'\n */\nexport function relative(rel, key) {\n  if (arguments.length === 1)\n    return function(k) {\n      return relative(rel, k);\n    };\n  rel = props(rel);\n  if (!rel || rel.tonic) return null;\n  key = props(key);\n  if (!key || !key.tonic) return null;\n  var tonic = trFifths(key.tonic, modeNum(rel.mode) - modeNum(key.mode));\n  return toKey(tonic, rel.mode);\n}\n\n/**\n * Get a list of the altered notes of a given key. The notes will be in\n * the same order than in the key signature.\n * @param {String|Nunber} key\n * @return {Array}\n * @example\n * var key = require('tonal-keys')\n * key.alteredNotes('Eb major') // => [ 'Bb', 'Eb', 'Ab' ]\n */\nexport function alteredNotes(key) {\n  var alt = alteration(key);\n  return alt === null\n    ? null\n    : alt < 0\n      ? numeric([-1, alt]).map(trFifths(\"F\"))\n      : numeric([1, alt]).map(trFifths(\"B\"));\n}\n\n/**\n * Get a list of valid mode names. The list of modes will be always in\n * increasing order (ionian to locrian)\n *\n * @param {Boolean} alias - true to get aliases names\n * @return {Array} an array of strings\n * @example\n * key.modes() // => [ 'ionian', 'dorian', 'phrygian', 'lydian',\n * // 'mixolydian', 'aeolian', 'locrian' ]\n * key.modes(true) // => [ 'ionian', 'dorian', 'phrygian', 'lydian',\n * // 'mixolydian', 'aeolian', 'locrian', 'major', 'minor' ]\n */\nexport function modes(alias) {\n  return alias ? MODES.slice() : MODES.slice(0, -2);\n}\n\n/**\n * Create a major key from alterations\n * @function\n * @param {Integer} alt - the alteration number (positive sharps, negative flats)\n * @return {Key} the key object\n * @example\n * var key = require('tonal-key')\n * key.fromAlter(2) // => 'D major'\n */\nexport function fromAlter(n) {\n  return typeof n === \"number\" ? majorKey(n) : null;\n}\n\n/**\n * Get key name from accidentals\n *\n * @param {String} acc - the accidentals string\n * @return {Key} the key object\n * @example\n * var key = require('tonal-key')\n * key.fromAcc('b') // => 'F major'\n * key.fromAcc('##') // => 'D major'\n */\nexport function fromAcc(s) {\n  return areSharps(s)\n    ? majorKey(s.length)\n    : areFlats(s) ? majorKey(-s.length) : null;\n}\n\n/**\n * Get scale of a key\n *\n * @param {String|Object} key\n * @return {Array} the key scale\n * @example\n * key.scale('A major') // => [ 'A', 'B', 'C#', 'D', 'E', 'F#', 'G#' ]\n * key.scale('Bb minor') // => [ 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab' ]\n * key.scale('C dorian') // => [ 'C', 'D', 'Eb', 'F', 'G', 'A', 'Bb' ]\n * key.scale('E mixolydian') // => [ 'E', 'F#', 'G#', 'A', 'B', 'C#', 'D' ]\n */\nexport function scale(key) {\n  var p = props(key);\n  if (!p || !p.tonic) return null;\n  return harmonize(SCALES[MODES.indexOf(p.mode)], p.tonic);\n}\n\n/**\n * Get key alteration. The alteration is a number indicating the number of\n * sharpen notes (positive) or flaten notes (negative)\n * @param {String|Integer} key\n * @return {Integer}\n * @example\n * var key = require('tonal-keys')\n * key.alteration('A major') // => 3\n */\nexport function alteration(key) {\n  var k = props(key);\n  if (!k || !k.tonic) return null;\n  var toMajor = modeNum(k.mode);\n  var toC = pcFifths(k.tonic);\n  return toC - toMajor;\n}\n\n/**\n * Get the signature of a key. The signature is a string with sharps or flats.\n * @example\n * var key = require('tonal-keys')\n * key.signature('A major') // => '###'\n */\nexport function signature(key) {\n  return toAcc(alteration(key));\n}\n\n/**\n * An alias for `signature()`\n * @function\n */\nexport var accidentals = signature;\n","import { map, compact, sort } from \"tonal-array\";\nimport { pc } from \"tonal-note\";\nimport { chroma, modes } from \"tonal-pcset\";\n\n/**\n * This module contains functions to query tonal dictionaries.\n *\n * A tonal dictionary is basically a map from keys to list of intervals. It\n * also supports name aliases. See `tonal-chords` or `tonal-scales` to examples\n * of dictionaries.\n *\n * This functions are quite low level, and probably you wont need it, because\n * they are friendly served via `tonal-chords` and `tonal-scales`.\n *\n * __Those functions are NOT visible via `tonal` package__.\n *\n * @module dictionary\n */\nfunction id(x) {\n  return x;\n}\n\n/**\n * Create a tonal dictionary. A dictionary is an object with two functions: get and\n * keys.\n *\n * The data given to this constructor it's a HashMap in the form:\n * `{ key: [intervals, [aliases]] }`\n *\n * @param {HashMap} data - the dictionary data\n * @return {Object} the dictionary object\n *\n * @example\n * var dictionary = require('tonal-dictionary').dictionary\n * var DATA = {\n * 'maj7': ['1 3 5 7', ['Maj7']],\n *   'm7': ['1 b3 5 7']\n * }\n * var chords = dictionary(DATA, function (str) { return str.split(' ') })\n * chords.get('maj7') // => [ '1', '3', '5', '7' ]\n * chords.get('Maj7') // => [ '1', '3', '5', '7' ]\n * chords.get('m7') // => ['1', 'b3', '5', '7']\n * chords.get('m7b5') // => null\n * chords.keys() // => ['maj7', 'm7']\n * chords.keys(true) // => ['maj7', 'm7', 'Maj7']\n */\nexport function dictionary(raw, parse) {\n  parse = parse || id;\n  var byKey = {};\n  var names = Object.keys(raw);\n  var aliases = [];\n  names.forEach(function(k) {\n    var value = parse(raw[k][0]);\n    byKey[k] = value;\n    if (raw[k][1]) {\n      raw[k][1].forEach(function(alias) {\n        byKey[alias] = value;\n        aliases.push(alias);\n      });\n    }\n  });\n  return {\n    /**\n     * Get a value by key\n     * @name get\n     * @function\n     * @param {String} key\n     * @return {Object} the value (normally an array of intervals or notes)\n     * @memberof dictionary\n     */\n    get: function(n) {\n      return byKey[n];\n    },\n    /**\n     * Get the valid keys of dictionary\n     * @name keys\n     * @function\n     * @param {Boolean} aliases - (Optional) include aliases names (false by default)\n     * @param {Function} filter - a function to filter the names. It receives the\n     * name and the value as parameters\n     * @return {Array<String>} the keys\n     * @memberof dictionary\n     */\n    keys: function(all, filter) {\n      var keys = all ? names.concat(aliases) : names.slice();\n      return typeof filter !== \"function\"\n        ? keys\n        : keys.filter(function(k) {\n            return filter(k, byKey[k]);\n          });\n    }\n  };\n}\n\n/**\n * Create a pitch set detector. Given a dictionary data, it returns a\n * function that tries to detect a given pitch set inside the dictionary\n *\n * @param {Dictionary} dictionary - the dictionary object\n * @param {Function|String} builder - (Optional) a function that given a name and a tonic,\n * returns the object or a string to join both\n * @return {Function} the detector function\n * @see chord.detect\n * @see scale.detect\n * @example\n * var detect = detector(dictionary(DATA), '')\n * detect('c d e b') // => 'Cmaj/'\n */\nexport function detector(dict, build) {\n  var isSep = typeof build === \"string\";\n  var isFn = typeof build === \"function\";\n  var nameByChroma = dict.keys(false).reduce(function(map, key) {\n    map[chroma(dict.get(key))] = key;\n    return map;\n  }, {});\n\n  return function(notes) {\n    notes = sort(map(pc, notes));\n    var sets = modes(notes);\n    return compact(\n      sets.map(function(set, i) {\n        var type = nameByChroma[set];\n        if (!type) return null;\n        var tonic = notes[i];\n        return isSep\n          ? tonic + build + type\n          : isFn ? build(type, tonic) : [type, tonic];\n      })\n    );\n  };\n}\n","/**\n * A scale is a collection of pitches in ascending or descending order.\n *\n * This module provides functions to get and manipulate scales.\n *\n * @example\n * scale.notes('Ab bebop') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'G' ]\n * scale.get('hungarian major', 'B3') // => [ 'B3', 'C##4', 'D#4', 'E#4', 'F#4', 'G#4', 'A4'\n * scale.get('C E F G', 'F') // => [ 'F', 'A', 'Bb', 'C' ]\n * scale.get('1P 2M 3M 5P 6M', 'D4') // => [ 'D4', 'E4', 'F#4', 'A4', 'B4' ]\n * scale.names() => ['major', 'minor', ...]\n * scale.detect('f5 d2 c5 b5 a2 e4 g') // => [ 'C major', 'D dorian', 'E phrygian', 'F lydian', 'G mixolydian', 'A aeolian', 'B locrian'])\n * @module scale\n */\nimport { dictionary, detector } from \"tonal-dictionary\";\nimport { map, compact } from \"tonal-array\";\nimport { pc, name as note } from \"tonal-note\";\nimport { harmonize } from \"tonal-harmonizer\";\nimport DATA from \"./scales.json\";\n\nvar dict = dictionary(DATA, function(str) {\n  return str.split(\" \");\n});\n\n/**\n * Transpose the given scale notes, intervals or name to a given tonic.\n * The returned scale is an array of notes (or intervals if you specify `false` as tonic)\n *\n * It returns null if the scale type is not in the scale dictionary\n *\n * This function is currified\n *\n * @param {String} source - the scale type, intervals or notes\n * @param {String} tonic - the scale tonic (or false to get intervals)\n * @return {Array} the scale notes\n *\n * @example\n * scale.get('bebop', 'Eb') // => [ 'Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'Db', 'D' ]\n * scale.get('major', false) // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]\n * var major = scale.get('major')\n * major('Db3') // => [ 'Db3', 'Eb3', 'F3', 'Gb3', 'Ab3', 'Bb3', 'C4' ]\n */\nexport function get(type, tonic) {\n  if (arguments.length === 1)\n    return function(t) {\n      return get(type, t);\n    };\n  var ivls = dict.get(type);\n  return ivls ? harmonize(ivls, tonic) : null;\n}\n\n/**\n * Return the available scale names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the scale names\n *\n * @example\n * var scale = require('tonal-scale')\n * scale.names() // => ['maj7', ...]\n */\nexport var names = dict.keys;\n\n/**\n * Get the notes (pitch classes) of a scale. It accepts either a scale name\n * (tonic and type) or a collection of notes.\n *\n * Note that it always returns an array, and the values are only pitch classes.\n *\n * @param {String|Array} src - the scale name (it must include the scale type and\n * a tonic. The tonic can be a note or a pitch class) or the list of notes\n * @return {Array} the scale pitch classes\n *\n * @example\n * scale.notes('C major') // => [ 'C', 'D', 'E', 'F', 'G', 'A', 'B' ]\n * scale.notes('C4 major') // => [ 'C', 'D', 'E', 'F', 'G', 'A', 'B' ]\n * scale.notes('Ab bebop') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'G' ]\n * scale.notes('C4 D6 E2 c7 a2 b5 g2 g4 f') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n */\nexport function notes(name) {\n  var scale = parse(name);\n  var notes = scale.tonic ? get(scale.type, pc(scale.tonic)) : null;\n  return (\n    notes ||\n    compact(\n      map(pc, name).map(function(n, i, arr) {\n        // check for duplicates\n        // TODO: sort but preserving the root\n        return arr.indexOf(n) < i ? null : n;\n      })\n    )\n  );\n}\n\n/**\n * Given a scale name, return its intervals. The name can be the type and\n * optionally the tonic (which is ignored)\n *\n * It retruns an empty array when no scale found\n *\n * @param {String} name - the scale name (tonic and type, tonic is optional)\n * @return {Array<String>} the scale intervals if is a known scale or an empty\n * array if no scale found\n * @example\n * scale.intervals('C major')\n */\nexport function intervals(name) {\n  var scale = parse(name);\n  return get(scale.type, false) || [];\n}\n\n/**\n * Check if the given name (and optional tonic and type) is a know scale\n * @param {String} name - the scale name\n * @return {Boolean}\n * @example\n * scale.intervals('C major') // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ])\n * scale.intervals('major') // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ])\n * scale.intervals('mixophrygian') // => null\n */\nexport function isKnowScale(name) {\n  return intervals(name).length > 0;\n}\n\n/**\n * Given a string try to parse as scale name. It retuns an object with the\n * form { tonic, type } where tonic is the note or false if no tonic specified\n * and type is the rest of the string minus the tonic\n *\n * Note that this function doesn't check that the scale type is a valid scale\n * type or if is present in any scale dictionary.\n *\n * @param {String} name - the scale name\n * @return {Object} an object { tonic, type }\n * @example\n * scale.parse('C mixoblydean') // => { tonic: 'C', type: 'mixoblydean' }\n * scale.parse('anything is valid') // => { tonic: false, type: 'anything is valid'}\n */\nexport function parse(str) {\n  if (typeof str !== \"string\") return null;\n  var i = str.indexOf(\" \");\n  var tonic = note(str.substring(0, i)) || false;\n  var type = tonic ? str.substring(i + 1) : str;\n  return { tonic: tonic, type: type };\n}\n\n/**\n * Detect a scale. Given a list of notes, return the scale name(s) if any.\n * It only detects chords with exactly same notes.\n *\n * @function\n * @param {Array|String} notes - the list of notes\n * @return {Array<String>} an array with the possible scales\n * @example\n * scale.detect('b g f# d') // => [ 'GMaj7' ]\n * scale.detect('e c a g') // => [ 'CM6', 'Am7' ]\n */\nexport var detect = detector(dict, \" \");\n","'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n","/**\n * A chord is a harmonic unit with at least three different tones sounding simultaneously.\n *\n * This module have functions to create and manipulate chords. It includes a\n * chord dictionary and a simple chord detection algorithm.\n *\n * @example\n * var chord = require('tonal-chord')\n * chord.detect('c b g e') // => 'CMaj7'\n * chord.get('CMaj7') // => ['C', 'E', 'G', 'B']\n *\n * @module chord\n */\nimport { dictionary, detector } from \"tonal-dictionary\";\nimport { map, compact, permutations, rotate } from \"tonal-array\";\nimport { pc, name as note } from \"tonal-note\";\nimport { regex } from \"note-parser\";\nimport { harmonize, intervallic } from \"tonal-harmonizer\";\nimport DATA from \"./chords.json\";\n\nvar dict = dictionary(DATA, function(str) {\n  return str.split(\" \");\n});\n\n/**\n * Return the available chord names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the chord names\n *\n * @example\n * var chord = require('tonal-chord')\n * chord.names() // => ['maj7', ...]\n */\nexport var names = dict.keys;\n\n/**\n * Get chord notes or intervals from chord type\n *\n * This function is currified\n *\n * @param {String} type - the chord type\n * @param {Strng|Pitch} tonic - the tonic or false to get the intervals\n * @return {Array<String>} the chord notes or intervals, or null if not valid type\n *\n * @example\n * chords.get('dom7', 'C') // => ['C', 'E', 'G', 'Bb']\n * maj7 = chords.get('Maj7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n */\nexport function get(type, tonic) {\n  if (arguments.length === 1)\n    return function(t) {\n      return get(type, t);\n    };\n  var ivls = dict.get(type);\n  return ivls ? harmonize(ivls, tonic) : null;\n}\n\n/**\n * Get the chord notes of a chord. This function accepts either a chord name\n * (for example: 'Cmaj7') or a list of notes.\n *\n * It always returns an array, even if the chord is not found.\n *\n * @param {String|Array} chord - the chord to get the notes from\n * @return {Array<String>} a list of notes or empty list if not chord found\n *\n * @example\n * chord.notes('Cmaj7') // => ['C', 'E', 'G', 'B']\n */\nexport function notes(chord) {\n  var p = parse(chord);\n  var ivls = dict.get(p.type);\n  return ivls ? harmonize(ivls, p.tonic) : compact(map(note, chord));\n}\n\n/**\n * Get chord intervals. It always returns an array\n *\n * @param {String} name - the chord name (optionally a tonic and type)\n * @return {Array<String>} a list of intervals or null if the type is not known\n */\nexport function intervals(name) {\n  var p = parse(name);\n  return dict.get(p.type) || [];\n}\n\n/**\n * Check if a given name correspond to a chord in the dictionary\n * @param {String} name\n * @return {Boolean}\n * @example\n * chord.isKnownChord('CMaj7') // => true\n * chord.isKnownChord('Maj7') // => true\n * chord.isKnownChord('Ablah') // => false\n */\nexport function isKnownChord(name) {\n  return intervals(name).length > 0;\n}\n\n/**\n * Detect a chord. Given a list of notes, return the chord name(s) if any.\n * It only detects chords with exactly same notes.\n *\n * @function\n * @param {Array|String} notes - the list of notes\n * @return {Array<String>} an array with the possible chords\n * @example\n * chord.detect('b g f# d') // => [ 'GMaj7' ]\n * chord.detect('e c a g') // => [ 'CM6', 'Am7' ]\n */\nexport var detect = detector(dict, \"\");\n\n/**\n * Get the position (inversion number) of a chord (0 is root position, 1 is first\n * inversion...). It assumes the chord is formed by superposed thirds.\n *\n * @param {Array|String} chord - the chord notes\n * @return {Integer} the inversion number (0 for root inversion, 1 for first\n * inversion...) or null if not a valid chord\n *\n * @example\n * chord.position('e g c') // => 1\n * chord.position('g3 e2 c5') // => 1 (e is the lowest note)\n */\nexport function position(chord) {\n  var pcs = map(pc, chord);\n  var sorted = sortTriads(pcs);\n  return sorted ? sorted.indexOf(pcs[0]) : null;\n}\n\n/**\n * Given a chord in any inverstion, set to the given inversion. It accepts\n * chord names\n *\n * @param {Integer} num - the inversion number (0 root position, 1 first\n * inversion, ...)\n * @param {String|Array} chord - the chord name or notes\n * @return {Array} the chord pitch classes in the desired inversion or\n * an empty array if no inversion found (not triadic)\n *\n * @example\n * chord.inversion(1, 'Cmaj7') // => [ 'E', 'G', 'B', 'C' ]\n * chord.inversion(0, 'e g c') // => [ 'C', 'E', 'G' ]\n */\nexport function inversion(num, chord) {\n  if (arguments.length === 1)\n    return function(c) {\n      return inversion(num, c);\n    };\n  var sorted = sortTriads(chord);\n  return sorted ? rotate(num, sorted) : [];\n}\n\nfunction sortTriads(chord) {\n  var all = permutations(notes(chord).map(pc));\n  for (var i = 0; i < all.length; i++) {\n    var ivls = intervallic(all[i]);\n    if (areTriads(ivls)) return all[i];\n  }\n  return null;\n}\n\nfunction areTriads(list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i][0] !== \"3\") return false;\n  }\n  return true;\n}\n\n/**\n * Try to parse a chord name. It returns an array with the chord type and\n * the tonic. If not tonic is found, all the name is considered the chord\n * name.\n *\n * This function does NOT check if the chord type exists or not. It only tries\n * to split the tonic and chord type.\n *\n * @param {String} name - the chord name\n * @return {Array} an array with [type, tonic]\n * @example\n * chord.parse('Cmaj7') // => { tonic: 'C', type: 'maj7' }\n * chord.parse('C7') // => { tonic: 'C', type: '7' }\n * chord.parse('mMaj7') // => { tonic: false, type: 'mMaj7' }\n * chord.parse('Cnonsense') // => { tonic: 'C', type: 'nonsense' }\n */\nexport function parse(name) {\n  var p = regex().exec(name);\n  if (!p) return { type: name, tonic: false };\n\n  // If chord name is empty, the octave is the chord name\n  return !p[4]\n    ? { type: p[3], tonic: p[1] + p[2] }\n    : // If the octave is 6 or 7 is asumed to be part of the chord name\n      p[3] === \"7\" || p[3] === \"6\"\n      ? { type: p[3] + p[4], tonic: p[1] + p[2] }\n      : { type: p[4], tonic: p[1] + p[2] + p[3] };\n}\n","/**\n * # `tonal-progressions`\n * > Describe and manipulate chord progressions.\n *\n * @example\n * var progression = require('tonal-progression')\n * progression.abstract('Cmaj7 Dm7 G7', 'C')\n *\n * @module progression\n */\nimport { pc } from \"tonal-note\";\nimport { props, fromProps } from \"tonal-interval\";\nimport { map, compact } from \"tonal-array\";\nimport { transpose } from \"tonal-transpose\";\nimport { interval } from \"tonal-distance\";\nimport { parse } from \"tonal-chord\";\nimport { toAcc } from \"tonal-notation\";\n\n/**\n * Given a chord progression and a tonic, return the chord progression\n * with roman numeral chords.\n *\n * @param {Array|String} chords - the chord progression\n * @param {String} tonic - the tonic\n * @return {Array} the chord progression in roman numerals\n * @example\n * progression.abstract('Cmaj7 Dm7 G7', 'C') // => [ 'Imaj7', 'IIm7', 'V7' ]\n */\nexport function abstract(chords, tonic) {\n  tonic = pc(tonic);\n  chords = map(parse, chords);\n  var tonics = compact(\n    chords.map(function(x) {\n      return x.tonic;\n    })\n  );\n  // if some tonic missing, can't do the analysis\n  if (tonics.length !== chords.length) return null;\n\n  return tonics.map(function(t, i) {\n    var p = props(interval(tonic, t));\n    return buildRoman(p.num - 1, p.alt, chords[i].type);\n  });\n}\n\nvar NUMS = [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\"];\n/**\n * Build an abstract chord name using roman numerals\n */\nexport function buildRoman(num, alt, element) {\n  return toAcc(alt) + NUMS[num % 7] + (element || \"\");\n}\n\n/**\n * Get chord progression from a tonic and a list of chord in roman numerals\n *\n * @param {String} tonic - the tonic\n * @param {Array|String} progression - the progression in roman numerals\n * @return {Array} the chord progression\n *\n * @example\n * var progression = require('chord-progression')\n * progression.concrete('I IIm7 V7', 'C') // => ['C', 'Dm7', 'G7']\n */\nexport function concrete(chords, tonic) {\n  return map(function(e) {\n    var r = parseRomanChord(e);\n    return r ? transpose(r.root, tonic) + r.type : null;\n  }, chords);\n}\n\nvar ROMAN = /^\\s*(b|bb|#|##|)(IV|III|II|I|VII|VI|V|iv|iii|ii|i|vii|vi|v)\\s*(.*)\\s*$/;\n/**\n * Returns a regex to match roman numbers literals with the from:\n * `[accidentals]roman[element]`.\n *\n * The executed regex contains:\n *\n * - input: the input string\n * - accidentals: (Optional) one or two flats (b) or shaprs (#)\n * - roman: (Required) a roman numeral from I to VII either in upper or lower case\n * - element: (Optional) a name of an element\n *\n * @return {RegExp} the regexp\n *\n * @example\n * var r = progression.romanRegex()\n * r.exec('bVImaj7') // => ['bVImaj7', 'b', 'VI', 'maj7'])\n * r.exec('III dom') // => ['III dom', '', 'III', 'dom'])\n */\nexport function romanRegex() {\n  return ROMAN;\n}\n\nvar NUM = { i: 0, ii: 1, iii: 2, iv: 3, v: 4, vi: 5, vii: 6 };\n\n/**\n * Parse a chord expressed with roman numerals. It returns an interval representing\n * the root of the chord relative to the key tonic and the chord name.\n *\n * @param {String} str - the roman numeral string\n * @return {Object} the roman chord property object with:\n *\n * - type: the chord type\n * - root: the interval from the key to the root of this chord\n *\n * @example\n * var parse = require('music-notation/roman.parse')\n * parse('V7') // => { root: '5P', type: '7' }\n * parse('bIIalt') // => { root: '2m', type: 'alt' }\n */\nexport function parseRomanChord(str) {\n  var m = ROMAN.exec(str);\n  if (!m) return null;\n  var num = NUM[m[2].toLowerCase()] + 1;\n  var alt = m[1].length;\n  if (m[1][0] === \"b\") alt = -alt;\n  return { root: fromProps({ num: num, alt: alt, dir: 1 }), type: m[3] };\n}\n","/**\n *\n * @module sonority\n */\nimport { ic } from \"tonal-interval\";\nimport { asNotePitch, chr } from \"tonal-pitch\";\nimport { map, compact } from \"tonal-array\";\n\n/**\n * Get the intervals analysis of a collection of notes\n *\n * Returns an array with the format `[p, m, n, s, d, t]` where:\n *\n * - p: the number of perfect fourths or fifths\n * - m: the number of major thirds or minor sixths\n * - n: the number of major sixths or minor thirds\n * - s: the number of major seconds or minor sevenths\n * - d: the number of major sevents or minor seconds\n * - t: the number of tritones\n *\n * This is, mostly, an academic puzzle to show the expresiveness of tonal.\n * Implements the ideas found in \"The Analysis of Intervals\" chapter from\n * [Harmonic Materials of Modern Music]():\n *\n * > The letters _pmn_, therefore, represent intervals commonly considered\n * consonant, whereas the letters _sdt_ represent the intervals commonly\n * considered dissonant. (...) A sonority represented, for example, by the\n * symbol `sd^2`, indicating a triad composed of one major second and two minor\n * seconds, would be recognized as a highly dissonant sound, while the symbol\n * `pmn` would indicate a consonant sound.\n *\n * @param {Array|String} notes - the notes to analyze\n * @return {Array} the _pmnsdt_ array\n */\nexport function density(list) {\n  var a, b, i;\n  var notes = compact(map(asNotePitch, list));\n  var len = notes.length;\n  var result = [0, 0, 0, 0, 0, 0];\n  for (a = 0; a < len; a++) {\n    for (b = a; b < len; b++) {\n      i = ic(chr(notes[b]) - chr(notes[a]));\n      if (i === 6) result[5] = result[5] + 1;\n      else if (i > 0) result[5 - i] = result[5 - i] + 1;\n    }\n  }\n  return result;\n}\n","/**\n * Functions to create and manipulate pitch sets\n *\n * @example\n * var pitchset = require('tonal-pitchset')\n *\n * @module pitchset\n */\nimport { sort } from \"tonal-array\";\n\n/**\n * Get the notes of a pitch set. The notes in the set are sorted in asceding\n * pitch order, and no repetitions are allowed.\n *\n * Note that it creates pitch sets and NOT picth class sets. This functionallity\n * resides inside `tonal-pcset` module.\n *\n * @param {String|Array} notes - the notes to create the pitch set from\n * @return {Array<String>} the ordered pitch set notes\n * @example\n * pitchset.notes('C4 c3 C5 c4') // => ['C3', 'C4', 'C5']\n */\nexport function notes(notes) {\n  return sort(notes).filter(function(n, i, arr) {\n    return i === 0 || n !== arr[i - 1];\n  });\n}\n","/**\n * The `tonal` module is a facade to all the rest of the modules. They are namespaced,\n * so for example to use `pc` function from `tonal-note` you have to write:\n * `tonal.note.pc`\n *\n * Some modules are NOT namespaced for developer comfort:\n *\n * - `tonal-array`: for example `tonal.map(tonal.note.pc, 'C#2')`\n * - `tonal-transpose`: for example `tonal.transpose('C', '3M')`\n * - `tonal-distance`: for example `tonal.interval('C3', 'G4')`\n *\n * It also adds a couple of function aliases:\n *\n * - `tonal.scale` is an alias for `tonal.scale.notes`\n * - `tonal.chord` is an alias for `tonal.chord.notes`\n *\n * @example\n * var tonal = require('tonal')\n * tonal.transpose(tonal.note.pc('C#2'), 'M3') // => 'E#'\n * tonal.chord('Dmaj7') // => ['D', 'F#', 'A', 'C#']\n *\n * @module tonal\n */\nimport * as array from \"tonal-array\";\nimport * as transpose from \"tonal-transpose\";\nimport * as harmonizer from \"tonal-harmonizer\";\nimport * as distance from \"tonal-distance\";\nimport * as note from \"tonal-note\";\nimport * as interval from \"tonal-interval\";\nimport * as midi from \"tonal-midi\";\nimport * as freq from \"tonal-freq\";\nimport * as range from \"tonal-range\";\nimport * as key from \"tonal-key\";\nimport * as scale from \"tonal-scale\";\nimport * as chord from \"tonal-chord\";\nimport * as pitch from \"tonal-pitch\";\nimport * as notation from \"tonal-notation\";\nimport * as progression from \"tonal-progression\";\nimport * as sonority from \"tonal-sonority\";\nimport * as pitchset from \"tonal-pitchset\";\nimport * as pcset from \"tonal-pcset\";\n\nvar assign = Object.assign;\nvar tonal = assign({}, array, transpose, harmonizer, distance);\ntonal.pitch = pitch;\ntonal.notation = notation;\ntonal.note = note;\ntonal.ivl = interval;\ntonal.midi = midi;\ntonal.freq = freq;\ntonal.range = range;\ntonal.key = key;\ntonal.progression = progression;\ntonal.sonority = sonority;\ntonal.pitchset = pitchset;\ntonal.pcset = pcset;\n\ntonal.scale = function(name) {\n  return tonal.scale.notes(name);\n};\nassign(tonal.scale, scale);\ntonal.chord = function(name) {\n  return tonal.chord.notes(name);\n};\nassign(tonal.chord, chord);\n\nif (typeof window !== \"undefined\") window.Tonal = tonal;\nexport default tonal;\n"],"names":["fillStr","s","num","Array","join","isNum","x","midiToFreq","midi","tuning","Math","pow","parse","str","isTonic","m","REGEX","exec","p","letter","toUpperCase","acc","replace","pc","step","charCodeAt","alt","length","pos","SEMITONES","chroma","oct","freq","tonicOf","accStr","n","octStr","build","a","o","LETTERS","charAt","strict","IVL_REGEX","i","q","dir","simple","type","TYPES","qToAlt","floor","size","SIZES","t","test","abs","altToQ","encode","f","FIFTHS","FIFTH_OCTS","unaltered","decode","STEPS","pitch","fifths","focts","isPitch","isArray","enc","dec","apply","pType","isNotePitch","isIvlPitch","isPC","height","chr","memoize","fn","cache","parsePitch","parseNote","parseIvl","asNotePitch","asIvlPitch","asPitch","strNote","noteStr","strIvl","d","strPitch","decorator","is","v","trBy","transpose","b","arguments","pa","pb","r","trFifths","note","interval","transposeBy","substr","from","to","semitones","hasVal","e","map","list","l","asArr","compact","arr","filter","objHeight","Infinity","ascComp","descComp","sort","comp","slice","listFn","trOct","tr","rotate","times","len","concat","select","nums","permutations","reduce","perm","newPerm","splice","asPitchStr","listToStr","isArr","harmonics","intervallic","notes","dist","push","harmonize","tonic","isStr","isDef","toMidi","val","sharps","round","SHARPS","FLATS","eqTempFreq","ref","max","noteToMidi","eqTempFreqToMidi","log","name","props","warn","getProp","pcFifths","enharmonics","DESC","ASC","dirStr","ivl","fromProps","octs","ic","isNaN","CLASSES","chrToInt","set","parseInt","pitchChr","isChroma","forEach","modes","normalize","binary","split","_","intervals","IVLS","fromChroma","isEqual","s1","s2","isSubset","isSuperset","includes","asNum","ascR","descR","ran","numeric","last","chromatic","pitchSet","range","isStep","areFlats","areSharps","toAcc","toKey","majorKey","modeNum","mode","MODES","indexOf","validMode","trim","toLowerCase","key","ndx","relative","rel","k","alteration","toMajor","signature","id","dictionary","raw","byKey","names","Object","keys","aliases","value","alias","all","detector","dict","isSep","isFn","nameByChroma","get","ivls","substring","regex","chord","inversion","c","sorted","sortTriads","areTriads","buildRoman","element","NUMS","parseRomanChord","ROMAN","NUM","root","RegExp","noteParse","ivlParse","noteFn","ivlFn","pitchFn","ivl1","ivl2","i2","p1","p2","sep","undefined","shuffle","random","head","tail","toFreq","useSharps","midiToNote","base","fromMidi","next","IN","IQ","invert","simplify","pcs","norm","SCALES","accidentals","detect","scale","ii","iii","iv","vi","vii","chords","tonics","result","assign","tonal","array","harmonizer","distance","notation","progression","sonority","pitchset","pcset","window","Tonal"],"mappings":"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"}
{"version":3,"file":"tonal.min.js","sources":["../packages/core/pitch/node_modules/note-parser/index.js","../packages/core/pitch/node_modules/interval-notation/index.js","../packages/core/encoding/index.js","../packages/core/pitch/index.js","../packages/core/transpose/index.js","../packages/tonal/distance/index.js","../packages/core/array/index.js","../packages/core/harmonizer/index.js","../packages/tonal/note/index.js","../packages/tonal/interval/node_modules/interval-notation/index.js","../packages/tonal/interval/index.js","../packages/core/midi/node_modules/note-parser/index.js","../packages/core/midi/index.js","../packages/core/freq/index.js","../packages/tonal/pcset/index.js","../packages/tonal/range/index.js","../packages/core/notation/index.js","../packages/extensions/key/index.js","../packages/tonal/dictionary/index.js","../packages/tonal/scale/index.js","../packages/tonal/chord/node_modules/note-parser/index.js","../packages/tonal/chord/index.js","../packages/extensions/progression/index.js","../packages/incubator/sonority/index.js","../packages/incubator/pitchset/index.js","../packages/core/tonal/index.js"],"sourcesContent":["'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n","// shorthand tonal notation (with quality after number)\nvar IVL_TNL = '([-+]?)(\\\\d+)(d{1,4}|m|M|P|A{1,4})'\n// standard shorthand notation (with quality before number)\nvar IVL_STR = '(AA|A|P|M|m|d|dd)([-+]?)(\\\\d+)'\nvar COMPOSE = '(?:(' + IVL_TNL + ')|(' + IVL_STR + '))'\nvar IVL_REGEX = new RegExp('^' + COMPOSE + '$')\n\n/**\n * Parse a string with an interval in shorthand notation (https://en.wikipedia.org/wiki/Interval_(music)#Shorthand_notation)\n * and returns an object with interval properties.\n *\n * @param {String} str - the string with the interval\n * @param {Boolean} strict - (Optional) if its false, it doesn't check if the\n * interval is valid or not. For example, parse('P2') returns null\n * (because a perfect second is not a valid interval), but\n * parse('P2', false) it returns { num: 2, dir: 1, q: 'P'... }\n * @return {Object} an object properties or null if not valid interval string\n * The returned object contains:\n * - `num`: the interval number\n * - `q`: the interval quality string (M is major, m is minor, P is perfect...)\n * - `simple`: the simplified number (from 1 to 7)\n * - `dir`: the interval direction (1 ascending, -1 descending)\n * - `type`: the interval type (P is perfectable, M is majorable)\n * - `alt`: the alteration, a numeric representation of the quality\n * - `oct`: the number of octaves the interval spans. 0 for simple intervals.\n * - `size`: the size of the interval in semitones\n * @example\n * var parse = require('interval-notation').parse\n * parse('M3')\n * // => { num: 3, q: 'M', dir: 1, simple: 3,\n * //      type: 'M', alt: 0, oct: 0, size: 4 }\n */\nexport function parse (str, strict) {\n  if (typeof str !== 'string') return null\n  var m = IVL_REGEX.exec(str)\n  if (!m) return null\n  var i = { num: +(m[3] || m[8]), q: m[4] || m[6] }\n  i.dir = (m[2] || m[7]) === '-' ? -1 : 1\n  var step = (i.num - 1) % 7\n  i.simple = step + 1\n  i.type = TYPES[step]\n  i.alt = qToAlt(i.type, i.q)\n  i.oct = Math.floor((i.num - 1) / 7)\n  i.size = i.dir * (SIZES[step] + i.alt + 12 * i.oct)\n  if (strict !== false) {\n    if (i.type === 'M' && i.q === 'P') return null\n  }\n  return i\n}\nvar SIZES = [0, 2, 4, 5, 7, 9, 11]\n\nvar TYPES = 'PMMPPMM'\n/**\n * Get the type of interval. Can be perfectavle ('P') or majorable ('M')\n * @param {Integer} num - the interval number\n * @return {String} `P` if it's perfectable, `M` if it's majorable.\n */\nexport function type (num) {\n  return TYPES[(num - 1) % 7]\n}\n\nfunction dirStr (dir) { return dir === -1 ? '-' : '' }\nfunction num (simple, oct) { return simple + 7 * oct }\n\n/**\n * Build a shorthand interval notation string from properties.\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.shorthand(3, 0, 0, 1) // => 'M3'\n * interval.shorthand(3, -1, 0, -1) // => 'm-3'\n * interval.shorthand(3, 1, 1, 1) // => 'A10'\n */\nexport function shorthand (simple, alt, oct, dir) {\n  return altToQ(simple, alt) + dirStr(dir) + num(simple, oct)\n}\n/**\n * Build a special shorthand interval notation string from properties.\n * The special shorthand interval notation changes the order or the standard\n * shorthand notation so instead of 'M-3' it returns '-3M'.\n *\n * The standard shorthand notation has a string 'A4' (augmented four) that can't\n * be differenciate from 'A4' (the A note in 4th octave), so the purpose of this\n * notation is avoid collisions\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.build(3, 0, 0, 1) // => '3M'\n * interval.build(3, -1, 0, -1) // => '-3m'\n * interval.build(3, 1, 1, 1) // => '10A'\n */\nexport function build (simple, alt, oct, dir) {\n  return dirStr(dir) + num(simple, oct) + altToQ(simple, alt)\n}\n\n/**\n * Get an alteration number from an interval quality string.\n * It accepts the standard `dmMPA` but also sharps and flats.\n *\n * @param {Integer|String} num - the interval number or a string representing\n * the interval type ('P' or 'M')\n * @param {String} quality - the quality string\n * @return {Integer} the interval alteration\n * @example\n * qToAlt('M', 'm') // => -1 (for majorables, 'm' is -1)\n * qToAlt('P', 'A') // => 1 (for perfectables, 'A' means 1)\n * qToAlt('M', 'P') // => null (majorables can't be perfect)\n */\nexport function qToAlt (num, q) {\n  var t = typeof num === 'number' ? type(num) : num\n  if (q === 'M' && t === 'M') return 0\n  if (q === 'P' && t === 'P') return 0\n  if (q === 'm' && t === 'M') return -1\n  if (/^A+$/.test(q)) return q.length\n  if (/^d+$/.test(q)) return t === 'P' ? -q.length : -q.length - 1\n  return null\n}\n\nfunction fillStr (s, n) { return Array(Math.abs(n) + 1).join(s) }\n/**\n * Get interval quality from interval type and alteration\n *\n * @function\n * @param {Integer|String} num - the interval number of the the interval\n * type ('M' for majorables, 'P' for perfectables)\n * @param {Integer} alt - the interval alteration\n * @return {String} the quality string\n * @example\n * altToQ('M', 0) // => 'M'\n */\nexport function altToQ (num, alt) {\n  var t = typeof num === 'number' ? type(Math.abs(num)) : num\n  if (alt === 0) return t === 'M' ? 'M' : 'P'\n  else if (alt === -1 && t === 'M') return 'm'\n  else if (alt > 0) return fillStr('A', alt)\n  else if (alt < 0) return fillStr('d', t === 'P' ? alt : alt + 1)\n  else return null\n}\n\n","/**\n * Functions to encoding and decoding pitches into fifths/octaves notation.\n *\n * This functions are very low level and it's probably you wont need them.\n * @private\n * @module encoding\n */\n\nfunction isNum(n) {\n  return typeof n === \"number\";\n}\n\n// Map from letter step to number of fifths starting from 'C':\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n// Given a number of fifths, return the octaves they span\nfunction fOcts(f) {\n  return Math.floor(f * 7 / 12);\n}\n// Get the number of octaves it span each step\nvar FIFTH_OCTS = FIFTHS.map(fOcts);\n\n/**\n * Given a note's step, alteration and octave returns the fiths/octave\n * note encoding.\n * @param {number} step - the step number (0 = C, 1 = D, ...)\n * @param {number} alteration - the note alteration (..., -1 = 'b', 0 = '', 1 = '#', ...)\n * @param {number} octave - the note octave\n * @return {Array} the [fifths, octave] representation of that note\n */\nexport function encode(step, alt, oct) {\n  var f = FIFTHS[step] + 7 * alt;\n  if (!isNum(oct)) return [f];\n  var o = oct - FIFTH_OCTS[step] - 4 * alt;\n  return [f, o];\n}\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f) {\n  var i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for ['F', 'C', 'G', 'D', 'A', 'E', 'B'] we have:\nvar STEPS = [3, 0, 4, 1, 5, 2, 6];\n\n/**\n * Decode a encoded pitch\n * @param {Number} fifths - the number of fifths\n * @param {Number} octs - the number of octaves to compensate the fifhts\n * @return {Array} in the form [step, alt, oct]\n */\nexport function decode(f, o) {\n  var step = STEPS[unaltered(f)];\n  var alt = Math.floor((f + 1) / 7);\n  if (!isNum(o)) return [step, alt];\n  var oct = o + 4 * alt + FIFTH_OCTS[step];\n  return [step, alt, oct];\n}\n","/**\n * Functions to deal with pitches (either notes or intervals).\n *\n * This functions are very low level and more developer friendly of this functions\n * are exposed in the note and interval packages. It's unlikely you need them.\n * That's why __this module is NOT exported in the tonal package__.\n *\n * @private\n * @module pitch\n */\nimport { parse as noteParse, build as noteStr } from \"note-parser\";\nimport { parse as ivlParse, altToQ } from \"interval-notation\";\nimport { encode as enc, decode as dec } from \"tonal-encoding\";\n\n/**\n * Create a pitch\n * @param {Integer} fifths - the number of fifths from C or from P1\n * @param {Integer} focts - the number of encoded octaves\n * @param {Integer} dir - (Optional) Only required for intervals. Can be 1 or -1\n * @return {Pitch}\n */\nexport function pitch(fifths, focts, dir) {\n  return dir ? [\"tnlp\", [fifths, focts], dir] : [\"tnlp\", [fifths, focts]];\n}\n/**\n * Test if an object is a pitch\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isPitch(p) {\n  return Array.isArray(p) && p[0] === \"tnlp\";\n}\n/**\n * Encode a pitch\n * @param {Integer} step\n * @param {Integer} alt\n * @param {Integer} oct\n * @param {Integer} dir - (Optional)\n */\nexport function encode(s, a, o, dir) {\n  return dir ? [\"tnlp\", enc(s, a, o), dir] : [\"tnlp\", enc(s, a, o)];\n}\n\n/**\n * Decode a pitch\n * @param {Pitch} the pitch\n * @return {Array} An array with [step, alt, oct]\n */\nexport function decode(p) {\n  return dec.apply(null, p[1]);\n}\n\n/**\n * Get pitch type\n * @param {Pitch}\n * @return {String} 'ivl' or 'note' or null if not a pitch\n */\nexport function pType(p) {\n  return !isPitch(p) ? null : p[2] ? \"ivl\" : \"note\";\n}\n/**\n * Test if is a pitch note (with or without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isNotePitch(p) {\n  return pType(p) === \"note\";\n}\n/**\n * Test if is an interval\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isIvlPitch(p) {\n  return pType(p) === \"ivl\";\n}\n/**\n * Test if is a pitch class (a pitch note without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nexport function isPC(p) {\n  return isPitch(p) && p[1].length === 1;\n}\n\n/**\n * Get direction of a pitch (even for notes)\n * @param {Pitch}\n * @return {Integer} 1 or -1\n */\nexport function dir(p) {\n  return p[2] === -1 ? -1 : 1;\n}\n\n/**\n * Get encoded fifths from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nexport function fifths(p) {\n  return p[2] === -1 ? -p[1][0] : p[1][0];\n}\n/**\n * Get encoded octaves from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nexport function focts(p) {\n  return p[2] === -1 ? -p[1][1] : p[1][1];\n}\n/**\n * Get height of a pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nexport function height(p) {\n  return fifths(p) * 7 + focts(p) * 12;\n}\n\n/**\n * Get chroma of a pitch. The chroma is a number between 0 and 11 to represent\n * the position of a pitch inside an octave. Is the numeric equivlent of a\n * pitch class.\n *\n * @param {Pitch}\n * @return {Integer}\n */\nexport function chr(p) {\n  var f = fifths(p);\n  return 7 * f - 12 * Math.floor(f * 7 / 12);\n}\n\n// memoize parsers\nfunction memoize(fn) {\n  var cache = {};\n  return function(str) {\n    if (typeof str !== \"string\") return null;\n    return cache[str] || (cache[str] = fn(str));\n  };\n}\n\n/**\n * Parse a note\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid note string\n */\nexport var parseNote = memoize(function(s) {\n  var p = noteParse(s);\n  return p ? encode(p.step, p.alt, p.oct) : null;\n});\n\n/**\n * Parse an interval\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid interval string\n */\nexport var parseIvl = memoize(function(s) {\n  var p = ivlParse(s);\n  if (!p) return null;\n  return p ? encode(p.simple - 1, p.alt, p.oct, p.dir) : null;\n});\n\n/**\n * Parse a note or an interval\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid pitch string\n */\nexport function parsePitch(s) {\n  return parseNote(s) || parseIvl(s);\n}\n\n/**\n * Ensure the given object is a note pitch. If is a string, it will be\n * parsed. If not a note pitch or valid note string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nexport function asNotePitch(p) {\n  return isNotePitch(p) ? p : parseNote(p);\n}\n/**\n * Ensure the given object is a interval pitch. If is a string, it will be\n * parsed. If not a interval pitch or valid interval string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nexport function asIvlPitch(p) {\n  return isIvlPitch(p) ? p : parseIvl(p);\n}\n/**\n * Ensure the given object is a pitch. If is a string, it will be\n * parsed. If not a pitch or valid pitch string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nexport function asPitch(p) {\n  return isPitch(p) ? p : parsePitch(p);\n}\n\n/**\n * Convert a note pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nexport function strNote(p) {\n  if (!isNotePitch(p)) return null;\n  return noteStr.apply(null, decode(p));\n}\n\n/**\n * Convert a interval pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nexport function strIvl(p) {\n  if (!isIvlPitch(p)) return null;\n  // decode to [step, alt, oct]\n  var d = decode(p);\n  // d = [step, alt, oct]\n  var num = d[0] + 1 + 7 * d[2];\n  return p[2] * num + altToQ(num, d[1]);\n}\n\n/**\n * Convert a pitch to string representation (either notes or intervals)\n * @param {Pitch}\n * @return {String}\n */\nexport function strPitch(p) {\n  return strNote(p) || strIvl(p);\n}\n\n// A function that creates a decorator\n// The returned function can _decorate_ other functions to parse and build\n// string representations\nfunction decorator(is, parse, str) {\n  return function(fn) {\n    return function(v) {\n      var i = is(v);\n      // if the value is in pitch notation no conversion\n      if (i) return fn(v);\n      // else parse the pitch\n      var p = parse(v);\n      // if parsed, apply function and back to string\n      return p ? str(fn(p)) : null;\n    };\n  };\n}\n\n/**\n * Decorate a function to work internally with note pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a note pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nexport var noteFn = decorator(isNotePitch, parseNote, strNote);\n/**\n * Decorate a function to work internally with interval pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a interval pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nexport var ivlFn = decorator(isIvlPitch, parseIvl, strIvl);\n/**\n * Decorate a function to work internally with pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nexport var pitchFn = decorator(isPitch, parsePitch, strPitch);\n","/**\n * This module deals with note transposition. Just two functions: `transpose`\n * to transpose notes by any interval (or intervals by intervals) and `trFifths`\n * to transpose notes by fifths.\n *\n * @example\n * var tonal = require('tonal')\n * tonal.transpose('C3', 'P5') // => 'G3'\n * tonal.transpose('m2', 'P4') // => '5d'\n * tonal.trFifths('C', 2) // => 'D'\n *\n * @module transpose\n */\nimport {\n  pitch,\n  pType,\n  fifths,\n  focts,\n  height,\n  isPC,\n  asPitch,\n  isIvlPitch,\n  strPitch\n} from \"tonal-pitch\";\n\nfunction trBy(i, p) {\n  var t = pType(p);\n  if (!t) return null;\n  var f = fifths(i) + fifths(p);\n  if (isPC(p)) return [\"tnlp\", [f]];\n  var o = focts(i) + focts(p);\n  if (t === \"note\") return [\"tnlp\", [f, o]];\n  var d = height(i) + height(p) < 0 ? -1 : 1;\n  return [\"tnlp\", [d * f, d * o], d];\n}\n\n/**\n * Transpose notes. Can be used to add intervals. At least one of the parameter\n * is expected to be an interval. If not, it returns null.\n *\n * @param {String|Pitch} a - a note or interval\n * @param {String|Pitch} b - a note or interavl\n * @return {String|Pitch} the transposed pitch or null if not valid parameters\n * @example\n * var _ = require('tonal')\n * // transpose a note by an interval\n * _.transpose('d3', '3M') // => 'F#3'\n * // transpose intervals\n * _.transpose('3m', '5P') // => '7m'\n * // it works with pitch classes\n * _.transpose('d', '3M') // => 'F#'\n * // order or parameters is irrelevant\n * _.transpose('3M', 'd3') // => 'F#3'\n * // can be partially applied\n * _.map(_.transpose('3M'), 'c d e f g') // => ['E', 'F#', 'G#', 'A', 'B']\n */\nexport function transpose(a, b) {\n  if (arguments.length === 1)\n    return function(b) {\n      return transpose(a, b);\n    };\n  var pa = asPitch(a);\n  var pb = asPitch(b);\n  var r = isIvlPitch(pa) ? trBy(pa, pb) : isIvlPitch(pb) ? trBy(pb, pa) : null;\n  return a === pa && b === pb ? r : strPitch(r);\n}\n\n/**\n * Transpose a tonic a number of perfect fifths. It can be partially applied.\n *\n * @function\n * @param {Pitch|String} tonic\n * @param {Integer} number - the number of times\n * @return {String|Pitch} the transposed note\n * @example\n * import { trFifths } from 'tonal-transpose'\n * [0, 1, 2, 3, 4].map(trFifths('C')) // => ['C', 'G', 'D', 'A', 'E']\n * // or using tonal\n * tonal.trFifths('G4', 1) // => 'D5'\n */\nexport function trFifths(t, n) {\n  if (arguments.length > 1) return trFifths(t)(n);\n  return function(n) {\n    return transpose(t, pitch(n, 0, 1));\n  };\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-distance.svg)](https://www.npmjs.com/package/tonal-distance)\n * [![tonal](https://img.shields.io/badge/tonal-distance-yellow.svg)](https://github.com/danigb/tonal/tree/master/packages/tonal/distance)\n * \n * Transpose notes by intervals and find distances between notes\n *\n * @example\n * // using ES6 import\n * import { interval, semitones, transpose } from 'tonal-distance'\n * semitones('C' ,'D') // => 2\n * interval('C4', 'G4') // => '5P'\n * transpose('C4', 'P5') // => 'G4'\n *\n * // included in tonal facade\n * const tonal = require('tonal');\n * tonal.distance.transpose('C4', 'P5')\n * tonal.distance.transposeBy('P5', 'C4')\n * \n * @module distance\n */\nimport {\n  isPC,\n  fifths,\n  focts,\n  pitch,\n  height,\n  pType,\n  strPitch,\n  asPitch,\n  strIvl\n} from \"tonal-pitch\";\n\nfunction trBy(i, p) {\n  var t = pType(p);\n  if (!t) return null;\n  var f = fifths(i) + fifths(p);\n  if (isPC(p)) return [\"tnlp\", [f]];\n  var o = focts(i) + focts(p);\n  if (t === \"note\") return [\"tnlp\", [f, o]];\n  var d = height(i) + height(p) < 0 ? -1 : 1;\n  return [\"tnlp\", [d * f, d * o], d];\n}\n\n/**\n * Transpose a note by an interval. The note can be a pitch class.\n * \n * This function can be partially applied.\n * \n * @param {String} note\n * @param {String} interval\n * @return {String} the transposed note\n * @example\n * import { tranpose } from 'tonal-distance'\n * transpose('d3', '3M') // => 'F#3'\n * // it works with pitch classes\n * transpose('D', '3M') // => 'F#'\n * // can be partially applied\n * ['C', 'D', 'E', 'F', 'G'].map(transpose('M3)) // => ['E', 'F#', 'G#', 'A', 'B']\n */\nexport function transpose(note, interval) {\n  if (arguments.length === 1) return i => transpose(note, i);\n  var n = asPitch(note);\n  var i = asPitch(interval);\n  return n && i ? strPitch(trBy(i, n)) : null;\n}\n\n/**\n * The same as transpose with the arguments inverted.\n * \n * Can be partially applied.\n * \n * @param {String} note\n * @param {String} interval\n * @return {String} the transposed note\n * @example\n * import { tranposeBy } from 'tonal-distance'\n * transposeBy('3m', '5P') // => '7m'\n */\nexport function transposeBy(interval, note) {\n  if (arguments.length === 1) return n => transposeBy(interval, n);\n  return transpose(note, interval);\n}\n\n/**\n * Add two intervals \n * \n * Can be partially applied.\n * \n * @param {String} interval1\n * @param {String} interval2\n * @return {String} the resulting interval\n * @example\n * import { add } from 'tonal-distance'\n * add('3m', '5P') // => '7m'\n */\nexport function add(ivl1, ivl2) {\n  if (arguments.length === 1) return i2 => transposeBy(ivl1, i2);\n  var p1 = asPitch(ivl1);\n  var p2 = asPitch(ivl2);\n  return p1 && p2 ? strPitch(trBy(p1, p2)) : null;\n}\n\n/**\n * Transpose a note by a number of perfect fifths. \n * \n * It can be partially applied.\n *\n * @function\n * @param {String} note\n * @param {Integer} times - the number of times\n * @return {String} the transposed note\n * @example\n * import { trFifths } from 'tonal-transpose'\n * [0, 1, 2, 3, 4].map(trFifths('C')) // => ['C', 'G', 'D', 'A', 'E']\n * // or using tonal\n * tonal.trFifths('G4', 1) // => 'D5'\n */\nexport function trFifths(t, n) {\n  if (arguments.length > 1) return trFifths(t)(n);\n  return function(n) {\n    return transpose(t, pitch(n, 0, 1));\n  };\n}\n\n// substract two pitches\nfunction substr(a, b) {\n  if (!a || !b || a[1].length !== b[1].length) return null;\n  var f = fifths(b) - fifths(a);\n  if (isPC(a)) return pitch(f, -Math.floor(f * 7 / 12), 1);\n  var o = focts(b) - focts(a);\n  var d = height(b) - height(a) < 0 ? -1 : 1;\n  return pitch(d * f, d * o, d);\n}\n\n/**\n * Find the interval between two pitches. It works with pitch classes \n * (both must be pitch classes and the interval is always ascending)\n * \n * Can be partially applied\n *\n * @param {String} from - distance from\n * @param {String} to - distance to\n * @return {String} the interval distance\n *\n * @example\n * import { interval } from 'tonal-distance'\n * interval('C2', 'C3') // => 'P8'\n * interval('G', 'B') // => 'M3'\n * \n * // or use tonal\n * var tonal = require('tonal')\n * tonal.distance.interval('M2', 'P5') // => 'P4'\n */\nexport function interval(from, to) {\n  if (arguments.length === 1) return to => interval(from, to);\n  var pa = asPitch(from);\n  var pb = asPitch(to);\n  var i = substr(pa, pb);\n  // if a and b are in array notation, no conversion back\n  return strIvl(i);\n}\n\n/**\n * Subtract two intervals\n * \n * @param {String} minuend\n * @param {String} subtrahend\n * @return {String} interval diference\n */\nexport function subtract(ivl1, ivl2) {\n  return interval(ivl2, ivl1);\n}\n\n/**\n * Get the distance between two notes in semitones\n * @param {String|Pitch} from - first note\n * @param {String|Pitch} to - last note\n * @return {Integer} the distance in semitones or null if not valid notes\n * @example\n * import { semitones } from 'tonal-distance'\n * semitones('C3', 'A2') // => -3\n * // or use tonal\n * tonal.distance.semitones('C3', 'G3') // => 7\n */\nexport function semitones(a, b) {\n  var i = substr(asPitch(a), asPitch(b));\n  return i ? height(i) : null;\n}\n","/**\n * This module implements utility functions related to array manipulation, like:\n * `map`, `filter`, `shuffle`, `sort`, `rotate`, `select`\n *\n * All the functions are _functional friendly_ with target object as last\n * parameter and currified. The sorting functions understand about pitch\n * heights and interval sizes.\n *\n * One key feature of tonal is that you can represent lists with arrays or\n * with space separated string of elements. This module implements that\n * functionallity.\n *\n * @module array\n */\nimport { asPitch, isPitch, strPitch, pitch, fifths, focts } from \"tonal-pitch\";\nimport { transpose as tr } from \"tonal-transpose\";\nimport { semitones } from \"tonal-distance\";\n\nfunction split(sep) {\n  return function(o) {\n    return o === undefined\n      ? []\n      : Array.isArray(o)\n        ? o\n        : typeof o === \"string\" ? o.trim().split(sep) : [o];\n  };\n}\n\n// utility\nvar isArr = Array.isArray;\nfunction hasVal(e) {\n  return e || e === 0;\n}\n\n/**\n * Convert anything to array. Speifically, split string separated by spaces,\n * commas or bars. If you give it an actual array, it returns it without\n * modification.\n *\n * This function __always__ returns an array (null or undefined values are converted\n * to empty arrays)\n *\n * Thanks to this function, the rest of the functions of this module accepts\n * strings as an array parameter.\n *\n * @function\n * @param {*} source - the thing to get an array from\n * @return {Array} the object as an array\n *\n * @example\n * import { asArr } from 'tonal-arrays'\n * asArr('C D E F G') // => ['C', 'D', 'E', 'F', 'G']\n * asArr('A, B, c') // => ['A', 'B', 'c']\n * asArr('1 | 2 | x') // => ['1', '2', 'x']\n */\nexport var asArr = split(/\\s*\\|\\s*|\\s*,\\s*|\\s+/);\n\n/**\n * Return a new array with the elements mapped by a function.\n * Basically the same as the JavaScript standard `array.map` but with\n * two enhacements:\n *\n * - Arrays can be expressed as strings (see [asArr])\n * - This function can be partially applied. This is useful to create _mapped_\n * versions of single element functions. For an excellent introduction of\n * the adventages [read this](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html)\n *\n * @param {Function} fn - the function\n * @param {Array|String} arr - the array to be mapped\n * @return {Array}\n * @example\n * var arr = require('tonal-arr')\n * var toUp = arr.map(function(e) { return e.toUpperCase() })\n * toUp('a b c') // => ['A', 'B', 'C']\n *\n * @example\n * var tonal = require('tonal')\n * tonal.map(tonal.transpose('M3'), 'C D E') // => ['E', 'F#', 'G#']\n */\nexport function map(fn, list) {\n  return arguments.length > 1\n    ? map(fn)(list)\n    : function(l) {\n        return asArr(l).map(fn);\n      };\n}\n\n/**\n * Return a copy of the array with the null values removed\n * @param {String|Array} list\n * @return {Array}\n * @example\n * tonal.compact(['a', 'b', null, 'c']) // => ['a', 'b', 'c']\n */\nexport function compact(arr) {\n  return asArr(arr).filter(hasVal);\n}\n\n/**\n * Filter an array with a function. Again, almost the same as JavaScript standard\n * filter function but:\n *\n * - It accepts strings as arrays\n * - Can be partially applied\n *\n * @param {Function} fn\n * @param {String|Array} arr\n * @return {Array}\n * @example\n * t.filter(t.noteName, 'a b c x bb') // => [ 'a', 'b', 'c', 'bb' ]\n */\nexport function filter(fn, list) {\n  return arguments.length > 1\n    ? filter(fn)(list)\n    : function(l) {\n        return asArr(l).filter(fn);\n      };\n}\n\n// a custom height function that\n// - returns -Infinity for non-pitch objects\n// - assumes pitch classes has octave -100 (so are sorted before that notes)\nfunction objHeight(p) {\n  if (!p) return -Infinity;\n  var f = fifths(p) * 7;\n  var o = focts(p) || -Math.floor(f / 12) - 100;\n  return f + o * 12;\n}\n\n// ascending comparator\nfunction ascComp(a, b) {\n  return objHeight(a) - objHeight(b);\n}\n// descending comparator\nfunction descComp(a, b) {\n  return -ascComp(a, b);\n}\n\n/**\n * Sort a list of notes or intervals in ascending or descending pitch order.\n * It removes from the list any thing is not a pitch (a note or interval)\n *\n * Note this function returns a __copy__ of the array, it does NOT modify\n * the original.\n *\n * @param {Array|String} list - the list of notes or intervals\n * @param {Boolean|Function} comp - (Optional) comparator.\n * Ascending pitch by default. Pass a `false` to order descending\n * or a custom comparator function (that receives pitches in array notation).\n * Note that any other value is ignored.\n * @example\n * array.sort('D E C') // => ['C', 'D', 'E']\n * array.sort('D E C', false) // => ['E', 'D', 'C']\n * // if is not a note, it wil be removed\n * array.sort('g h f i c') // => ['C', 'F', 'G']\n */\nexport function sort(list, comp) {\n  var fn =\n    arguments.length === 1 || comp === true\n      ? ascComp\n      : comp === false ? descComp : typeof comp === \"function\" ? comp : ascComp;\n  // if the list is an array, make a copy\n  list = Array.isArray(list) ? list.slice() : asArr(list);\n  return listFn(function(arr) {\n    return arr.sort(fn).filter(hasVal);\n  }, list);\n}\n\n/**\n * Randomizes the order of the specified array using the Fisher–Yates shuffle.\n *\n * @function\n * @param {Array|String} arr - the array\n * @return {Array} the shuffled array\n *\n * @example\n * import { shuffle } from 'tonal-arrays'\n * @example\n * var tonal = require('tonal')\n * tonal.shuffle('C D E F')\n */\nexport var shuffle = listFn(function(arr) {\n  var i, t;\n  var m = arr.length;\n  while (m) {\n    i = (Math.random() * m--) | 0;\n    t = arr[m];\n    arr[m] = arr[i];\n    arr[i] = t;\n  }\n  return arr;\n});\n\nfunction trOct(n) {\n  return tr(pitch(0, n, 1));\n}\n\n/**\n * Rotates a list a number of times. It's completly agnostic about the\n * contents of the list.\n * @param {Integer} times - the number of rotations\n * @param {Array|String} list - the list to be rotated\n * @return {Array} the rotated array\n */\nexport function rotate(times, list) {\n  var arr = asArr(list);\n  var len = arr.length;\n  var n = (times % len + len) % len;\n  return arr.slice(n, len).concat(arr.slice(0, n));\n}\n\n/**\n * Rotates an ascending list of pitches n times keeping the ascending property.\n * This functions assumes the list is an ascending list of pitches, and\n * transposes the them to ensure they are ascending after rotation.\n * It can be used, for example, to invert chords.\n *\n * @param {Integer} times - the number of rotations\n * @param {Array|String} list - the list to be rotated\n * @return {Array} the rotated array\n */\nexport function rotateAsc(times, list) {\n  return listFn(function(arr) {\n    var len = arr.length;\n    var n = (times % len + len) % len;\n    var head = arr.slice(n, len);\n    var tail = arr.slice(0, n);\n    // See if the first note of tail is lower than the last of head\n    var s = semitones(head[len - n - 1], tail[0]);\n    if (s < 0) {\n      var octs = Math.floor(s / 12);\n      if (times < 0) head = head.map(trOct(octs));\n      else tail = tail.map(trOct(-octs));\n    }\n    return head.concat(tail);\n  }, list);\n}\n\n/**\n * Select elements from a list.\n *\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} list - the list of pitches\n * @return {Array} the selected elements (with nulls if not valid index)\n *\n * @example\n * import { select } from 'tonal-array'\n * select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n * select('-1 0 1 2 3', 'C D') // => [ null, null, 'C', 'D', null ]\n */\nexport function select(nums, list) {\n  if (arguments.length === 1) {\n    return function(l) {\n      return select(nums, l);\n    };\n  }\n  var arr = asArr(list);\n  return asArr(nums).map(function(n) {\n    return arr[n - 1] || null;\n  });\n}\n\n// http://stackoverflow.com/questions/9960908/permutations-in-javascript\n/**\n * Get all permutations of a list\n * @param {Array|Strng} list - the list\n * @return {Array<Array>} an array with all the permutations\n */\nexport function permutations(list) {\n  list = asArr(list);\n  if (list.length === 0) return [[]];\n  return permutations(list.slice(1)).reduce(function(acc, perm) {\n    return acc.concat(\n      list.map(function(e, pos) {\n        var newPerm = perm.slice();\n        newPerm.splice(pos, 0, list[0]);\n        return newPerm;\n      })\n    );\n  }, []);\n}\n\n// #### Transform lists in array notation\nfunction asPitchStr(p) {\n  return strPitch(p) || p;\n}\nfunction listToStr(v) {\n  return isPitch(v) ? strPitch(v) : isArr(v) ? v.map(asPitchStr) : v;\n}\n\n/**\n * Decorates a function to so it's first parameter is an array of pitches in\n * array notation. Also, if the return value is a pitch or an array of pitches\n * in array notation, it convert backs to strings.\n *\n * @private\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n * @example\n * import { listFn } from 'tonal-arrays'\n * var octUp = listFn((p) => { p[2] = p[2] + 1; return p[2] })\n * octUp('C2 D2 E2') // => ['C3', 'D3', 'E3']\n */\nfunction listFn(fn, list) {\n  if (arguments.length === 1) {\n    return function(l) {\n      return listFn(fn, l);\n    };\n  }\n  var arr = asArr(list).map(asPitch);\n  var res = fn(arr);\n  return listToStr(res);\n}\n","/**\n * Functions to transpose o calculate distances from a collection of notes.\n *\n * A useful concept is _harmonizer_: a function that _harmonizes_ notes. It can\n * be created by partially applying the `harmonize` function (see examples)\n *\n * @example\n * var harmonizer = require('tonal-harmonizer')\n * harmonizer.harmonize('1P 3M 5P', 'C') // => ['C', 'E', 'G']\n * var maj7 = harmonizer.harmonize('1P 3M 5P 7M')\n * maj7('D4') // =>  ['D4', 'F#4', 'A4', 'C#5']\n * harmonizer.harmonics('C E G') // => ['1P', '3M', '5P']\n *\n * @example\n * // in tonal this functions are NOT namespaced\n * var tonal = require('tonal')\n * tonal.harmonize('1P 3M 5P', 'G')\n *\n * @example\n * // using ES6 import syntax\n * import { harmonize } from 'tonal-harmonizer'\n * harmonize(...)\n *\n * @module harmonizer\n */\nimport { transpose as tr } from \"tonal-transpose\";\nimport { interval } from \"tonal-distance\";\nimport { asArr, map, compact } from \"tonal-array\";\n\n/**\n * Given a list of notes, return the distance from the first note to the rest.\n * @param {Array|String} notes - the list of notes\n * @return {Array} the intervals relative to the first note\n * @example\n * harmonizer.harmonics('C E G') // => ['1P', '3M', '5P']\n *\n * @example\n * // in tonal this functions are NOT namespaced\n * tonal.harmonics(tonal.scale('C major')) // => ['1P', ...]\n */\nexport function harmonics(list) {\n  var a = asArr(list);\n  return a.length ? compact(a.map(interval(a[0]))) : a;\n}\n\n/**\n * Given a list of notes, return the intervallic structure: the distance from\n * one to the next.\n *\n * Notice that the number of intervals is one less that the number of notes.\n *\n * @param {Array|String} notes - the list of notes\n * @return {Array} the intervals relative to the previous\n * @example\n * harmonizer.intervallic('c e g') // => ['3M', '3m']\n * harmonizer.intervallic('e g c') // => ['3m', '4P']\n * harmonizer.intervallic('c') // => []\n */\nexport function intervallic(notes) {\n  var dist = [];\n  notes = asArr(notes);\n  for (var i = 1; i < notes.length; i++) {\n    dist.push(interval(notes[i - 1], notes[i]));\n  }\n  return dist;\n}\n\n/**\n * Given a list of intervals and a tonic, return that tonic transposed\n * to that intervals.\n *\n * It's currified and, calling with only one parameter, returns an harmonizer,\n * a function that harmonizes any note (see example)\n *\n * @function\n * @param {String|Array} list - the list of intervals\n * @param {String|Pitch} note - the note to be harmonized\n * @return {Array} the resulting notes\n * @example\n * harmonizer.harmonize('P1 M3 P5 M7', 'C') // => ['C', 'E', 'G', 'B']\n * @example\n * // harmonizer with partial application\n * var maj7 = harmonize.harmonizer('P1 M3 P5 M7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n * @example\n * // in tonal this function is NOT namespaced\n * var C = tonal.harmonizer('C D E')\n * C('M3') // => ['E', 'G#', 'B']\n */\nexport function harmonize(list, pitch) {\n  if (arguments.length > 1) return harmonize(list)(pitch);\n  return function(tonic) {\n    return compact(map(tr(tonic || \"P1\"), list));\n  };\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-note.svg)](https://www.npmjs.com/package/tonal-note)\n * [![tonal](https://img.shields.io/badge/tonal-note-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-note` is a collection of functions to manipulate musical notes in scientific notation\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * import * as note from 'tonal-note'\n * // or var note = require('tonal-note')\n * note.name('bb2') // => 'Bb2'\n * note.chroma('bb2') // => 10\n * note.midi('a4') // => 69\n * note.freq('a4') // => 440\n * note.oct('G3') // => 3\n * \n * // part of tonal\n * const tonal = require('tonal')\n * tonal.note.midi('d4') // => 62\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-note](https://nodei.co/npm/tonal-note.png?mini=true)](https://npmjs.org/package/tonal-note/)\n *\n * ## API Documentation\n *\n * @module note\n */\nimport { fifths, asNotePitch } from \"tonal-pitch\";\n\nconst REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/;\n\nexport function split(str) {\n  const m = REGEX.exec(str);\n  if (!m) return null;\n  return {\n    letter: m[1].toUpperCase(),\n    acc: m[2].replace(/x/g, \"##\"),\n    oct: m[3],\n    mod: m[4]\n  };\n}\n\nfunction parseNote(str) {\n  const p = split(str);\n  return p && p.mod === \"\"\n    ? {\n        step: (p.letter.charCodeAt(0) + 3) % 7,\n        alt: p.acc[0] === \"b\" ? -p.acc.length : p.acc.length,\n        oct: p.oct.length ? +p.oct : null\n      }\n    : null;\n}\n\nvar cache = {};\nexport function parse(name) {\n  if (typeof name !== \"string\") return null;\n  return cache[name] === undefined\n    ? (cache[name] = parseNote(name))\n    : cache[name];\n}\n\nconst parsed = fn => (str, p) => ((p = parse(str)) !== null ? fn(p) : null);\n\nconst SEMI = [0, 2, 4, 5, 7, 9, 11];\nconst toMidi = parsed(\n  p => (p.oct !== null ? SEMI[p.step] + p.alt + 12 * (p.oct + 1) : null)\n);\n/**\n * Get the note midi number\n * (an alias of tonal-midi `toMidi` function)\n *\n * @function\n * @param {string|Number} note - the note to get the midi number from\n * @return {Integer} the midi number or null if not valid pitch\n * @example\n * note.midi('C4') // => 60\n * note.midi(60) // => 60\n * @see midi.toMidi\n */\nexport const midi = note => toMidi(note) || +note || null;\n\nvar FLATS = \"C Db D Eb E F Gb G Ab A Bb B\".split(\" \");\nvar SHARPS = \"C C# D D# E F F# G G# A A# B\".split(\" \");\n/**\n * Given a midi number, returns a note name. The altered notes will have\n * flats unless explicitly set with the optional `useSharps` parameter.\n *\n * @function\n * @param {number} midi - the midi note number\n * @param [boolean] useSharps - (Optional) set to true to use sharps instead of flats\n * @return {string} the note name\n * @example\n * var midi = require('tonal-midi')\n * midi.note(61) // => 'Db4'\n * midi.note(61, true) // => 'C#4'\n * // it rounds to nearest note\n * midi.note(61.7) // => 'D4'\n */\nexport function fromMidi(num, sharps) {\n  num = Math.round(num);\n  var pcs = sharps === true ? SHARPS : FLATS;\n  var pc = pcs[num % 12];\n  var o = Math.floor(num / 12) - 1;\n  return pc + o;\n}\n\n/**\n * Get the frequency of a note\n *\n * @function\n * @param {string|Number} note - the note name or midi note number\n * @return {Number} the frequency\n * @example\n * note.freq('A4') // => 440\n */\nexport const freq = (str, m) =>\n  (m = midi(str)) !== null ? Math.pow(2, (m - 69) / 12) * 440 : null;\n\n/**\n * Return the chroma of a note. The chroma is the numeric equivalent to the\n * pitch class, where 0 is C, 1 is C# or Db, 2 is D... 11 is B\n *\n * @param {string} note - the note name\n * @return {Integer} the chroma number\n * @example\n * var note = require('tonal-note')\n * note.chroma('Cb') // => 11\n * ['C', 'D', 'E', 'F'].map(note.chroma) // => [0, 2, 4, 5]\n */\nexport const chroma = parsed(p => (SEMI[p.step] + p.alt + 120) % 12);\n\n/**\n * @deprecated\n * An alias for note. Get the name of a note in scientific notation\n * @function\n */\nexport function note(n) {\n  console.warn(\"note.note() is deprecated. Use note.name()\");\n  return name(n);\n}\n\n/**\n * Get the octave of the given pitch\n *\n * @function\n * @param {string} note - the note\n * @return {Integer} the octave or null if doesn't have an octave or not a valid note\n * @example\n * note.oct('C#4') // => 4\n * note.oct('C') // => null\n * note.oct('blah') // => null\n */\nexport const oct = parsed(p => p.oct);\n\n/**\n * Get the note in a given octave\n * @function\n */\nexport const inOct = (oct, note) => pc(note) + oct;\n\n/**\n * Get the note step: a number equivalent of the note letter. 0 means C and\n * 6 means B. This is different from `chroma` (see example)\n *\n * @function\n * @param {string} note - the note\n * @return {Integer} a number between 0 and 6 or null if not a note\n * @example\n * note.step('C') // => 0\n * note.step('Cb') // => 0\n * // usually what you need is chroma\n * note.chroma('Cb') // => 6\n */\nexport const step = parsed(p => p.step);\n\n/**\n * @deprecated\n * Get the note step in fifths from 'C'. One property of the perfect fifth\n * interval is that you can obtain any pitch class by transposing 'C' a\n * number of times. This function return that number.\n * @param {string|Pitch} note - the note (can be a pitch class)\n * @return {Integer} the number of fifths to reach that pitch class from 'C'\n */\nexport function pcFifths(note) {\n  console.warn(\"Deprecated. Do you really need this?\");\n  var p = asNotePitch(note);\n  return p ? fifths(p) : null;\n}\n\n/**\n * Get the note alteration: a number equivalent to the accidentals. 0 means\n * no accidentals, negative numbers are for flats, positive for sharps\n *\n * @function\n * @param {string|Pitch} note - the note\n * @return {Integer} the alteration\n * @example\n * note.alt('C') // => 0\n * note.alt('C#') // => 1\n * note.alt('Cb') // => -1\n */\nexport const alt = parsed(p => p.alt);\n\nconst LETTERS = \"CDEFGAB\";\n/**\n * Given a step number return it's letter (0 = C, 1 = D, 2 = E)\n * @param {number} step \n * @return {string} the letter\n * @private\n */\nconst letter = step => LETTERS[step];\n\nconst fillStr = (s, n) => Array(n + 1).join(s);\nconst numToStr = (num, op) => (typeof num !== \"number\" ? \"\" : op(num));\n\nconst acc = alt =>\n  numToStr(alt, alt => (alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt)));\n\n/**\n * Build a note name in scientific notation from a parsed note \n * (an object with { step, alt, oct })\n * @function\n * @param {parsed} parsed\n * @return {string} the note name\n * @example\n * note.build({ step: 1, alt: -1, oct: 3 }) // => Db3\n */\nexport const build = p => letter(p.step) + acc(p.alt) + numToStr(p.oct, o => o);\n\n/**\n * Given a note name, return the note name or null if not valid note.\n * The note name will ALWAYS have the letter in upercase and accidentals\n * using # or b\n * \n * Can be used to test if a string is a valid note name.\n *\n * @function\n * @param {Pitch|string}\n * @return {string}\n *\n * @example\n * var note = require('tonal-note')\n * note.name('cb2') // => 'Cb2'\n * ['c', 'db3', '2', 'g+', 'gx4'].map(note.name) // => ['C', 'Db3', null, null, 'G##4']\n */\nexport const name = parsed(p => build(p));\n\n/**\n * Get pitch class of a note. The note can be a string or a pitch array.\n *\n * @function\n * @param {string|Pitch}\n * @return {string} the pitch class\n * @example\n * tonal.pc('Db3') // => 'Db'\n * tonal.map(tonal.pc, 'db3 bb6 fx2') // => [ 'Db', 'Bb', 'F##']\n */\nexport const pc = parsed(p => letter(p.step) + acc(p.alt));\n","// shorthand tonal notation (with quality after number)\nvar IVL_TNL = '([-+]?)(\\\\d+)(d{1,4}|m|M|P|A{1,4})'\n// standard shorthand notation (with quality before number)\nvar IVL_STR = '(AA|A|P|M|m|d|dd)([-+]?)(\\\\d+)'\nvar COMPOSE = '(?:(' + IVL_TNL + ')|(' + IVL_STR + '))'\nvar IVL_REGEX = new RegExp('^' + COMPOSE + '$')\n\n/**\n * Parse a string with an interval in shorthand notation (https://en.wikipedia.org/wiki/Interval_(music)#Shorthand_notation)\n * and returns an object with interval properties.\n *\n * @param {String} str - the string with the interval\n * @param {Boolean} strict - (Optional) if its false, it doesn't check if the\n * interval is valid or not. For example, parse('P2') returns null\n * (because a perfect second is not a valid interval), but\n * parse('P2', false) it returns { num: 2, dir: 1, q: 'P'... }\n * @return {Object} an object properties or null if not valid interval string\n * The returned object contains:\n * - `num`: the interval number\n * - `q`: the interval quality string (M is major, m is minor, P is perfect...)\n * - `simple`: the simplified number (from 1 to 7)\n * - `dir`: the interval direction (1 ascending, -1 descending)\n * - `type`: the interval type (P is perfectable, M is majorable)\n * - `alt`: the alteration, a numeric representation of the quality\n * - `oct`: the number of octaves the interval spans. 0 for simple intervals.\n * - `size`: the size of the interval in semitones\n * @example\n * var parse = require('interval-notation').parse\n * parse('M3')\n * // => { num: 3, q: 'M', dir: 1, simple: 3,\n * //      type: 'M', alt: 0, oct: 0, size: 4 }\n */\nexport function parse (str, strict) {\n  if (typeof str !== 'string') return null\n  var m = IVL_REGEX.exec(str)\n  if (!m) return null\n  var i = { num: +(m[3] || m[8]), q: m[4] || m[6] }\n  i.dir = (m[2] || m[7]) === '-' ? -1 : 1\n  var step = (i.num - 1) % 7\n  i.simple = step + 1\n  i.type = TYPES[step]\n  i.alt = qToAlt(i.type, i.q)\n  i.oct = Math.floor((i.num - 1) / 7)\n  i.size = i.dir * (SIZES[step] + i.alt + 12 * i.oct)\n  if (strict !== false) {\n    if (i.type === 'M' && i.q === 'P') return null\n  }\n  return i\n}\nvar SIZES = [0, 2, 4, 5, 7, 9, 11]\n\nvar TYPES = 'PMMPPMM'\n/**\n * Get the type of interval. Can be perfectavle ('P') or majorable ('M')\n * @param {Integer} num - the interval number\n * @return {String} `P` if it's perfectable, `M` if it's majorable.\n */\nexport function type (num) {\n  return TYPES[(num - 1) % 7]\n}\n\nfunction dirStr (dir) { return dir === -1 ? '-' : '' }\nfunction num (simple, oct) { return simple + 7 * oct }\n\n/**\n * Build a shorthand interval notation string from properties.\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.shorthand(3, 0, 0, 1) // => 'M3'\n * interval.shorthand(3, -1, 0, -1) // => 'm-3'\n * interval.shorthand(3, 1, 1, 1) // => 'A10'\n */\nexport function shorthand (simple, alt, oct, dir) {\n  return altToQ(simple, alt) + dirStr(dir) + num(simple, oct)\n}\n/**\n * Build a special shorthand interval notation string from properties.\n * The special shorthand interval notation changes the order or the standard\n * shorthand notation so instead of 'M-3' it returns '-3M'.\n *\n * The standard shorthand notation has a string 'A4' (augmented four) that can't\n * be differenciate from 'A4' (the A note in 4th octave), so the purpose of this\n * notation is avoid collisions\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.build(3, 0, 0, 1) // => '3M'\n * interval.build(3, -1, 0, -1) // => '-3m'\n * interval.build(3, 1, 1, 1) // => '10A'\n */\nexport function build (simple, alt, oct, dir) {\n  return dirStr(dir) + num(simple, oct) + altToQ(simple, alt)\n}\n\n/**\n * Get an alteration number from an interval quality string.\n * It accepts the standard `dmMPA` but also sharps and flats.\n *\n * @param {Integer|String} num - the interval number or a string representing\n * the interval type ('P' or 'M')\n * @param {String} quality - the quality string\n * @return {Integer} the interval alteration\n * @example\n * qToAlt('M', 'm') // => -1 (for majorables, 'm' is -1)\n * qToAlt('P', 'A') // => 1 (for perfectables, 'A' means 1)\n * qToAlt('M', 'P') // => null (majorables can't be perfect)\n */\nexport function qToAlt (num, q) {\n  var t = typeof num === 'number' ? type(num) : num\n  if (q === 'M' && t === 'M') return 0\n  if (q === 'P' && t === 'P') return 0\n  if (q === 'm' && t === 'M') return -1\n  if (/^A+$/.test(q)) return q.length\n  if (/^d+$/.test(q)) return t === 'P' ? -q.length : -q.length - 1\n  return null\n}\n\nfunction fillStr (s, n) { return Array(Math.abs(n) + 1).join(s) }\n/**\n * Get interval quality from interval type and alteration\n *\n * @function\n * @param {Integer|String} num - the interval number of the the interval\n * type ('M' for majorables, 'P' for perfectables)\n * @param {Integer} alt - the interval alteration\n * @return {String} the quality string\n * @example\n * altToQ('M', 0) // => 'M'\n */\nexport function altToQ (num, alt) {\n  var t = typeof num === 'number' ? type(Math.abs(num)) : num\n  if (alt === 0) return t === 'M' ? 'M' : 'P'\n  else if (alt === -1 && t === 'M') return 'm'\n  else if (alt > 0) return fillStr('A', alt)\n  else if (alt < 0) return fillStr('d', t === 'P' ? alt : alt + 1)\n  else return null\n}\n\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-interval.svg)](https://www.npmjs.com/package/tonal-interval)\n * [![tonal](https://img.shields.io/badge/tonal-interval-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-interval` is a collection of functions to create and manipulate music intervals.\n *\n * The intervals are strings in shorthand notation. Two variations are supported:\n *\n * - standard shorthand notation: type and number, for example: 'M3', 'd-4'\n * - inverse shorthand notation: number and then type, for example: '3M', '-4d'\n *\n * The problem with the standard shorthand notation is that some strings can be\n * parsed as notes or intervals, for example: 'A4' can be note A in 4th octave\n * or an augmented four. To remove ambiguity, the prefered notation in tonal is the\n * inverse shortand notation.\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * import * as interval from 'tonal-interval'\n * // or var interval = require('tonal-interval')\n * interval.semitones('4P') // => 5\n * interval.invert('3m') // => '6M'\n * interval.simplify('9m') // => '2m'\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-interval](https://nodei.co/npm/tonal-interval.png?mini=true)](https://npmjs.org/package/tonal-interval/)\n *\n * ## API Documentation\n *\n * @module interval\n */\nimport { build } from \"interval-notation\";\nimport {\n  asIvlPitch,\n  ivlFn,\n  chr,\n  dir,\n  strIvl,\n  encode,\n  decode,\n  height\n} from \"tonal-pitch\";\n\n/**\n * Get interval name. Can be used to test if it's an interval. It accepts intervals\n * as pitch or string in shorthand notation or tonal notation. It returns always\n * intervals in tonal notation.\n *\n * @param {String|Pitch} interval - the interval string or array\n * @return {String} the interval name or null if not valid interval\n * @example\n * interval.toInterval('m-3') // => '-3m'\n * interval.toInterval('3') // => null\n */\nexport function toInterval(ivl) {\n  var i = asIvlPitch(ivl);\n  return i ? strIvl(i) : null;\n}\n\n/**\n * Get the number of the interval (same as value, but always positive)\n *\n * @param {String|Pitch} interval - the interval\n * @return {Integer} the positive interval number (P1 is 1, m2 is 2, ...)\n * @example\n * interval.num('m2') // => 2\n * interval.num('P9') // => 9\n * interval.num('P-4') // => 4\n */\nexport function num(ivl) {\n  var p = props(ivl);\n  return p ? p.num : null;\n}\n\n/**\n * Get the interval value (the interval number, but positive or negative\n * depending the interval direction)\n *\n * @param {String|Pitch} interval - the interval\n * @return {Integer} the positive interval number (P1 is 1, m-2 is -2, ...)\n * @example\n * interval.num('m2') // => 2\n * interval.num('m9') // => 9\n * interval.num('P-4') // => -4\n * interval.num('m-9') // => -9\n */\nexport function value(ivl) {\n  var p = props(ivl);\n  return p ? p.num * p.dir : null;\n}\n\n/**\n * Get interval properties. It returns an object with:\n *\n * - num: the interval number (always positive)\n * - alt: the interval alteration (0 for perfect in perfectables, or 0 for major in _majorables_)\n * - dir: the interval direction (1 ascending, -1 descending)\n *\n * @param {String|Pitch} interval - the interval\n * @return {Array} the interval in the form [number, alt]\n * @example\n * interval.parse('m2') // => { num: 2, alt: -1, dir: 1 }\n * interval.parse('m9') // => { num: 9, alt: -1, dir: 1 }\n * interval.parse('P-4') // => { num: 4, alt: 0, dir: -1}\n * interval.parse('m-9') // => { num: 9, alt: -1, dir: -1 }\n */\nexport function props(ivl) {\n  var i = asIvlPitch(ivl);\n  if (!i) return null;\n  var d = decode(i);\n  return { num: d[0] + 1 + d[2] * 7, alt: d[1], dir: i[2] };\n}\n\n/**\n * Given a interval property object, get the interval name\n *\n * @param {Object} props - the interval property object\n *\n * - num: the interval number\n * - alt: the interval alteration\n * - dir: the direction\n * @return {String} the interval name\n */\nexport function fromProps(props) {\n  if (!props || props.num < 1) return null;\n  var octs = Math.floor(props.num / 8);\n  var simple = props.num - 7 * octs;\n  return build(simple, props.alt || 0, octs, props.dir);\n}\n\n/**\n * Get size in semitones of an interval\n * @param {String|Pitch} ivl\n * @return {Integer} the number of semitones or null if not an interval\n * @example\n * import { semitones } from 'tonal-interval'\n * semitones('P4') // => 5\n * // or using tonal\n * tonal.semitones('P5') // => 7\n */\nexport function semitones(ivl) {\n  var i = asIvlPitch(ivl);\n  return i ? height(i) : null;\n}\n\n// interval numbers\nvar IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];\n// interval qualities\nvar IQ = \"P m M m M P d P m M m M\".split(\" \");\n\n/**\n * Get interval name from semitones number. Since there are several interval\n * names for the same number, the name it's arbitraty, but deterministic.\n * @param {Integer} num - the number of semitones (can be negative)\n * @return {String} the interval name\n * @example\n * import { fromSemitones } from 'tonal-interval'\n * fromSemitones(7) // => '5P'\n * // or using tonal\n * tonal.fromSemitones(-7) // => '-5P'\n */\nexport function fromSemitones(num) {\n  var d = num < 0 ? -1 : 1;\n  var n = Math.abs(num);\n  var c = n % 12;\n  var o = Math.floor(n / 12);\n  return d * (IN[c] + 7 * o) + IQ[c];\n}\n\nvar CLASSES = [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1];\n/**\n * Get the [interval class](https://en.wikipedia.org/wiki/Interval_class)\n * number of a given interval.\n *\n * In musical set theory, an interval class is the shortest distance in\n * pitch class space between two unordered pitch classes\n *\n * As paramter you can pass an interval in shorthand notation, an interval in\n * array notation or the number of semitones of the interval\n *\n * @param {String|Integer} interval - the interval or the number of semitones\n * @return {Integer} A value between 0 and 6\n *\n * @example\n * interval.ic('P8') // => 0\n * interval.ic('m6') // => 4\n * ['P1', 'M2', 'M3', 'P4', 'P5', 'M6', 'M7'].map(ic) // => [0, 2, 4, 5, 5, 3, 1]\n */\nexport function ic(ivl) {\n  var i = asIvlPitch(ivl);\n  var s = i ? chr(i) : Math.round(ivl);\n  return isNaN(s) ? null : CLASSES[Math.abs(s) % 12];\n}\n\nvar TYPES = \"PMMPPMM\";\n/**\n * Get interval type. Can be perfectable (1, 4, 5) or majorable (2, 3, 6, 7)\n * It does NOT return the actual quality.\n *\n * @param {String|Pitch} interval\n * @return {String} 'P' for perfectables, 'M' for majorables or null if not\n * valid interval\n * @example\n * interval.type('5A') // => 'P'\n */\nexport function type(ivl) {\n  var i = asIvlPitch(ivl);\n  return i ? TYPES[decode(i)[0]] : null;\n}\n\n/**\n * Get the inversion (https://en.wikipedia.org/wiki/Inversion_(music)#Intervals)\n * of an interval.\n *\n * @function\n * @param {String|Pitch} interval - the interval to invert in interval shorthand\n * notation or interval array notation\n * @return {String|Pitch} the inverted interval\n *\n * @example\n * interval.invert('3m') // => '6M'\n * interval.invert('2M') // => '7m'\n */\nexport var invert = ivlFn(function(i) {\n  var d = decode(i);\n  // d = [step, alt, oct]\n  var step = (7 - d[0]) % 7;\n  var alt = TYPES[d[0]] === \"P\" ? -d[1] : -(d[1] + 1);\n  return encode(step, alt, d[2], dir(i));\n});\n\n/**\n * Get the simplified version of an interval.\n *\n * @function\n * @param {String|Array} interval - the interval to simplify\n * @return {String|Array} the simplified interval\n *\n * @example\n * interval.simplify('9M') // => '2M'\n * ['8P', '9M', '10M', '11P', '12P', '13M', '14M', '15P'].map(interval.simplify)\n * // => [ '8P', '2M', '3M', '4P', '5P', '6M', '7M', '8P' ]\n * interval.simplify('2M') // => '2M'\n * interval.simplify('-2M') // => '7m'\n */\nexport var simplify = ivlFn(function(i) {\n  // decode to [step, alt, octave]\n  var dec = decode(i);\n  // if it's not 8 reduce the octaves to 0\n  if (dec[0] !== 0 || dec[2] !== 1) dec[2] = 0;\n  // encode back\n  return encode(dec[0], dec[1], dec[2], dir(i));\n});\n","'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n","/**\n * A midi note number is a number representation of a note pitch. It can be\n * integers so it's equal tempered tuned, or float to indicate it's not\n * tuned into equal temepered scale.\n *\n * This module contains functions to convert to and from midi notes.\n *\n * @example\n * var midi = require('tonal-midi')\n * midi.toMidi('A4') // => 69\n * midi.note(69) // => 'A4'\n * midi.note(61) // => 'Db4'\n * midi.note(61, true) // => 'C#4'\n *\n * @module midi\n */\n\nimport { midi } from \"note-parser\";\n\n/**\n * Convert the given note to a midi note number. If you pass a midi number it\n * will returned as is.\n *\n * @param {Array|String|Number} note - the note to get the midi number from\n * @return {Integer} the midi number or null if not valid pitch\n * @example\n * midi.toMidi('C4') // => 60\n * midi.toMidi(60) // => 60\n * midi.toMidi('60') // => 60\n */\nexport function toMidi(val) {\n  if (Array.isArray(val) && val.length === 2)\n    return val[0] * 7 + val[1] * 12 + 12;\n  return midi(val);\n}\n\nvar FLATS = \"C Db D Eb E F Gb G Ab A Bb B\".split(\" \");\nvar SHARPS = \"C C# D D# E F F# G G# A A# B\".split(\" \");\n\n/**\n * Given a midi number, returns a note name. The altered notes will have\n * flats unless explicitly set with the optional `useSharps` parameter.\n *\n * @function\n * @param {Integer} midi - the midi note number\n * @param {Boolean} useSharps - (Optional) set to true to use sharps instead of flats\n * @return {String} the note name\n * @example\n * var midi = require('tonal-midi')\n * midi.note(61) // => 'Db4'\n * midi.note(61, true) // => 'C#4'\n * // it rounds to nearest note\n * midi.note(61.7) // => 'D4'\n */\nexport function note(num, sharps) {\n  if (num === true || num === false)\n    return function(m) {\n      return note(m, num);\n    };\n  num = Math.round(num);\n  var pcs = sharps === true ? SHARPS : FLATS;\n  var pc = pcs[num % 12];\n  var o = Math.floor(num / 12) - 1;\n  return pc + o;\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-freq.svg)](https://www.npmjs.com/package/tonal-freq)\n * [![tonal](https://img.shields.io/badge/tonal-freq-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-freq` is a collection of functions to perform calculations related to frequencies.\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * var freq = require('tonal-freq')\n * freq.toFreq('A4') // => 440\n * freq.note(440) // => 'A4'\n * freq.noteAndDetune(320) // => ['C4', 200]\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-freq](https://nodei.co/npm/tonal-freq.png?mini=true)](https://npmjs.org/package/tonal-freq/)\n *\n * ## API Documentation\n *\n * @module freq\n */\nimport { toMidi as noteToMidi, note as midiToNote } from \"tonal-midi\";\n\n// decorate a function to round the numeric result to a max\nfunction round(m, fn) {\n  m = m || m === 0 ? Math.pow(10, m) : false;\n  return function(v) {\n    v = fn(v);\n    return v === null ? null : m ? Math.round(v * m) / m : v;\n  };\n}\n\n/**\n * Return the equal tempered frequency of a note.\n *\n * This function can be partially applied if note parameter is not present.\n * @function\n * @param {Float} ref - the tuning reference\n * @param {Integer} maxDecimals - (Optional) the maximum number of decimals (all by default)\n * @param {String|Pitch} note - the note to get the frequency from\n * @return {Number} the frequency\n * @example\n * eqTempFreq(444, 4, 'C3')\n * const toFreq = eqTempFreq(444, 2)\n * toFreq('A3') // => 222\n */\nexport function eqTempFreq(ref, max, note) {\n  if (arguments.length > 2) return eqTempFreq(ref, max)(note);\n  return round(max, function(p) {\n    var m = noteToMidi(p);\n    return m ? Math.pow(2, (m - 69) / 12) * ref : null;\n  });\n}\n\n/**\n * Get the frequency of note with 2 decimals precission using A4 440Hz tuning\n *\n * This is an alias for: `eqTempFreq(440, 2, <note>)`\n *\n * @function\n * @param {Number|String} note - the note name or midi number\n * @return {Float} the frequency in herzs\n * @example\n * freq.toFreq('A4') // => 440\n * freq.toFreq('C4') // => 261.63\n */\nexport var toFreq = eqTempFreq(440, 2);\n\n/**\n * Get the midi note from a frequency in equal temperament scale. You can\n * specify the number of decimals of the midi number.\n *\n * @param {Float} tuning - (Optional) the reference A4 tuning (440Hz by default)\n * @param {Number} freq - the frequency\n * @return {Number} the midi number\n */\nexport function eqTempFreqToMidi(ref, max, freq) {\n  if (arguments.length > 2) return eqTempFreqToMidi(ref, max)(freq);\n  return round(max, function(freq) {\n    return 12 * (Math.log(freq) - Math.log(ref)) / Math.log(2) + 69;\n  });\n}\n\n/**\n * Get midi number from frequency with two decimals of precission.\n *\n * This is an alisas for: `eqTempFreqToMidi(440, 2, <freq>)`\n *\n * @function\n * @param {Float} freq\n * @return {Number} midi number\n * @example\n * freq.toMidi(361) // => 59.96\n */\nexport var toMidi = eqTempFreqToMidi(440, 2);\n\n/**\n * Get note name from frequency using an equal temperament scale with 440Hz\n * as reference\n *\n * @param {Float} freq\n * @param {Boolean} useSharps - (Optional) set to true to use sharps instead of flats\n * @return {String} note name\n * @example\n * freq.note(440) // => 'A4'\n */\nexport function note(freq, useSharps) {\n  return midiToNote(toMidi(freq), useSharps);\n}\n\n/**\n * Get difference in cents between two frequencies. The frequencies can be\n * expressed with hertzs or midi numbers or note names\n * @param {Float|Integer|String} base\n * @param {Float|Integer|String} freq\n * @return {Integer} The difference in cents\n * @example\n * import { cents } from 'tonal-freq'\n * cents('C4', 261) // => -4\n */\nexport function cents(base, freq) {\n  var b = toFreq(base) || base;\n  var f = toFreq(freq) || freq;\n  return Math.round(1200 * (Math.log(f / b) / Math.log(2)));\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-pcset.svg?style=flat-square)](https://www.npmjs.com/package/tonal-pcset)\n * [![tonal](https://img.shields.io/badge/tonal-pcset-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-pcset` is a collection of functions to work with pitch class sets, oriented\n * to make comparations (isEqual, isSubset, isSuperset)\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * You can install via npm: `npm i --save tonal-pcset`\n *\n * ```js\n * var pcset = require('tonal-pcset')\n * pcset.isEqual('c2 d5 e6', 'c6 e3 d1') // => true\n * ```\n *\n * ## API documentation\n *\n * @module pcset\n */\nimport { chr, asPitch } from \"tonal-pitch\";\nimport { pc } from \"tonal-note\";\nimport { map, asArr, rotate, compact } from \"tonal-array\";\nimport { transpose } from \"tonal-transpose\";\n\nfunction chrToInt(set) {\n  return parseInt(chroma(set), 2);\n}\nfunction pitchChr(p) {\n  p = asPitch(p);\n  return p ? chr(p) : null;\n}\n\n/**\n * Get chroma of a pitch class set. A chroma identifies each set uniquely.\n * It's a 12-digit binary each presenting one semitone of the octave.\n *\n * Note that this function accepts a chroma as parameter and return it\n * without modification.\n *\n * @param {Array|String} set - the pitch class set\n * @return {String} a binary representation of the pitch class set\n * @example\n * pcset.chroma('C D E') // => '1010100000000'\n */\nexport function chroma(set) {\n  if (isChroma(set)) return set;\n  var b = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  map(pitchChr, set).forEach(i => {\n    b[i] = 1;\n  });\n  return b.join(\"\");\n}\n\n/**\n * @deprecated\n * @see collection.pcset\n * Given a list of notes, return the pitch class names of the set\n * starting with the first note of the list\n * @param {String|Array} notes - the pitch class set notes\n * @return {Array} an array of pitch class sets\n */\nexport function notes(notes) {\n  // FIXME: move to collection\n  console.warn(\"pcset.notes deprecated. Use collection.pcset\");\n  var pcs = map(pc, notes);\n  if (!pcs.length) return pcs;\n  var tonic = pcs[0];\n  // since the first note of the chroma is always C, we have to rotate it\n  var rotated = rotate(pitchChr(tonic), chroma(pcs).split(\"\")).join(\"\");\n  return fromChroma(rotated, tonic);\n}\n\n/**\n * Given a a list of notes or a pcset chroma, produce the rotations\n * of the chroma discarding the ones that starts with '0'\n *\n * This is used, for example, to get all the modes of a scale.\n *\n * @param {Array|String} set - the list of notes or pitchChr of the set\n * @param {Boolean} normalize - (Optional, true by default) remove all\n * the rotations that starts with '0'\n * @return {Array<String>} an array with all the modes of the chroma\n *\n * @example\n * pcset.modes('C E G')\n */\nexport function modes(set, normalize) {\n  normalize = normalize !== false;\n  var binary = chroma(set).split(\"\");\n  return compact(\n    binary.map(function(_, i) {\n      var r = rotate(i, binary);\n      return normalize && r[0] === \"0\" ? null : r.join(\"\");\n    })\n  );\n}\n\nvar REGEX = /^[01]{12}$/;\n/**\n * Test if the given string is a pitch class set chroma.\n * @param {String} chroma - the pitch class set chroma\n * @return {Boolean} true if its a valid pcset chroma\n * @example\n * pcset.isChroma('101010101010') // => true\n * pcset.isChroma('101001') // => false\n */\nexport function isChroma(set) {\n  return REGEX.test(set);\n}\n\nvar IVLS = \"1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M\".split(\" \");\n/**\n * Given a pcset (notes or chroma) return it's intervals\n * @param {String|Array} pcset - the pitch class set (notes or chroma)\n * @return {Array} intervals or empty array if not valid pcset\n * @example\n * pcset.intervals('1010100000000') => ['C', 'D', 'E']\n */\nexport function intervals(set) {\n  return compact(\n    chroma(set)\n      .split(\"\")\n      .map(function(d, i) {\n        return d === \"1\" ? IVLS[i] : null;\n      })\n  );\n}\n\n/**\n * @deprecated\n * @see intervals\n * Given a pitch class set in binary notation it returns the intervals or notes\n * (depending on the tonic)\n * @param {String} binary - the pitch class set in binary representation\n * @param {String|Pitch} tonic - the pitch class set tonic\n * @return {Array} a list of notes or intervals\n * @example\n * pcset.fromChroma('101010101010', 'C') // => ['C', 'D', 'E', 'Gb', 'Ab', 'Bb']\n */\nexport function fromChroma(binary, tonic) {\n  console.warn(\n    \"pcset.fromChroma is deprecated. Use pcset.intervals().map(...)\"\n  );\n  if (arguments.length === 1)\n    return function(t) {\n      return fromChroma(binary, t);\n    };\n  if (!tonic) tonic = \"P1\";\n  return intervals(binary).map(transpose(tonic));\n}\n\n/**\n * Test if two pitch class sets are identical\n *\n * @param {Array|String} set1 - one of the pitch class sets\n * @param {Array|String} set2 - the other pitch class set\n * @return {Boolean} true if they are equal\n * @example\n * pcset.isEqual('c2 d3', 'c5 d2') // => true\n */\nexport function isEqual(s1, s2) {\n  if (arguments.length === 1)\n    return function(s) {\n      return isEqual(s1, s);\n    };\n  return chroma(s1) === chroma(s2);\n}\n\n/**\n * Test if a pitch class set is a subset of another\n *\n * @param {Array|String} test - the set to test\n * @param {Array|String} set - the base set to test against\n * @return {Boolean} true if the test set is a subset of the set\n * @example\n * pcset.subset('c d e', 'C2 D4 D5 C6') // => true\n */\nexport function isSubset(test, set) {\n  test = chrToInt(test);\n  return (test & chrToInt(set)) === test;\n}\n\n/**\n * Test if a pitch class set is a superset\n *\n * @param {Array|String} test - the set to test\n * @param {Array|String} set - the base set to test against\n * @return {Boolean} true if the test set is a superset of the set\n * @example\n * pcset.isSuperset('c d e', 'C2 D4 F4 D5 E5 C6') // => true\n */\nexport function isSuperset(test, set) {\n  test = chrToInt(test);\n  return (test | chrToInt(set)) === test;\n}\n\n/**\n * Test if a given pitch class set includes a note\n * @param {Array|String} set - the base set to test against\n * @param {String|Pitch} note - the note to test\n * @return {Boolean} true if the note is included in the pcset\n * @example\n * pcset.includes('c d e', 'C4') // =A true\n * pcset.includes('c d e', 'C#4') // =A false\n */\nexport function includes(set, note) {\n  if (arguments.length > 1) return includes(set)(note);\n  set = chroma(set);\n  return function(note) {\n    return set[pitchChr(note)] === \"1\";\n  };\n}\n\n/**\n * Filter a list with a pitch class set\n *\n * @param {Array|String} set - the pitch class set notes\n * @param {Array|String} notes - the note list to be filtered\n * @return {Array} the filtered notes\n *\n * @example\n * pcset.filter('c d e', 'c2 c#2 d2 c3 c#3 d3') // => [ 'c2', 'd2', 'c3', 'd3' ])\n * pcset.filter('c2', 'c2 c#2 d2 c3 c#3 d3') // => [ 'c2', 'c3' ])\n */\nexport function filter(set, notes) {\n  if (arguments.length === 1)\n    return function(n) {\n      return filter(set, n);\n    };\n  return asArr(notes).filter(includes(set));\n}\n","/**\n * A collection of functions to create note ranges.\n *\n * @example\n * var range = require('tonal-range')\n * // ascending chromatic range\n * range.chromatic(['C4', 'E4']) // => ['C4', 'Db4', 'D4', 'Eb4', 'E4']\n * // descending chromatic range\n * range.chromatic(['E4', 'C4']) // => ['E4', 'Eb4', 'D4', 'Db4', 'C4']\n * // combining ascending and descending in complex ranges\n * range.chromatic(['C2', 'E2', 'D2']) // => ['C2', 'Db2', 'D2', 'Eb2', 'E2', 'Eb2', 'D2']\n * // numeric (midi note numbers) range\n * range.numeric('C4 E4 Bb3') // => [60, 61, 62, 63, 64]\n * // complex numeric range\n * range.numeric('C4 E4 Bb3') // => [60, 61, 62, 63, 64, 63, 62, 61, 60, 59, 58]\n * // create a scale range\n * range.pitchSet('c e g a', 'c2 c3 c2') // => [ 'C2', 'E2', 'G2', 'A2', 'C3', 'A2', 'G2', 'E2', 'C2' ] *\n g\n * @module range\n */\nimport { asArr, map } from \"tonal-array\";\nimport { trFifths } from \"tonal-transpose\";\nimport { toMidi, note } from \"tonal-midi\";\nimport { filter } from \"tonal-pcset\";\n\nfunction isNum(n) {\n  return typeof n === \"number\";\n}\n// convert notes to midi if needed\nfunction asNum(n) {\n  return isNum(n) ? n : toMidi(n);\n}\n// ascending range\nfunction ascR(b, n) {\n  for (var a = []; n--; a[n] = n + b);\n  return a;\n}\n// descending range\nfunction descR(b, n) {\n  for (var a = []; n--; a[n] = b - n);\n  return a;\n}\n// create a range between a and b\nfunction ran(a, b) {\n  return a === null || b === null\n    ? []\n    : a < b ? ascR(a, b - a + 1) : descR(a, a - b + 1);\n}\n\n/**\n * Create a numeric range. You supply a list of notes or numbers and it will\n * be conected to create complex ranges.\n *\n * @param {String|Array} list - the list of notes or numbers used\n * @return {Array} an array of numbers or empty array if not vald parameters\n *\n * @example\n * range.numeric([\"C5\", \"C4']) // => [ 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60 ]\n * // it works midi notes\n * range.numeric([10, 5]) // => [ 10, 9, 8, 7, 6, 5 ]\n * // complex range\n * range.numeric('C4 E4 Bb3') // => [60, 61, 62, 63, 64, 63, 62, 61, 60, 59, 58]\n * // can be expressed with a string or array\n * range.numeric('C2 C4 C2') === range.numeric(['C2', 'C4', 'C2'])\n */\nexport function numeric(list) {\n  return asArr(list)\n    .map(asNum)\n    .reduce(function(r, n, i) {\n      if (i === 1) return ran(r, n);\n      var last = r[r.length - 1];\n      return r.concat(ran(last, n).slice(1));\n    });\n}\n\n/**\n * Create a range of chromatic notes. The altered notes will use flats.\n *\n * @function\n * @param {String|Array} list - the list of notes or midi note numbers\n * @return {Array} an array of note names\n * @example\n * tonal.chromatic('C2 E2 D2') // => ['C2', 'Db2', 'D2', 'Eb2', 'E2', 'Eb2', 'D2']\n * // with sharps\n * tonal.chromatic('C2 C3', true) // => [ 'C2', 'C#2', 'D2', 'D#2', 'E2', 'F2', 'F#2', 'G2', 'G#2', 'A2', 'A#2', 'B2', 'C3' ]\n */\nexport function chromatic(list, sharps) {\n  return map(note(sharps === true), numeric(list));\n}\n\n/**\n * Create a range with a cycle of fifths\n * @function\n * @param {String|Pitch} tonic - the tonic note or pitch class\n * @param {Array|String} range - the range array\n * @return {Array} a range of cycle of fifths starting with the tonic\n * @example\n * range.fifths('C', [0, 6]) // => [ 'C', 'G', 'D', 'A', 'E', 'B', 'F#' ])\n */\nexport function fifths(tonic, range) {\n  return numeric(range).map(trFifths(tonic));\n}\n\n/**\n * Create a pitch set (scale or chord) range. Given a pitch set (a collection\n * of pitch classes), and a range array, it returns a range in notes.\n *\n * @param {String|Array|Function} scale - the scale to use or a function to\n * convert from midi numbers to note names\n * @param {String|Array} range - a list of notes or midi numbers\n * @return {Array} the scale range, an empty array if not valid source or\n * null if not valid start or end\n * @example\n * range.pitchSet('C D E F G A B', ['C3', 'C2'])\n * // => [ 'C3', 'B2', 'A2', 'G2', 'F2', 'E2', 'D2', 'C2' ]\n */\nexport function pitchSet(set, range) {\n  if (arguments.length === 1)\n    return function(l) {\n      return pitchSet(set, l);\n    };\n\n  return filter(set, chromatic(range));\n}\n","/**\n * Functions related to music notation in strings. Things like parse accidentals,\n * or convert from step to note letter.\n *\n * Glossary:\n *\n * - step: the number from 0 to 6 representing the letters from C to B\n * - letter: a valid note letter (from A to G)\n * - alteration: a number indicating the sharps (positive) or flats (negative)\n * - accidentals: a string with sharps (#) or flats (b)\n *\n * @example\n * var notation = require('tonal-notation')\n * notation.toAcc('3') // => '###'\n * notation.toAcc('-3') // => 'bbb'\n * notation.toAlt('###') // => 3\n * @module notation\n */\n\n/**\n * Given a letter, return step\n * @param {String} letter - the letter\n * @return {Integer} the step number (from 0 to 6)\n */\nexport function toStep(l) {\n  var s = \"CDEFGAB\".indexOf(l.toUpperCase());\n  return s < 0 ? null : s;\n}\n\n/**\n * Test if a number is a valid step number (a number from 0 to 6)\n * @param {Integer} step - the step number\n * @return {Boolean} true if it's a valid step number, false otherwise\n */\nexport function isStep(d) {\n  return !(d < 0 || d > 6);\n}\n\n/**\n * Given a step, return a letter\n * @param {Integer} step - the step number\n * @return {String} the note letter or null if not valid step number\n */\nexport function toLetter(s) {\n  return isStep(s) ? \"CDEFGAB\".charAt(s) : null;\n}\n\n// ACCIDENTALS\n// ===========\n\n/**\n * Test if a string are all flats (`b`) chars\n * @param {String} str - the string to test\n * @return {Boolean} true if all charaters are `b`, false otherwise\n */\nexport function areFlats(s) {\n  return /^b+$/.test(s);\n}\n/**\n * Test if a string are all sharps (`#`) chars\n * @param {String} str - the string to test\n * @return {Boolean} true if all charaters are `#`, false otherwise\n */\nexport function areSharps(s) {\n  return /^#+$/.test(s);\n}\n\n/**\n * Given an accidentals string return its alteration, the number\n * of semitones (positive for sharps, negative for flats, 0 for none)\n * @param {String} accidentals - the string to parse\n * @return {Integer} the alteration number of null if not a valid accidental strings\n * @example\n * toAlt('###') // => 3\n * toAlt('bbb') // => -3\n */\nexport function toAlt(s) {\n  return s === \"\"\n    ? 0\n    : areFlats(s) ? -s.length : areSharps(s) ? s.length : null;\n}\n\nfunction fillStr(s, num) {\n  return Array(num + 1).join(s);\n}\n\n/**\n * Given an alteration number, returns the accidentals string\n * @param {Integer} alteration - the number of semitones (positive and negative\n * values are accepted for sharps and flats)\n * @return {String} the accidental string\n * @example\n * toAcc(3) // => '###'\n * toAcc(-3) // => 'bbb'\n */\nexport function toAcc(n) {\n  return !n ? \"\" : n < 0 ? fillStr(\"b\", -n) : fillStr(\"#\", n);\n}\n","/**\n * _Key_ refers to the tonal system based on the major and minor scales. This is\n * is the most common tonal system, but tonality can be present in music\n * based in other scales or concepts.\n *\n * This is a collection of functions related to keys.\n *\n * @example\n * var key = require('tonal-key')\n * key.scale('E mixolydian') // => [ 'E', 'F#', 'G#', 'A', 'B', 'C#', 'D' ]\n * key.relative('minor', 'C major') // => 'A minor'\n *\n * @module key\n */\n\nimport { areFlats, areSharps, toAcc } from \"tonal-notation\";\nimport { trFifths } from \"tonal-transpose\";\nimport { pc, pcFifths } from \"tonal-note\";\nimport { numeric } from \"tonal-range\";\nimport { rotate } from \"tonal-array\";\nimport { harmonics, harmonize } from \"tonal-harmonizer\";\n\n// Order matters: use an array\nvar MODES = [\n  \"ionian\",\n  \"dorian\",\n  \"phrygian\",\n  \"lydian\",\n  \"mixolydian\",\n  \"aeolian\",\n  \"locrian\",\n  \"major\",\n  \"minor\"\n];\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5, 0, 3];\nvar SCALES = [0, 1, 2, 3, 4, 5, 6, 0, 5].map(function(n) {\n  return harmonics(rotate(n, [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"]));\n});\n\n// PRIVATE\n// Given a tonic, mode pair, return the key string\nfunction toKey(t, m) {\n  return !t ? m : t + \" \" + m;\n}\n// Given the alterations, return the major key\nfunction majorKey(n) {\n  return toKey(trFifths(\"C\", n), \"major\");\n}\n// given the mode name, return the alterations\nfunction modeNum(mode) {\n  return FIFTHS[MODES.indexOf(mode)];\n}\n// given a string, return the valid mode it represents or null\nfunction validMode(m) {\n  m = m.trim().toLowerCase();\n  return MODES.indexOf(m) === -1 ? null : m;\n}\n\n/**\n * Return the key properties, an object with { tonic, mode }\n *\n * @param {String} name - the key name\n * @return {Key} the key properties object or null if not a valid key\n * @example\n * var key = require('tonal-key')\n * key.props('C3 dorian') // => { tonic: 'C', mode: 'dorian' }\n * key.props('dorian') // => { tonic: false, mode: 'dorian' }\n * key.props('Ab bebop') // => null\n * key.props('blah') // => null\n */\nexport function props(str) {\n  if (typeof str !== \"string\") return null;\n  var ndx = str.indexOf(\" \");\n  var key;\n  if (ndx === -1) {\n    var p = pc(str);\n    key = p\n      ? { tonic: p, mode: \"major\" }\n      : { tonic: false, mode: validMode(str) };\n  } else {\n    key = { tonic: pc(str.slice(0, ndx)), mode: validMode(str.slice(ndx + 1)) };\n  }\n  return key.mode ? key : null;\n}\n\n/**\n * Test if a given name is a valid key name\n *\n * @param {String} name\n * @param {Boolean}\n * @example\n * key.isKeyName('C major') // => true\n * key.isKeyName('major') // => true\n * key.isKeyName('Bb bebop') // => false\n */\nexport function isKeyName(name) {\n  return props(name) !== null;\n}\n\n/**\n * Get the tonic of a key\n *\n * @param {String} key - the key\n * @return {String} the tonic or false is no tonic, or null if its not a valid key\n * @example\n * key.tonic('c3 major') // => 'C'\n * key.tonic('minor') // => false\n * key.tonic('bebop') // null\n */\nexport function tonic(key) {\n  return (props(key) || key || {}).tonic || null;\n}\n\n/**\n * Get the mode of a key. It can be used to test if its a valid key mode.\n *\n * @param {String}\n * @return {Boolean}\n * @example\n * key.mode('A dorian') // => 'dorian'\n * key.mode('DORIAN') // => 'dorian'\n * key.mode('mixophrygian') // => null\n */\nexport function mode(key) {\n  return (props(key) || key || {}).mode || null;\n}\n\n/**\n * Get relative of a key. Two keys are relative when the have the same\n * key signature (for example C major and A minor)\n *\n * It can be partially applied.\n *\n * @param {String} mode - the relative destination\n * @param {String} key - the key source\n * @example\n * key.relative('dorian', 'B major') // => 'C# dorian'\n * // partial application\n * var minor = key.relative('minor')\n * minor('C major') // => 'A minor'\n * minor('E major') // => 'C# minor'\n */\nexport function relative(rel, key) {\n  if (arguments.length === 1)\n    return function(k) {\n      return relative(rel, k);\n    };\n  rel = props(rel);\n  if (!rel || rel.tonic) return null;\n  key = props(key);\n  if (!key || !key.tonic) return null;\n  var tonic = trFifths(key.tonic, modeNum(rel.mode) - modeNum(key.mode));\n  return toKey(tonic, rel.mode);\n}\n\n/**\n * Get a list of the altered notes of a given key. The notes will be in\n * the same order than in the key signature.\n * @param {String|Nunber} key\n * @return {Array}\n * @example\n * var key = require('tonal-keys')\n * key.alteredNotes('Eb major') // => [ 'Bb', 'Eb', 'Ab' ]\n */\nexport function alteredNotes(key) {\n  var alt = alteration(key);\n  return alt === null\n    ? null\n    : alt < 0\n      ? numeric([-1, alt]).map(trFifths(\"F\"))\n      : numeric([1, alt]).map(trFifths(\"B\"));\n}\n\n/**\n * Get a list of valid mode names. The list of modes will be always in\n * increasing order (ionian to locrian)\n *\n * @param {Boolean} alias - true to get aliases names\n * @return {Array} an array of strings\n * @example\n * key.modes() // => [ 'ionian', 'dorian', 'phrygian', 'lydian',\n * // 'mixolydian', 'aeolian', 'locrian' ]\n * key.modes(true) // => [ 'ionian', 'dorian', 'phrygian', 'lydian',\n * // 'mixolydian', 'aeolian', 'locrian', 'major', 'minor' ]\n */\nexport function modes(alias) {\n  return alias ? MODES.slice() : MODES.slice(0, -2);\n}\n\n/**\n * Create a major key from alterations\n * @function\n * @param {Integer} alt - the alteration number (positive sharps, negative flats)\n * @return {Key} the key object\n * @example\n * var key = require('tonal-key')\n * key.fromAlter(2) // => 'D major'\n */\nexport function fromAlter(n) {\n  return typeof n === \"number\" ? majorKey(n) : null;\n}\n\n/**\n * Get key name from accidentals\n *\n * @param {String} acc - the accidentals string\n * @return {Key} the key object\n * @example\n * var key = require('tonal-key')\n * key.fromAcc('b') // => 'F major'\n * key.fromAcc('##') // => 'D major'\n */\nexport function fromAcc(s) {\n  return areSharps(s)\n    ? majorKey(s.length)\n    : areFlats(s) ? majorKey(-s.length) : null;\n}\n\n/**\n * Get scale of a key\n *\n * @param {String|Object} key\n * @return {Array} the key scale\n * @example\n * key.scale('A major') // => [ 'A', 'B', 'C#', 'D', 'E', 'F#', 'G#' ]\n * key.scale('Bb minor') // => [ 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab' ]\n * key.scale('C dorian') // => [ 'C', 'D', 'Eb', 'F', 'G', 'A', 'Bb' ]\n * key.scale('E mixolydian') // => [ 'E', 'F#', 'G#', 'A', 'B', 'C#', 'D' ]\n */\nexport function scale(key) {\n  var p = props(key);\n  if (!p || !p.tonic) return null;\n  return harmonize(SCALES[MODES.indexOf(p.mode)], p.tonic);\n}\n\n/**\n * Get key alteration. The alteration is a number indicating the number of\n * sharpen notes (positive) or flaten notes (negative)\n * @param {String|Integer} key\n * @return {Integer}\n * @example\n * var key = require('tonal-keys')\n * key.alteration('A major') // => 3\n */\nexport function alteration(key) {\n  var k = props(key);\n  if (!k || !k.tonic) return null;\n  var toMajor = modeNum(k.mode);\n  var toC = pcFifths(k.tonic);\n  return toC - toMajor;\n}\n\n/**\n * Get the signature of a key. The signature is a string with sharps or flats.\n * @example\n * var key = require('tonal-keys')\n * key.signature('A major') // => '###'\n */\nexport function signature(key) {\n  return toAcc(alteration(key));\n}\n\n/**\n * An alias for `signature()`\n * @function\n */\nexport var accidentals = signature;\n","/**\n * This module tonal dictionaries: functions that, given a name, returns an\n * array of intervals.\n *\n * @module dictionary\n */\nimport { map, compact, sort } from \"tonal-array\";\nimport { pc } from \"tonal-note\";\nimport { chroma, modes } from \"tonal-pcset\";\nimport scalesData from \"./data/scales.json\";\nimport chordsData from \"./data/chords.json\";\n\n/**\n * Create a tonal dictionary from data object\n * \n * The data object must have this form:\n * `{ key: [intervals, [aliases]] }`\n * \n * @param {Object} source \n * @param {Function} parse \n * @example\n * const dictionary = require('tonal-dictionary')\n * var DATA = {\n *   'maj7': ['1 3 5 7', ['Maj7']],\n *   'm7':   ['1 b3 5 7']\n * }\n * var chords = dictionary.build(DATA);\n * chords('maj7') // => [ '1', '3', '5', '7' ]\n * chords('Maj7') // => [ '1', '3', '5', '7' ]\n * chords('m7') // => ['1', 'b3', '5', '7']\n * chords('m7b5') // => null\n * chords.keys() // => ['maj7', 'm7']\n * chords.keys(true) // => ['maj7', 'm7', 'Maj7']\n */\nexport function build(source, parse = x => x.split(\" \")) {\n  const keys = Object.keys(source).sort();\n  const data = {};\n  keys.forEach(k => {\n    data[k] = parse(source[k][0]);\n    (source[k][1] || []).forEach(alias => (data[alias] = data[k]));\n  });\n  const allKeys = Object.keys(data).sort();\n  const dictionary = name => data[name];\n  dictionary.keys = aliases => (aliases ? allKeys : keys).slice();\n  return dictionary;\n}\n\nexport const scale = build(scalesData);\nexport const chord = build(chordsData);\n\n/**\n * A dictionary with all known pitchsets (includes chords and scales)\n * \n * @param {String} name \n */\nexport const pitchset = name => scale(name) || chord(name);\npitchset.keys = alias => scale.keys(alias).concat(chord.keys(alias));\n\nexport const index = (dictionary, genKey = chroma) => {\n  const names = dictionary.keys(true);\n  const data = {};\n  names.forEach(name => {\n    const key = genKey(dictionary(name));\n    data[key] = data[key] || [];\n    data[key].push(name);\n  });\n  const index = name => data[name] || [];\n  index.keys = () => Object.keys(data);\n  return index;\n};\n\n/**\n * Create a tonal dictionary. A dictionary is an object with two functions: get and\n * keys.\n *\n * The data given to this constructor it's a HashMap in the form:\n * `{ key: [intervals, [aliases]] }`\n *\n * @param {HashMap} data - the dictionary data\n * @return {Object} the dictionary object\n *\n * @example\n * var dictionary = require('tonal-dictionary').dictionary\n * var DATA = {\n * 'maj7': ['1 3 5 7', ['Maj7']],\n *   'm7': ['1 b3 5 7']\n * }\n * var chords = dictionary(DATA, function (str) { return str.split(' ') })\n * chords.get('maj7') // => [ '1', '3', '5', '7' ]\n * chords.get('Maj7') // => [ '1', '3', '5', '7' ]\n * chords.get('m7') // => ['1', 'b3', '5', '7']\n * chords.get('m7b5') // => null\n * chords.keys() // => ['maj7', 'm7']\n * chords.keys(true) // => ['maj7', 'm7', 'Maj7']\n */\nexport function dictionary(raw, parse) {\n  console.warn(\"@deprecated: use dictionary.build\");\n  parse = parse || (x => x);\n  var byKey = {};\n  var names = Object.keys(raw);\n  var aliases = [];\n  names.forEach(function(k) {\n    var value = parse(raw[k][0]);\n    byKey[k] = value;\n    if (raw[k][1]) {\n      raw[k][1].forEach(function(alias) {\n        byKey[alias] = value;\n        aliases.push(alias);\n      });\n    }\n  });\n  return {\n    /**\n     * Get a value by key\n     * @name get\n     * @function\n     * @param {String} key\n     * @return {Object} the value (normally an array of intervals or notes)\n     * @memberof dictionary\n     */\n    get: function(n) {\n      return byKey[n];\n    },\n    /**\n     * Get the valid keys of dictionary\n     * @name keys\n     * @function\n     * @param {Boolean} aliases - (Optional) include aliases names (false by default)\n     * @param {Function} filter - a function to filter the names. It receives the\n     * name and the value as parameters\n     * @return {Array<String>} the keys\n     * @memberof dictionary\n     */\n    keys: function(all, filter) {\n      var keys = all ? names.concat(aliases) : names.slice();\n      return typeof filter !== \"function\"\n        ? keys\n        : keys.filter(function(k) {\n            return filter(k, byKey[k]);\n          });\n    }\n  };\n}\n\n/**\n * Create a pitch set detector. Given a dictionary data, it returns a\n * function that tries to detect a given pitch set inside the dictionary\n *\n * @param {Dictionary} dictionary - the dictionary object\n * @param {Function|String} builder - (Optional) a function that given a name and a tonic,\n * returns the object or a string to join both\n * @return {Function} the detector function\n * @see chord.detect\n * @see scale.detect\n * @example\n * var detect = detector(dictionary(DATA), '')\n * detect('c d e b') // => 'Cmaj/'\n */\nexport function detector(dict, build) {\n  var isSep = typeof build === \"string\";\n  var isFn = typeof build === \"function\";\n  var nameByChroma = dict.keys(false).reduce(function(map, key) {\n    map[chroma(dict.get(key))] = key;\n    return map;\n  }, {});\n\n  return function(notes) {\n    notes = sort(map(pc, notes));\n    var sets = modes(notes);\n    return compact(\n      sets.map(function(set, i) {\n        var type = nameByChroma[set];\n        if (!type) return null;\n        var tonic = notes[i];\n        return isSep\n          ? tonic + build + type\n          : isFn ? build(type, tonic) : [type, tonic];\n      })\n    );\n  };\n}\n","/**\n * A scale is a collection of pitches in ascending or descending order.\n *\n * This module provides functions to get and manipulate scales.\n *\n * @example\n * scale.notes('Ab bebop') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'G' ]\n * scale.get('hungarian major', 'B3') // => [ 'B3', 'C##4', 'D#4', 'E#4', 'F#4', 'G#4', 'A4'\n * scale.get('C E F G', 'F') // => [ 'F', 'A', 'Bb', 'C' ]\n * scale.get('1P 2M 3M 5P 6M', 'D4') // => [ 'D4', 'E4', 'F#4', 'A4', 'B4' ]\n * scale.names() => ['major', 'minor', ...]\n * scale.detect('f5 d2 c5 b5 a2 e4 g') // => [ 'C major', 'D dorian', 'E phrygian', 'F lydian', 'G mixolydian', 'A aeolian', 'B locrian'])\n * @module scale\n */\nimport { scale, dictionary, detector } from \"tonal-dictionary/index\";\nimport { map, compact } from \"tonal-array\";\nimport { pc, name as note } from \"tonal-note\";\nimport { transpose } from \"tonal-distance/index\";\nimport { harmonize } from \"tonal-harmonizer\";\nimport DATA from \"./scales.json\";\n\nconst dict = dictionary(DATA, function(str) {\n  return str.split(\" \");\n});\n\n/**\n * Transpose the given scale notes, intervals or name to a given tonic.\n * The returned scale is an array of notes (or intervals if you specify `false` as tonic)\n *\n * It returns null if the scale type is not in the scale dictionary\n *\n * This function is currified\n *\n * @param {String} source - the scale type, intervals or notes\n * @param {String} tonic - the scale tonic (or false to get intervals)\n * @return {Array} the scale notes\n *\n * @example\n * scale.get('bebop', 'Eb') // => [ 'Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'Db', 'D' ]\n * scale.get('major', false) // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]\n * const major = scale.get('major')\n * major('Db3') // => [ 'Db3', 'Eb3', 'F3', 'Gb3', 'Ab3', 'Bb3', 'C4' ]\n */\nexport function get(type, tonic) {\n  console.warn(\"@deprecated: use scale.intervals or scale.notes\");\n  if (arguments.length === 1)\n    return function(t) {\n      return get(type, t);\n    };\n  const ivls = dict.get(type);\n  return ivls ? harmonize(ivls, tonic) : null;\n}\n\n/**\n * Return the available scale names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the scale names\n *\n * @example\n * const scale = require('tonal-scale')\n * scale.names() // => ['maj7', ...]\n */\nexport const names = scale.keys;\n\n/**\n * Get the notes (pitch classes) of a scale. It accepts either a scale name\n * (tonic and type) or a collection of notes.\n *\n * Note that it always returns an array, and the values are only pitch classes.\n *\n * @param {String|Array} src - the scale name (it must include the scale type and\n * a tonic. The tonic can be a note or a pitch class) or the list of notes\n * @return {Array} the scale pitch classes\n *\n * @example\n * scale.notes('C major') // => [ 'C', 'D', 'E', 'F', 'G', 'A', 'B' ]\n * scale.notes('C4 major') // => [ 'C', 'D', 'E', 'F', 'G', 'A', 'B' ]\n * scale.notes('Ab bebop') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'G' ]\n * scale.notes('C4 D6 E2 c7 a2 b5 g2 g4 f') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n */\nexport function notes(name) {\n  const parsed = parseName(name);\n  if (parsed.tonic) console.log(parsed.tonic, pc(parsed.tonic));\n  if (parsed.tonic) {\n    const ivls = scale(parsed.type);\n    return ivls ? ivls.map(transpose(pc(parsed.tonic))) : [];\n  }\n  const notes = scale.tonic ? get(scale.type, pc(scale.tonic)) : null;\n  return (\n    notes ||\n    compact(\n      map(pc, name).map(function(n, i, arr) {\n        // check for duplicates\n        // TODO: sort but preserving the root\n        return arr.indexOf(n) < i ? null : n;\n      })\n    )\n  );\n}\n\n/**\n * Given a scale name, return its intervals. The name can be the type and\n * optionally the tonic (which is ignored)\n *\n * It retruns an empty array when no scale found\n *\n * @param {String} name - the scale name (tonic and type, tonic is optional)\n * @return {Array<String>} the scale intervals if is a known scale or an empty\n * array if no scale found\n * @example\n * scale.intervals('C major')\n */\nexport function intervals(name) {\n  const parsed = parseName(name);\n  return scale(parsed.type) || [];\n}\n\n/**\n * Check if the given name (and optional tonic and type) is a know scale\n * @param {String} name - the scale name\n * @return {Boolean}\n * @example\n * scale.intervals('C major') // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ])\n * scale.intervals('major') // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ])\n * scale.intervals('mixophrygian') // => null\n */\nexport function exists(name) {\n  return scale(name) !== undefined;\n}\n\nexport function isKnowScale(name) {\n  console.warn(\"@renamed: use scale.exists\");\n  return exists(name);\n}\n\n/**\n * Given a string try to parse as scale name. It retuns an object with the\n * form { tonic, type } where tonic is the note or false if no tonic specified\n * and type is the rest of the string minus the tonic\n *\n * Note that this function doesn't check that the scale type is a valid scale\n * type or if is present in any scale dictionary.\n *\n * @param {String} name - the scale name\n * @return {Object} an object { tonic, type }\n * @example\n * scale.parseName('C mixoblydean') // => { tonic: 'C', type: 'mixoblydean' }\n * scale.parseName('anything is valid') // => { tonic: false, type: 'anything is valid'}\n */\nexport function parseName(str) {\n  if (typeof str !== \"string\") return null;\n  const i = str.indexOf(\" \");\n  const tonic = note(str.substring(0, i)) || false;\n  const type = tonic ? str.substring(i + 1) : str;\n  return { tonic: tonic, type: type };\n}\n\n/**\n * Detect a scale. Given a list of notes, return the scale name(s) if any.\n * It only detects chords with exactly same notes.\n *\n * @function\n * @param {Array|String} notes - the list of notes\n * @return {Array<String>} an array with the possible scales\n * @example\n * scale.detect('b g f# d') // => [ 'GMaj7' ]\n * scale.detect('e c a g') // => [ 'CM6', 'Am7' ]\n */\nexport const detect = detector(dict, \" \");\n","'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n","/**\n * A chord is a harmonic unit with at least three different tones sounding simultaneously.\n *\n * This module have functions to create and manipulate chords. It includes a\n * chord dictionary and a simple chord detection algorithm.\n *\n * @example\n * var chord = require('tonal-chord')\n * chord.detect('c b g e') // => 'CMaj7'\n * chord.get('CMaj7') // => ['C', 'E', 'G', 'B']\n *\n * @module chord\n */\nimport { dictionary, detector } from \"tonal-dictionary/index\";\nimport { map, compact, permutations, rotate } from \"tonal-array/index\";\nimport { pc, name as note } from \"tonal-note\";\nimport { regex } from \"note-parser\";\nimport { harmonize, intervallic } from \"tonal-harmonizer\";\nimport DATA from \"./chords.json\";\n\nvar dict = dictionary(DATA, function(str) {\n  return str.split(\" \");\n});\n\n/**\n * Return the available chord names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the chord names\n *\n * @example\n * var chord = require('tonal-chord')\n * chord.names() // => ['maj7', ...]\n */\nexport var names = dict.keys;\n\n/**\n * Get chord notes or intervals from chord type\n *\n * This function is currified\n *\n * @param {String} type - the chord type\n * @param {Strng|Pitch} tonic - the tonic or false to get the intervals\n * @return {Array<String>} the chord notes or intervals, or null if not valid type\n *\n * @example\n * chords.get('dom7', 'C') // => ['C', 'E', 'G', 'Bb']\n * maj7 = chords.get('Maj7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n */\nexport function get(type, tonic) {\n  if (arguments.length === 1)\n    return function(t) {\n      return get(type, t);\n    };\n  var ivls = dict.get(type);\n  return ivls ? harmonize(ivls, tonic) : null;\n}\n\n/**\n * Get the chord notes of a chord. This function accepts either a chord name\n * (for example: 'Cmaj7') or a list of notes.\n *\n * It always returns an array, even if the chord is not found.\n *\n * @param {String|Array} chord - the chord to get the notes from\n * @return {Array<String>} a list of notes or empty list if not chord found\n *\n * @example\n * chord.notes('Cmaj7') // => ['C', 'E', 'G', 'B']\n */\nexport function notes(chord) {\n  var p = parse(chord);\n  var ivls = dict.get(p.type);\n  return ivls ? harmonize(ivls, p.tonic) : compact(map(note, chord));\n}\n\n/**\n * Get chord intervals. It always returns an array\n *\n * @param {String} name - the chord name (optionally a tonic and type)\n * @return {Array<String>} a list of intervals or null if the type is not known\n */\nexport function intervals(name) {\n  var p = parse(name);\n  return dict.get(p.type) || [];\n}\n\n/**\n * Check if a given name correspond to a chord in the dictionary\n * @param {String} name\n * @return {Boolean}\n * @example\n * chord.isKnownChord('CMaj7') // => true\n * chord.isKnownChord('Maj7') // => true\n * chord.isKnownChord('Ablah') // => false\n */\nexport function isKnownChord(name) {\n  return intervals(name).length > 0;\n}\n\n/**\n * Detect a chord. Given a list of notes, return the chord name(s) if any.\n * It only detects chords with exactly same notes.\n *\n * @function\n * @param {Array|String} notes - the list of notes\n * @return {Array<String>} an array with the possible chords\n * @example\n * chord.detect('b g f# d') // => [ 'GMaj7' ]\n * chord.detect('e c a g') // => [ 'CM6', 'Am7' ]\n */\nexport var detect = detector(dict, \"\");\n\n/**\n * Get the position (inversion number) of a chord (0 is root position, 1 is first\n * inversion...). It assumes the chord is formed by superposed thirds.\n *\n * @param {Array|String} chord - the chord notes\n * @return {Integer} the inversion number (0 for root inversion, 1 for first\n * inversion...) or null if not a valid chord\n *\n * @example\n * chord.position('e g c') // => 1\n * chord.position('g3 e2 c5') // => 1 (e is the lowest note)\n */\nexport function position(chord) {\n  var pcs = map(pc, chord);\n  var sorted = sortTriads(pcs);\n  return sorted ? sorted.indexOf(pcs[0]) : null;\n}\n\n/**\n * Given a chord in any inverstion, set to the given inversion. It accepts\n * chord names\n *\n * @param {Integer} num - the inversion number (0 root position, 1 first\n * inversion, ...)\n * @param {String|Array} chord - the chord name or notes\n * @return {Array} the chord pitch classes in the desired inversion or\n * an empty array if no inversion found (not triadic)\n *\n * @example\n * chord.inversion(1, 'Cmaj7') // => [ 'E', 'G', 'B', 'C' ]\n * chord.inversion(0, 'e g c') // => [ 'C', 'E', 'G' ]\n */\nexport function inversion(num, chord) {\n  if (arguments.length === 1)\n    return function(c) {\n      return inversion(num, c);\n    };\n  var sorted = sortTriads(chord);\n  return sorted ? rotate(num, sorted) : [];\n}\n\nfunction sortTriads(chord) {\n  var all = permutations(notes(chord).map(pc));\n  for (var i = 0; i < all.length; i++) {\n    var ivls = intervallic(all[i]);\n    if (areTriads(ivls)) return all[i];\n  }\n  return null;\n}\n\nfunction areTriads(list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i][0] !== \"3\") return false;\n  }\n  return true;\n}\n\n/**\n * Try to parse a chord name. It returns an array with the chord type and\n * the tonic. If not tonic is found, all the name is considered the chord\n * name.\n *\n * This function does NOT check if the chord type exists or not. It only tries\n * to split the tonic and chord type.\n *\n * @param {String} name - the chord name\n * @return {Array} an array with [type, tonic]\n * @example\n * chord.parse('Cmaj7') // => { tonic: 'C', type: 'maj7' }\n * chord.parse('C7') // => { tonic: 'C', type: '7' }\n * chord.parse('mMaj7') // => { tonic: false, type: 'mMaj7' }\n * chord.parse('Cnonsense') // => { tonic: 'C', type: 'nonsense' }\n */\nexport function parse(name) {\n  var p = regex().exec(name);\n  if (!p) return { type: name, tonic: false };\n\n  // If chord name is empty, the octave is the chord name\n  return !p[4]\n    ? { type: p[3], tonic: p[1] + p[2] }\n    : // If the octave is 6 or 7 is asumed to be part of the chord name\n      p[3] === \"7\" || p[3] === \"6\"\n      ? { type: p[3] + p[4], tonic: p[1] + p[2] }\n      : { type: p[4], tonic: p[1] + p[2] + p[3] };\n}\n","/**\n * # `tonal-progressions`\n * > Describe and manipulate chord progressions.\n *\n * @example\n * var progression = require('tonal-progression')\n * progression.abstract('Cmaj7 Dm7 G7', 'C')\n *\n * @module progression\n */\nimport { pc } from \"tonal-note\";\nimport { props, fromProps } from \"tonal-interval\";\nimport { map, compact } from \"tonal-array\";\nimport { transpose } from \"tonal-transpose\";\nimport { interval } from \"tonal-distance\";\nimport { parse } from \"tonal-chord\";\nimport { toAcc } from \"tonal-notation\";\n\n/**\n * Given a chord progression and a tonic, return the chord progression\n * with roman numeral chords.\n *\n * @param {Array|String} chords - the chord progression\n * @param {String} tonic - the tonic\n * @return {Array} the chord progression in roman numerals\n * @example\n * progression.abstract('Cmaj7 Dm7 G7', 'C') // => [ 'Imaj7', 'IIm7', 'V7' ]\n */\nexport function abstract(chords, tonic) {\n  tonic = pc(tonic);\n  chords = map(parse, chords);\n  var tonics = compact(\n    chords.map(function(x) {\n      return x.tonic;\n    })\n  );\n  // if some tonic missing, can't do the analysis\n  if (tonics.length !== chords.length) return null;\n\n  return tonics.map(function(t, i) {\n    var p = props(interval(tonic, t));\n    return buildRoman(p.num - 1, p.alt, chords[i].type);\n  });\n}\n\nvar NUMS = [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\"];\n/**\n * Build an abstract chord name using roman numerals\n */\nexport function buildRoman(num, alt, element) {\n  return toAcc(alt) + NUMS[num % 7] + (element || \"\");\n}\n\n/**\n * Get chord progression from a tonic and a list of chord in roman numerals\n *\n * @param {String} tonic - the tonic\n * @param {Array|String} progression - the progression in roman numerals\n * @return {Array} the chord progression\n *\n * @example\n * var progression = require('chord-progression')\n * progression.concrete('I IIm7 V7', 'C') // => ['C', 'Dm7', 'G7']\n */\nexport function concrete(chords, tonic) {\n  return map(function(e) {\n    var r = parseRomanChord(e);\n    return r ? transpose(r.root, tonic) + r.type : null;\n  }, chords);\n}\n\nvar ROMAN = /^\\s*(b|bb|#|##|)(IV|III|II|I|VII|VI|V|iv|iii|ii|i|vii|vi|v)\\s*(.*)\\s*$/;\n/**\n * Returns a regex to match roman numbers literals with the from:\n * `[accidentals]roman[element]`.\n *\n * The executed regex contains:\n *\n * - input: the input string\n * - accidentals: (Optional) one or two flats (b) or shaprs (#)\n * - roman: (Required) a roman numeral from I to VII either in upper or lower case\n * - element: (Optional) a name of an element\n *\n * @return {RegExp} the regexp\n *\n * @example\n * var r = progression.romanRegex()\n * r.exec('bVImaj7') // => ['bVImaj7', 'b', 'VI', 'maj7'])\n * r.exec('III dom') // => ['III dom', '', 'III', 'dom'])\n */\nexport function romanRegex() {\n  return ROMAN;\n}\n\nvar NUM = { i: 0, ii: 1, iii: 2, iv: 3, v: 4, vi: 5, vii: 6 };\n\n/**\n * Parse a chord expressed with roman numerals. It returns an interval representing\n * the root of the chord relative to the key tonic and the chord name.\n *\n * @param {String} str - the roman numeral string\n * @return {Object} the roman chord property object with:\n *\n * - type: the chord type\n * - root: the interval from the key to the root of this chord\n *\n * @example\n * var parse = require('music-notation/roman.parse')\n * parse('V7') // => { root: '5P', type: '7' }\n * parse('bIIalt') // => { root: '2m', type: 'alt' }\n */\nexport function parseRomanChord(str) {\n  var m = ROMAN.exec(str);\n  if (!m) return null;\n  var num = NUM[m[2].toLowerCase()] + 1;\n  var alt = m[1].length;\n  if (m[1][0] === \"b\") alt = -alt;\n  return { root: fromProps({ num: num, alt: alt, dir: 1 }), type: m[3] };\n}\n","/**\n *\n * @module sonority\n */\nimport { ic } from \"tonal-interval\";\nimport { asNotePitch, chr } from \"tonal-pitch\";\nimport { map, compact } from \"tonal-array\";\n\n/**\n * Get the intervals analysis of a collection of notes\n *\n * Returns an array with the format `[p, m, n, s, d, t]` where:\n *\n * - p: the number of perfect fourths or fifths\n * - m: the number of major thirds or minor sixths\n * - n: the number of major sixths or minor thirds\n * - s: the number of major seconds or minor sevenths\n * - d: the number of major sevents or minor seconds\n * - t: the number of tritones\n *\n * This is, mostly, an academic puzzle to show the expresiveness of tonal.\n * Implements the ideas found in \"The Analysis of Intervals\" chapter from\n * [Harmonic Materials of Modern Music]():\n *\n * > The letters _pmn_, therefore, represent intervals commonly considered\n * consonant, whereas the letters _sdt_ represent the intervals commonly\n * considered dissonant. (...) A sonority represented, for example, by the\n * symbol `sd^2`, indicating a triad composed of one major second and two minor\n * seconds, would be recognized as a highly dissonant sound, while the symbol\n * `pmn` would indicate a consonant sound.\n *\n * @param {Array|String} notes - the notes to analyze\n * @return {Array} the _pmnsdt_ array\n */\nexport function density(list) {\n  var a, b, i;\n  var notes = compact(map(asNotePitch, list));\n  var len = notes.length;\n  var result = [0, 0, 0, 0, 0, 0];\n  for (a = 0; a < len; a++) {\n    for (b = a; b < len; b++) {\n      i = ic(chr(notes[b]) - chr(notes[a]));\n      if (i === 6) result[5] = result[5] + 1;\n      else if (i > 0) result[5 - i] = result[5 - i] + 1;\n    }\n  }\n  return result;\n}\n","/**\n * Functions to create and manipulate pitch sets\n *\n * @example\n * var pitchset = require('tonal-pitchset')\n *\n * @module pitchset\n */\nimport { sort } from \"tonal-array\";\n\n/**\n * Get the notes of a pitch set. The notes in the set are sorted in asceding\n * pitch order, and no repetitions are allowed.\n *\n * Note that it creates pitch sets and NOT picth class sets. This functionallity\n * resides inside `tonal-pcset` module.\n *\n * @param {String|Array} notes - the notes to create the pitch set from\n * @return {Array<String>} the ordered pitch set notes\n * @example\n * pitchset.notes('C4 c3 C5 c4') // => ['C3', 'C4', 'C5']\n */\nexport function notes(notes) {\n  return sort(notes).filter(function(n, i, arr) {\n    return i === 0 || n !== arr[i - 1];\n  });\n}\n","/**\n * The `tonal` module is a facade to all the rest of the modules. They are namespaced,\n * so for example to use `pc` function from `tonal-note` you have to write:\n * `tonal.note.pc`\n *\n * Some modules are NOT namespaced for developer comfort:\n *\n * - `tonal-array`: for example `tonal.map(tonal.note.pc, 'C#2')`\n * - `tonal-transpose`: for example `tonal.transpose('C', '3M')`\n * - `tonal-distance`: for example `tonal.interval('C3', 'G4')`\n *\n * It also adds a couple of function aliases:\n *\n * - `tonal.scale` is an alias for `tonal.scale.notes`\n * - `tonal.chord` is an alias for `tonal.chord.notes`\n *\n * @example\n * var tonal = require('tonal')\n * tonal.transpose(tonal.note.pc('C#2'), 'M3') // => 'E#'\n * tonal.chord('Dmaj7') // => ['D', 'F#', 'A', 'C#']\n *\n * @module tonal\n */\nimport * as array from \"tonal-array\";\nimport * as transpose from \"tonal-transpose\";\nimport * as harmonizer from \"tonal-harmonizer\";\nimport * as distance from \"tonal-distance\";\nimport * as note from \"tonal-note\";\nimport * as interval from \"tonal-interval\";\nimport * as midi from \"tonal-midi\";\nimport * as freq from \"tonal-freq\";\nimport * as range from \"tonal-range\";\nimport * as key from \"tonal-key\";\nimport * as scale from \"tonal-scale\";\nimport * as chord from \"tonal-chord\";\nimport * as pitch from \"tonal-pitch\";\nimport * as notation from \"tonal-notation\";\nimport * as progression from \"tonal-progression\";\nimport * as sonority from \"tonal-sonority\";\nimport * as pitchset from \"tonal-pitchset\";\nimport * as pcset from \"tonal-pcset\";\n\nvar assign = Object.assign;\nvar tonal = assign({}, array, transpose, harmonizer, distance);\ntonal.pitch = pitch;\ntonal.notation = notation;\ntonal.note = note;\ntonal.ivl = interval;\ntonal.midi = midi;\ntonal.freq = freq;\ntonal.range = range;\ntonal.key = key;\ntonal.progression = progression;\ntonal.sonority = sonority;\ntonal.pitchset = pitchset;\ntonal.pcset = pcset;\n\ntonal.scale = function(name) {\n  return tonal.scale.notes(name);\n};\nassign(tonal.scale, scale);\ntonal.chord = function(name) {\n  return tonal.chord.notes(name);\n};\nassign(tonal.chord, chord);\n\nif (typeof window !== \"undefined\") window.Tonal = tonal;\nexport default tonal;\n"],"names":["fillStr","s","num","Array","join","isNum","x","midiToFreq","midi","tuning","Math","pow","parse","str","isTonic","m","REGEX","exec","p","letter","toUpperCase","acc","replace","pc","step","charCodeAt","alt","length","pos","SEMITONES","chroma","oct","freq","tonicOf","accStr","n","octStr","build","a","o","LETTERS","charAt","strict","IVL_REGEX","i","q","dir","simple","type","TYPES","qToAlt","floor","size","SIZES","t","test","abs","altToQ","fOcts","f","encode","FIFTHS","FIFTH_OCTS","unaltered","decode","STEPS","pitch","fifths","focts","isPitch","isArray","enc","dec","apply","pType","isNotePitch","isIvlPitch","isPC","height","chr","memoize","fn","cache","parsePitch","parseNote","parseIvl","asNotePitch","asIvlPitch","asPitch","strNote","noteStr","strIvl","d","strPitch","decorator","is","v","trBy","transpose","b","arguments","pa","pb","r","trFifths","note","interval","transposeBy","add","ivl1","ivl2","i2","p1","p2","substr","from","to","subtract","semitones","hasVal","e","map","list","l","asArr","compact","arr","filter","objHeight","Infinity","ascComp","descComp","sort","comp","slice","listFn","trOct","tr","rotate","times","len","concat","rotateAsc","head","tail","octs","select","nums","permutations","reduce","perm","newPerm","splice","asPitchStr","listToStr","isArr","harmonics","intervallic","notes","dist","push","harmonize","tonic","split","mod","name","undefined","fromMidi","sharps","round","SHARPS","FLATS","console","warn","pcFifths","dirStr","toInterval","ivl","props","value","fromProps","fromSemitones","c","IN","IQ","ic","isNaN","CLASSES","isStr","isDef","toMidi","val","eqTempFreq","ref","max","noteToMidi","eqTempFreqToMidi","log","useSharps","midiToNote","cents","base","toFreq","chrToInt","set","parseInt","pitchChr","isChroma","forEach","pcs","fromChroma","modes","normalize","binary","_","intervals","IVLS","isEqual","s1","s2","isSubset","isSuperset","includes","asNum","ascR","descR","ran","numeric","last","chromatic","range","pitchSet","toStep","indexOf","isStep","toLetter","areFlats","areSharps","toAlt","toAcc","toKey","majorKey","modeNum","mode","MODES","validMode","trim","toLowerCase","key","ndx","isKeyName","relative","rel","k","alteredNotes","alteration","alias","fromAlter","fromAcc","scale","SCALES","toMajor","signature","source","keys","Object","data","allKeys","dictionary","aliases","raw","byKey","names","get","all","detector","dict","isSep","isFn","nameByChroma","ivls","parsed","parseName","exists","isKnowScale","substring","regex","chord","isKnownChord","position","sorted","sortTriads","inversion","areTriads","abstract","chords","tonics","buildRoman","element","NUMS","concrete","parseRomanChord","root","romanRegex","ROMAN","NUM","density","result","RegExp","noteParse","ivlParse","noteFn","ivlFn","pitchFn","sep","shuffle","random","SEMI","inOct","numToStr","op","invert","simplify","accidentals","chordsData","detect","ii","iii","iv","vi","vii","assign","tonal","array","harmonizer","distance","notation","progression","sonority","pitchset","pcset","window","Tonal"],"mappings":"gLAGA,SAASA,GAASC,EAAGC,GAAO,MAAOC,OAAMD,EAAM,GAAGE,KAAKH,GACvD,QAASI,GAAOC,GAAK,MAAoB,gBAANA,GACnC,QAESC,GAAYC,EAAMC,GACzB,MAAOC,MAAKC,IAAI,GAAIH,EAAO,IAAM,KAAOC,GAAU,KAoFpD,QAAgBG,GAAOC,EAAKC,EAASL,GACnC,GAAmB,gBAARI,GAAkB,MAAO,KACpC,IAAIE,GAAIC,GAAMC,KAAKJ,EACnB,KAAKE,IAAOD,GAAWC,EAAE,GAAK,MAAO,KAErC,IAAIG,IAAMC,OAAQJ,EAAE,GAAGK,cAAeC,IAAKN,EAAE,GAAGO,QAAQ,KAAM,MAC9DJ,GAAEK,GAAKL,EAAEC,OAASD,EAAEG,IACpBH,EAAEM,MAAQN,EAAEC,OAAOM,WAAW,GAAK,GAAK,EACxCP,EAAEQ,IAAmB,MAAbR,EAAEG,IAAI,IAAcH,EAAEG,IAAIM,OAAST,EAAEG,IAAIM,MACjD,IAAIC,GAAMC,GAAUX,EAAEM,MAAQN,EAAEQ,GAQhC,OAPAR,GAAEY,OAASF,EAAM,EAAI,GAAKA,EAAMA,EAAM,GAClCb,EAAE,KACJG,EAAEa,KAAOhB,EAAE,GACXG,EAAEV,KAAOoB,EAAM,IAAMV,EAAEa,IAAM,GAC7Bb,EAAEc,KAAOzB,EAAWW,EAAEV,KAAMC,IAE1BK,IAASI,EAAEe,QAAUlB,EAAE,IACpBG,EAIT,QAASgB,GAAQC,GAAK,MAAQ9B,GAAM8B,GAAUA,EAAI,EAAInC,EAAQ,KAAMmC,GAAKnC,EAAQ,IAAKmC,GAA7C,GACzC,QAASC,GAAQD,GAAK,MAAQ9B,GAAM8B,GAAU,GAAKA,EAAV,GAgBzC,QAAgBE,GAAOpC,EAAGqC,EAAGC,GAC3B,MAAU,QAANtC,OAA2B,KAANA,EAA0B,KAC/CA,EAAEuB,KAAaa,EAAMpC,EAAEuB,KAAMvB,EAAEyB,IAAKzB,EAAE8B,KACtC9B,EAAI,GAAKA,EAAI,EAAU,KACpBuC,GAAQC,OAAOxC,GAAKiC,EAAOI,GAAKF,EAAOG,GCtGhD,QAAgB3B,GAAOC,EAAK6B,GAC1B,GAAmB,gBAAR7B,GAAkB,MAAO,KACpC,IAAIE,GAAI4B,GAAU1B,KAAKJ,EACvB,KAAKE,EAAG,MAAO,KACf,IAAI6B,IAAM1C,MAAOa,EAAE,IAAMA,EAAE,IAAK8B,EAAG9B,EAAE,IAAMA,EAAE,GAC7C6B,GAAEE,IAAyB,OAAlB/B,EAAE,IAAMA,EAAE,KAAe,EAAI,CACtC,IAAIS,IAAQoB,EAAE1C,IAAM,GAAK,CAMzB,OALA0C,GAAEG,OAASvB,EAAO,EAClBoB,EAAEI,KAAOC,GAAMzB,GACfoB,EAAElB,IAAMwB,EAAON,EAAEI,KAAMJ,EAAEC,GACzBD,EAAEb,IAAMrB,KAAKyC,OAAOP,EAAE1C,IAAM,GAAK,GACjC0C,EAAEQ,KAAOR,EAAEE,KAAOO,GAAM7B,GAAQoB,EAAElB,IAAM,GAAKkB,EAAEb,MAChC,IAAXW,GACa,MAAXE,EAAEI,MAAwB,MAARJ,EAAEC,EAAkB,KAErCD,EAUT,QAAgBI,GAAM9C,GACpB,MAAO+C,KAAO/C,EAAM,GAAK,GA8D3B,QAAgBgD,GAAQhD,EAAK2C,GAC3B,GAAIS,GAAmB,gBAARpD,GAAmB8C,EAAK9C,GAAOA,CAC9C,OAAU,MAAN2C,GAAmB,MAANS,EAAkB,EACzB,MAANT,GAAmB,MAANS,EAAkB,EACzB,MAANT,GAAmB,MAANS,GAAmB,EAChC,OAAOC,KAAKV,GAAWA,EAAElB,OACzB,OAAO4B,KAAKV,GAAiB,MAANS,GAAaT,EAAElB,QAAUkB,EAAElB,OAAS,EACxD,KAGT,QAAS3B,GAASC,EAAGkC,GAAK,MAAOhC,OAAMO,KAAK8C,IAAIrB,GAAK,GAAG/B,KAAKH,GAY7D,QAAgBwD,GAAQvD,EAAKwB,GAC3B,GAAI4B,GAAmB,gBAARpD,GAAmB8C,EAAKtC,KAAK8C,IAAItD,IAAQA,CACxD,OAAY,KAARwB,EAAwB,MAAN4B,EAAY,IAAM,KACtB,IAAT5B,GAAoB,MAAN4B,EAAkB,IAChC5B,EAAM,EAAU1B,EAAQ,IAAK0B,GAC7BA,EAAM,EAAU1B,EAAQ,IAAW,MAANsD,EAAY5B,EAAMA,EAAM,GAClD,KC5Id,QAASrB,GAAM8B,GACb,MAAoB,gBAANA,GAOhB,QAASuB,GAAMC,GACb,MAAOjD,MAAKyC,MAAU,EAAJQ,EAAQ,IAa5B,QAAgBC,GAAOpC,EAAME,EAAKK,GAChC,GAAI4B,GAAIE,GAAOrC,GAAQ,EAAIE,CAC3B,OAAKrB,GAAM0B,IAEH4B,EADA5B,EAAM+B,GAAWtC,GAAQ,EAAIE,IADZiC,GAM3B,QAASI,GAAUJ,GACjB,GAAIf,IAAKe,EAAI,GAAK,CAClB,OAAOf,GAAI,EAAI,EAAIA,EAAIA,EAezB,QAAgBoB,GAAOL,EAAGpB,GACxB,GAAIf,GAAOyC,GAAMF,EAAUJ,IACvBjC,EAAMhB,KAAKyC,OAAOQ,EAAI,GAAK,EAC/B,OAAKtD,GAAMkC,IAEHf,EAAME,EADJa,EAAI,EAAIb,EAAMoC,GAAWtC,KADZA,EAAME,GCrC/B,QAAgBwC,GAAMC,EAAQC,EAAOtB,GACnC,MAAOA,IAAO,QAASqB,EAAQC,GAAQtB,IAAQ,QAASqB,EAAQC,IAOlE,QAAgBC,GAAQnD,GACtB,MAAOf,OAAMmE,QAAQpD,IAAe,SAATA,EAAE,GAS/B,QAAgB0C,GAAO3D,EAAGqC,EAAGC,EAAGO,GAC9B,MAAOA,IAAO,OAAQyB,EAAItE,EAAGqC,EAAGC,GAAIO,IAAQ,OAAQyB,EAAItE,EAAGqC,EAAGC,IAQhE,QAAgByB,GAAO9C,GACrB,MAAOsD,GAAIC,MAAM,KAAMvD,EAAE,IAQ3B,QAAgBwD,GAAMxD,GACpB,MAAQmD,GAAQnD,GAAYA,EAAE,GAAK,MAAQ,OAAtB,KAOvB,QAAgByD,GAAYzD,GAC1B,MAAoB,SAAbwD,EAAMxD,GAOf,QAAgB0D,GAAW1D,GACzB,MAAoB,QAAbwD,EAAMxD,GAOf,QAAgB2D,GAAK3D,GACnB,MAAOmD,GAAQnD,IAAsB,IAAhBA,EAAE,GAAGS,OAQ5B,QAAgBmB,GAAI5B,GAClB,OAAiB,IAAVA,EAAE,IAAa,EAAI,EAQ5B,QAAgBiD,GAAOjD,GACrB,OAAiB,IAAVA,EAAE,IAAaA,EAAE,GAAG,GAAKA,EAAE,GAAG,GAOvC,QAAgBkD,GAAMlD,GACpB,OAAiB,IAAVA,EAAE,IAAaA,EAAE,GAAG,GAAKA,EAAE,GAAG,GAOvC,QAAgB4D,GAAO5D,GACrB,MAAmB,GAAZiD,EAAOjD,GAAoB,GAAXkD,EAAMlD,GAW/B,QAAgB6D,GAAI7D,GAClB,GAAIyC,GAAIQ,EAAOjD,EACf,OAAO,GAAIyC,EAAI,GAAKjD,KAAKyC,MAAU,EAAJQ,EAAQ,IAIzC,QAASqB,GAAQC,GACf,GAAIC,KACJ,OAAO,UAASrE,GACd,MAAmB,gBAARA,GAAyB,KAC7BqE,EAAMrE,KAASqE,EAAMrE,GAAOoE,EAAGpE,KAgC1C,QAAgBsE,GAAWlF,GACzB,MAAOmF,IAAUnF,IAAMoF,GAASpF,GASlC,QAAgBqF,GAAYpE,GAC1B,MAAOyD,GAAYzD,GAAKA,EAAIkE,GAAUlE,GAQxC,QAAgBqE,GAAWrE,GACzB,MAAO0D,GAAW1D,GAAKA,EAAImE,GAASnE,GAQtC,QAAgBsE,GAAQtE,GACtB,MAAOmD,GAAQnD,GAAKA,EAAIiE,EAAWjE,GAQrC,QAAgBuE,GAAQvE,GACtB,MAAKyD,GAAYzD,GACVwE,EAAQjB,MAAM,KAAMT,EAAO9C,IADN,KAS9B,QAAgByE,GAAOzE,GACrB,IAAK0D,EAAW1D,GAAI,MAAO,KAE3B,IAAI0E,GAAI5B,EAAO9C,GAEXhB,EAAM0F,EAAE,GAAK,EAAI,EAAIA,EAAE,EAC3B,OAAO1E,GAAE,GAAKhB,EAAMuD,EAAOvD,EAAK0F,EAAE,IAQpC,QAAgBC,GAAS3E,GACvB,MAAOuE,GAAQvE,IAAMyE,EAAOzE,GAM9B,QAAS4E,GAAUC,EAAInF,EAAOC,GAC5B,MAAO,UAASoE,GACd,MAAO,UAASe,GAGd,GAFQD,EAAGC,GAEJ,MAAOf,GAAGe,EAEjB,IAAI9E,GAAIN,EAAMoF,EAEd,OAAO9E,GAAIL,EAAIoE,EAAG/D,IAAM,OCzO9B,QAYS+E,GAAKrD,EAAG1B,GACf,GAAIoC,GAAIoB,EAAMxD,EACd,KAAKoC,EAAG,MAAO,KACf,IAAIK,GAAIQ,EAAOvB,GAAKuB,EAAOjD,EAC3B,IAAI2D,EAAK3D,GAAI,OAAQ,QAASyC,GAC9B,IAAIpB,GAAI6B,EAAMxB,GAAKwB,EAAMlD,EACzB,IAAU,SAANoC,EAAc,OAAQ,QAASK,EAAGpB,GACtC,IAAIqD,GAAId,EAAOlC,GAAKkC,EAAO5D,GAAK,GAAK,EAAI,CACzC,QAAQ,QAAS0E,EAAIjC,EAAGiC,EAAIrD,GAAIqD,GAuBlC,QAAgBM,GAAU5D,EAAG6D,GAC3B,GAAyB,IAArBC,UAAUzE,OACZ,MAAO,UAASwE,GACd,MAAOD,GAAU5D,EAAG6D,GAExB,IAAIE,GAAKb,EAAQlD,GACbgE,EAAKd,EAAQW,GACbI,EAAI3B,EAAWyB,GAAMJ,EAAKI,EAAIC,GAAM1B,EAAW0B,GAAML,EAAKK,EAAID,GAAM,IACxE,OAAO/D,KAAM+D,GAAMF,IAAMG,EAAKC,EAAIV,EAASU,GAgB7C,QAAgBC,GAASlD,EAAGnB,GAC1B,MAAIiE,WAAUzE,OAAS,EAAU6E,EAASlD,GAAGnB,GACtC,SAASA,GACd,MAAO+D,GAAU5C,EAAGY,EAAM/B,EAAG,EAAG,KC/DpC,QAYS8D,GAAKrD,EAAG1B,GACf,GAAIoC,GAAIoB,EAAMxD,EACd,KAAKoC,EAAG,MAAO,KACf,IAAIK,GAAIQ,EAAOvB,GAAKuB,EAAOjD,EAC3B,IAAI2D,EAAK3D,GAAI,OAAQ,QAASyC,GAC9B,IAAIpB,GAAI6B,EAAMxB,GAAKwB,EAAMlD,EACzB,IAAU,SAANoC,EAAc,OAAQ,QAASK,EAAGpB,GACtC,IAAIqD,GAAId,EAAOlC,GAAKkC,EAAO5D,GAAK,GAAK,EAAI,CACzC,QAAQ,QAAS0E,EAAIjC,EAAGiC,EAAIrD,GAAIqD,GAmBlC,QAAgBM,GAAUO,EAAMC,GAC9B,GAAyB,IAArBN,UAAUzE,OAAc,MAAOiB,IAAKsD,EAAUO,EAAM7D,EACxD,IAAIT,GAAIqD,EAAQiB,GACZ7D,EAAI4C,EAAQkB,EAChB,OAAOvE,IAAKS,EAAIiD,EAASI,EAAKrD,EAAGT,IAAM,KAezC,QAAgBwE,GAAYD,EAAUD,GACpC,MAAyB,KAArBL,UAAUzE,OAAqBQ,GAAKwE,EAAYD,EAAUvE,GACvD+D,EAAUO,EAAMC,GAezB,QAAgBE,GAAIC,EAAMC,GACxB,GAAyB,IAArBV,UAAUzE,OAAc,MAAOoF,IAAMJ,EAAYE,EAAME,EAC3D,IAAIC,GAAKxB,EAAQqB,GACbI,EAAKzB,EAAQsB,EACjB,OAAOE,IAAMC,EAAKpB,EAASI,EAAKe,EAAIC,IAAO,KAkB7C,QAAgBT,GAASlD,EAAGnB,GAC1B,MAAIiE,WAAUzE,OAAS,EAAU6E,EAASlD,GAAGnB,GACtC,SAASA,GACd,MAAO+D,GAAU5C,EAAGY,EAAM/B,EAAG,EAAG,KAKpC,QAAS+E,GAAO5E,EAAG6D,GACjB,IAAK7D,IAAM6D,GAAK7D,EAAE,GAAGX,SAAWwE,EAAE,GAAGxE,OAAQ,MAAO,KACpD,IAAIgC,GAAIQ,EAAOgC,GAAKhC,EAAO7B,EAC3B,IAAIuC,EAAKvC,GAAI,MAAO4B,GAAMP,GAAIjD,KAAKyC,MAAU,EAAJQ,EAAQ,IAAK,EACtD,IAAIpB,GAAI6B,EAAM+B,GAAK/B,EAAM9B,GACrBsD,EAAId,EAAOqB,GAAKrB,EAAOxC,GAAK,GAAK,EAAI,CACzC,OAAO4B,GAAM0B,EAAIjC,EAAGiC,EAAIrD,EAAGqD,GAsB7B,QAAgBc,GAASS,EAAMC,GAC7B,MAAyB,KAArBhB,UAAUzE,OAAqByF,GAAMV,EAASS,EAAMC,GAKjDzB,EAFCuB,EAFC1B,EAAQ2B,GACR3B,EAAQ4B,KAanB,QAAgBC,GAASR,EAAMC,GAC7B,MAAOJ,GAASI,EAAMD,GAcxB,QAAgBS,GAAUhF,EAAG6D,GAC3B,GAAIvD,GAAIsE,EAAO1B,EAAQlD,GAAIkD,EAAQW,GACnC,OAAOvD,GAAIkC,EAAOlC,GAAK,KC5JzB,QAAS2E,GAAOC,GACd,MAAOA,IAAW,IAANA,EAgDd,QAAgBC,GAAIxC,EAAIyC,GACtB,MAAOtB,WAAUzE,OAAS,EACtB8F,EAAIxC,GAAIyC,GACR,SAASC,GACP,MAAOC,IAAMD,GAAGF,IAAIxC,IAW5B,QAAgB4C,GAAQC,GACtB,MAAOF,IAAME,GAAKC,OAAOR,GAgB3B,QAAgBQ,IAAO9C,EAAIyC,GACzB,MAAOtB,WAAUzE,OAAS,EACtBoG,GAAO9C,GAAIyC,GACX,SAASC,GACP,MAAOC,IAAMD,GAAGI,OAAO9C,IAO/B,QAAS+C,IAAU9G,GACjB,IAAKA,EAAG,OAAQ+G,EAAAA,CAChB,IAAItE,GAAgB,EAAZQ,EAAOjD,EAEf,OAAOyC,GAAQ,IADPS,EAAMlD,KAAOR,KAAKyC,MAAMQ,EAAI,IAAM,KAK5C,QAASuE,IAAQ5F,EAAG6D,GAClB,MAAO6B,IAAU1F,GAAK0F,GAAU7B,GAGlC,QAASgC,IAAS7F,EAAG6D,GACnB,OAAQ+B,GAAQ5F,EAAG6D,GAqBrB,QAAgBiC,IAAKV,EAAMW,GACzB,GAAIpD,GACmB,IAArBmB,UAAUzE,SAAyB,IAAT0G,EACtBH,IACS,IAATG,EAAiBF,GAA2B,kBAATE,GAAsBA,EAAOH,EAGtE,OADAR,GAAOvH,MAAMmE,QAAQoD,GAAQA,EAAKY,QAAUV,GAAMF,GAC3Ca,GAAO,SAAST,GACrB,MAAOA,GAAIM,KAAKnD,GAAI8C,OAAOR,IAC1BG,GA4BL,QAASc,IAAMrG,GACb,MAAOsG,GAAGvE,EAAM,EAAG/B,EAAG,IAUxB,QAAgBuG,IAAOC,EAAOjB,GAC5B,GAAII,GAAMF,GAAMF,GACZkB,EAAMd,EAAInG,OACVQ,GAAKwG,EAAQC,EAAMA,GAAOA,CAC9B,OAAOd,GAAIQ,MAAMnG,EAAGyG,GAAKC,OAAOf,EAAIQ,MAAM,EAAGnG,IAa/C,QAAgB2G,IAAUH,EAAOjB,GAC/B,MAAOa,IAAO,SAAST,GACrB,GAAIc,GAAMd,EAAInG,OACVQ,GAAKwG,EAAQC,EAAMA,GAAOA,EAC1BG,EAAOjB,EAAIQ,MAAMnG,EAAGyG,GACpBI,EAAOlB,EAAIQ,MAAM,EAAGnG,GAEpBlC,EAAIqH,EAAUyB,EAAKH,EAAMzG,EAAI,GAAI6G,EAAK,GAC1C,IAAI/I,EAAI,EAAG,CACT,GAAIgJ,GAAOvI,KAAKyC,MAAMlD,EAAI,GACtB0I,GAAQ,EAAGI,EAAOA,EAAKtB,IAAIe,GAAMS,IAChCD,EAAOA,EAAKvB,IAAIe,IAAOS,IAE9B,MAAOF,GAAKF,OAAOG,IAClBtB,GAeL,QAAgBwB,IAAOC,EAAMzB,GAC3B,GAAyB,IAArBtB,UAAUzE,OACZ,MAAO,UAASgG,GACd,MAAOuB,IAAOC,EAAMxB,GAGxB,IAAIG,GAAMF,GAAMF,EAChB,OAAOE,IAAMuB,GAAM1B,IAAI,SAAStF,GAC9B,MAAO2F,GAAI3F,EAAI,IAAM,OAUzB,QAAgBiH,IAAa1B,GAE3B,MADAA,GAAOE,GAAMF,GACO,IAAhBA,EAAK/F,YACFyH,GAAa1B,EAAKY,MAAM,IAAIe,OAAO,SAAShI,EAAKiI,GACtD,MAAOjI,GAAIwH,OACTnB,EAAKD,IAAI,SAASD,EAAG5F,GACnB,GAAI2H,GAAUD,EAAKhB,OAEnB,OADAiB,GAAQC,OAAO5H,EAAK,EAAG8F,EAAK,IACrB6B,UAOf,QAASE,IAAWvI,GAClB,MAAO2E,GAAS3E,IAAMA,EAExB,QAASwI,IAAU1D,GACjB,MAAO3B,GAAQ2B,GAAKH,EAASG,GAAK2D,GAAM3D,GAAKA,EAAEyB,IAAIgC,IAAczD,EAgBnE,QAASuC,IAAOtD,EAAIyC,GAClB,GAAyB,IAArBtB,UAAUzE,OACZ,MAAO,UAASgG,GACd,MAAOY,IAAOtD,EAAI0C,GAGtB,IAAIG,GAAMF,GAAMF,GAAMD,IAAIjC,EAE1B,OAAOkE,IADGzE,EAAG6C,IC9Qf,QAAgB8B,IAAUlC,GACxB,GAAIpF,GAAIsF,GAAMF,EACd,OAAOpF,GAAEX,OAASkG,EAAQvF,EAAEmF,IAAIf,EAASpE,EAAE,MAAQA,EAgBrD,QAAgBuH,IAAYC,GAC1B,GAAIC,KACJD,GAAQlC,GAAMkC,EACd,KAAK,GAAIlH,GAAI,EAAGA,EAAIkH,EAAMnI,OAAQiB,IAChCmH,EAAKC,KAAKtD,EAASoD,EAAMlH,EAAI,GAAIkH,EAAMlH,IAEzC,OAAOmH,GAyBT,QAAgBE,IAAUvC,EAAMxD,GAC9B,MAAIkC,WAAUzE,OAAS,EAAUsI,GAAUvC,GAAMxD,GAC1C,SAASgG,GACd,MAAOrC,GAAQJ,EAAIgB,EAAGyB,GAAS,MAAOxC,KCxD1C,QAAgByC,IAAMtJ,GACpB,KAAME,GAAIC,GAAMC,KAAKJ,EACrB,OAAKE,IAEHI,OAAQJ,EAAE,GAAGK,cACbC,IAAKN,EAAE,GAAGO,QAAQ,KAAM,MACxBS,IAAKhB,EAAE,GACPqJ,IAAKrJ,EAAE,IALM,KASjB,QAASqE,IAAUvE,GACjB,KAAMK,GAAIiJ,GAAMtJ,EAChB,OAAOK,IAAe,KAAVA,EAAEkJ,KAER5I,MAAON,EAAEC,OAAOM,WAAW,GAAK,GAAK,EACrCC,IAAkB,MAAbR,EAAEG,IAAI,IAAcH,EAAEG,IAAIM,OAAST,EAAEG,IAAIM,OAC9CI,IAAKb,EAAEa,IAAIJ,QAAUT,EAAEa,IAAM,MAE/B,KAIN,QAAgBnB,IAAMyJ,GACpB,MAAoB,gBAATA,GAA0B,SACdC,KAAhBpF,GAAMmF,GACRnF,GAAMmF,GAAQjF,GAAUiF,GACzBnF,GAAMmF,GAwCZ,QAAgBE,IAASrK,EAAKsK,GAK5B,MAJAtK,GAAMQ,KAAK+J,MAAMvK,KACI,IAAXsK,EAAkBE,GAASC,IACxBzK,EAAM,KACXQ,KAAKyC,MAAMjD,EAAM,IAAM,GAkCjC,QAAgBuG,IAAKtE,GAEnB,MADAyI,SAAQC,KAAK,8CACNR,GAAKlI,GA6Cd,QAAgB2I,IAASrE,GACvBmE,QAAQC,KAAK,uCACb,IAAI3J,GAAIoE,EAAYmB,EACpB,OAAOvF,GAAIiD,EAAOjD,GAAK,KCtIzB,QAAgB8B,IAAM9C,GACpB,MAAO+C,KAAO/C,EAAM,GAAK,GAG3B,QAAS6K,IAAQjI,GAAO,OAAgB,IAATA,EAAa,IAAM,GAClD,QAAS5C,IAAK6C,EAAQhB,GAAO,MAAOgB,GAAS,EAAIhB,EAyCjD,QAAgBM,IAAOU,EAAQrB,EAAKK,EAAKe,GACvC,MAAOiI,IAAOjI,GAAO5C,GAAI6C,EAAQhB,GAAO0B,GAAOV,EAAQrB,GA0BzD,QAAS1B,IAASC,EAAGkC,GAAK,MAAOhC,OAAMO,KAAK8C,IAAIrB,GAAK,GAAG/B,KAAKH,GAY7D,QAAgBwD,IAAQvD,EAAKwB,GAC3B,GAAI4B,GAAmB,gBAARpD,GAAmB8C,GAAKtC,KAAK8C,IAAItD,IAAQA,CACxD,OAAY,KAARwB,EAAwB,MAAN4B,EAAY,IAAM,KACtB,IAAT5B,GAAoB,MAAN4B,EAAkB,IAChC5B,EAAM,EAAU1B,GAAQ,IAAK0B,GAC7BA,EAAM,EAAU1B,GAAQ,IAAW,MAANsD,EAAY5B,EAAMA,EAAM,GAClD,KCzFd,QAAgBsJ,IAAWC,GACzB,GAAIrI,GAAI2C,EAAW0F,EACnB,OAAOrI,GAAI+C,EAAO/C,GAAK,KAazB,QAAgB1C,IAAI+K,GAClB,GAAI/J,GAAIgK,GAAMD,EACd,OAAO/J,GAAIA,EAAEhB,IAAM,KAerB,QAAgBiL,IAAMF,GACpB,GAAI/J,GAAIgK,GAAMD,EACd,OAAO/J,GAAIA,EAAEhB,IAAMgB,EAAE4B,IAAM,KAkB7B,QAAgBoI,IAAMD,GACpB,GAAIrI,GAAI2C,EAAW0F,EACnB,KAAKrI,EAAG,MAAO,KACf,IAAIgD,GAAI5B,EAAOpB,EACf,QAAS1C,IAAK0F,EAAE,GAAK,EAAW,EAAPA,EAAE,GAAQlE,IAAKkE,EAAE,GAAI9C,IAAKF,EAAE,IAavD,QAAgBwI,IAAUF,GACxB,IAAKA,GAASA,EAAMhL,IAAM,EAAG,MAAO,KACpC,IAAI+I,GAAOvI,KAAKyC,MAAM+H,EAAMhL,IAAM,EAElC,OAAOmC,IADM6I,EAAMhL,IAAM,EAAI+I,EACRiC,EAAMxJ,KAAO,EAAGuH,EAAMiC,EAAMpI,KAanD,QAAgBwE,IAAU2D,GACxB,GAAIrI,GAAI2C,EAAW0F,EACnB,OAAOrI,GAAIkC,EAAOlC,GAAK,KAmBzB,QAAgByI,IAAcnL,GAC5B,GAAI0F,GAAI1F,EAAM,GAAK,EAAI,EACnBiC,EAAIzB,KAAK8C,IAAItD,GACboL,EAAInJ,EAAI,GACRI,EAAI7B,KAAKyC,MAAMhB,EAAI,GACvB,OAAOyD,IAAK2F,GAAGD,GAAK,EAAI/I,GAAKiJ,GAAGF,GAsBlC,QAAgBG,IAAGR,GACjB,GAAIrI,GAAI2C,EAAW0F,GACfhL,EAAI2C,EAAImC,EAAInC,GAAKlC,KAAK+J,MAAMQ,EAChC,OAAOS,OAAMzL,GAAK,KAAO0L,GAAQjL,KAAK8C,IAAIvD,GAAK,IAcjD,QAAgB+C,IAAKiI,GACnB,GAAIrI,GAAI2C,EAAW0F,EACnB,OAAOrI,GAAIK,GAAMe,EAAOpB,GAAG,IAAM,KClNnC,QAESvC,IAAOC,GAAK,MAAoB,gBAANA,GACnC,QAASsL,IAAOtL,GAAK,MAAoB,gBAANA,GACnC,QAASuL,IAAOvL,GAAK,WAAoB,KAANA,EACnC,QAASC,IAAYC,EAAMC,GACzB,MAAOC,MAAKC,IAAI,GAAIH,EAAO,IAAM,KAAOC,GAAU,KAoFpD,QAAgBG,IAAOC,EAAKC,EAASL,GACnC,GAAmB,gBAARI,GAAkB,MAAO,KACpC,IAAIE,GAAIC,GAAMC,KAAKJ,EACnB,KAAKE,IAAOD,GAAWC,EAAE,GAAK,MAAO,KAErC,IAAIG,IAAMC,OAAQJ,EAAE,GAAGK,cAAeC,IAAKN,EAAE,GAAGO,QAAQ,KAAM,MAC9DJ,GAAEK,GAAKL,EAAEC,OAASD,EAAEG,IACpBH,EAAEM,MAAQN,EAAEC,OAAOM,WAAW,GAAK,GAAK,EACxCP,EAAEQ,IAAmB,MAAbR,EAAEG,IAAI,IAAcH,EAAEG,IAAIM,OAAST,EAAEG,IAAIM,MACjD,IAAIC,GAAMC,GAAUX,EAAEM,MAAQN,EAAEQ,GAQhC,OAPAR,GAAEY,OAASF,EAAM,EAAI,GAAKA,EAAMA,EAAM,GAClCb,EAAE,KACJG,EAAEa,KAAOhB,EAAE,GACXG,EAAEV,KAAOoB,EAAM,IAAMV,EAAEa,IAAM,GAC7Bb,EAAEc,KAAOzB,GAAWW,EAAEV,KAAMC,IAE1BK,IAASI,EAAEe,QAAUlB,EAAE,IACpBG,EA6CT,QAAgBV,IAAMiG,GACpB,IAAKpG,GAAMoG,IAASmF,GAAMnF,KAAUA,GAAQ,GAAKA,EAAO,IAAK,OAAQA,CACrE,IAAIvF,GAAIN,GAAM6F,EACd,OAAOvF,IAAK2K,GAAM3K,EAAEV,MAAQU,EAAEV,KAAO,KC/HvC,QAAgBsL,IAAOC,GACrB,MAAI5L,OAAMmE,QAAQyH,IAAuB,IAAfA,EAAIpK,OACZ,EAAToK,EAAI,GAAkB,GAATA,EAAI,GAAU,GAC7BvL,GAAKuL,GAqBd,QAAgBtF,IAAKvG,EAAKsK,GACxB,OAAY,IAARtK,IAAwB,IAARA,EACX,SAASa,GACd,MAAO0F,IAAK1F,EAAGb,KAEnBA,EAAMQ,KAAK+J,MAAMvK,KACI,IAAXsK,EAAkBE,GAASC,IACxBzK,EAAM,KACXQ,KAAKyC,MAAMjD,EAAM,IAAM,IClCjC,QAASuK,IAAM1J,EAAGkE,GAEhB,MADAlE,MAAIA,GAAW,IAANA,IAAUL,KAAKC,IAAI,GAAII,GACzB,SAASiF,GAEd,MADAA,GAAIf,EAAGe,GACM,OAANA,EAAa,KAAOjF,EAAIL,KAAK+J,MAAMzE,EAAIjF,GAAKA,EAAIiF,GAkB3D,QAAgBgG,IAAWC,EAAKC,EAAKzF,GACnC,MAAIL,WAAUzE,OAAS,EAAUqK,GAAWC,EAAKC,GAAKzF,GAC/CgE,GAAMyB,EAAK,SAAShL,GACzB,GAAIH,GAAIoL,GAAWjL,EACnB,OAAOH,GAAIL,KAAKC,IAAI,GAAII,EAAI,IAAM,IAAMkL,EAAM,OA0BlD,QAAgBG,IAAiBH,EAAKC,EAAKlK,GACzC,MAAIoE,WAAUzE,OAAS,EAAUyK,GAAiBH,EAAKC,GAAKlK,GACrDyI,GAAMyB,EAAK,SAASlK,GACzB,MAAO,KAAMtB,KAAK2L,IAAIrK,GAAQtB,KAAK2L,IAAIJ,IAAQvL,KAAK2L,IAAI,GAAK,KA2BjE,QAAgB5F,IAAKzE,EAAMsK,GACzB,MAAOC,IAAWT,GAAO9J,GAAOsK,GAalC,QAAgBE,IAAMC,EAAMzK,GAC1B,GAAImE,GAAIuG,GAAOD,IAASA,EACpB9I,EAAI+I,GAAO1K,IAASA,CACxB,OAAOtB,MAAK+J,MAAc/J,KAAK2L,IAAI1I,EAAIwC,GAAKzF,KAAK2L,IAAI,GAAnC,MC3GpB,QAKSM,IAASC,GAChB,MAAOC,UAAS/K,GAAO8K,GAAM,GAE/B,QAASE,IAAS5L,GAEhB,MADAA,GAAIsE,EAAQtE,GACLA,EAAI6D,EAAI7D,GAAK,KAetB,QAAgBY,IAAO8K,GACrB,GAAIG,GAASH,GAAM,MAAOA,EAC1B,IAAIzG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAI1C,OAHAsB,GAAIqF,GAAUF,GAAKI,QAAQpK,IACzBuD,EAAEvD,GAAK,IAEFuD,EAAE/F,KAAK,IAWhB,QAAgB0J,IAAMA,GAEpBc,QAAQC,KAAK,+CACb,IAAIoC,GAAMxF,EAAIlG,GAAIuI,EAClB,KAAKmD,EAAItL,OAAQ,MAAOsL,EACxB,IAAI/C,GAAQ+C,EAAI,EAGhB,OAAOC,IADOxE,GAAOoE,GAAS5C,GAAQpI,GAAOmL,GAAK9C,MAAM,KAAK/J,KAAK,IACvC8J,GAiB7B,QAAgBiD,IAAMP,EAAKQ,GACzBA,GAA0B,IAAdA,CACZ,IAAIC,GAASvL,GAAO8K,GAAKzC,MAAM,GAC/B,OAAOtC,GACLwF,EAAO5F,IAAI,SAAS6F,EAAG1K,GACrB,GAAI2D,GAAImC,GAAO9F,EAAGyK,EAClB,OAAOD,IAAsB,MAAT7G,EAAE,GAAa,KAAOA,EAAEnG,KAAK,OAcvD,QAAgB2M,IAASH,GACvB,MAAO5L,IAAMuC,KAAKqJ,GAWpB,QAAgBW,IAAUX,GACxB,MAAO/E,GACL/F,GAAO8K,GACJzC,MAAM,IACN1C,IAAI,SAAS7B,EAAGhD,GACf,MAAa,MAANgD,EAAY4H,GAAK5K,GAAK,QAgBrC,QAAgBsK,IAAWG,EAAQnD,GAIjC,MAHAU,SAAQC,KACN,kEAEuB,IAArBzE,UAAUzE,OACL,SAAS2B,GACd,MAAO4J,IAAWG,EAAQ/J,KAEzB4G,IAAOA,EAAQ,MACbqD,GAAUF,GAAQ5F,IAAIvB,EAAUgE,KAYzC,QAAgBuD,IAAQC,EAAIC,GAC1B,MAAyB,KAArBvH,UAAUzE,OACL,SAAS1B,GACd,MAAOwN,IAAQC,EAAIzN,IAEhB6B,GAAO4L,KAAQ5L,GAAO6L,GAY/B,QAAgBC,IAASrK,EAAMqJ,GAE7B,QADArJ,EAAOoJ,GAASpJ,IACDoJ,GAASC,MAAUrJ,EAYpC,QAAgBsK,IAAWtK,EAAMqJ,GAE/B,QADArJ,EAAOoJ,GAASpJ,IACDoJ,GAASC,MAAUrJ,EAYpC,QAAgBuK,IAASlB,EAAKnG,GAC5B,MAAIL,WAAUzE,OAAS,EAAUmM,GAASlB,GAAKnG,IAC/CmG,EAAM9K,GAAO8K,GACN,SAASnG,GACd,MAA+B,MAAxBmG,EAAIE,GAASrG,MAexB,QAAgBsB,IAAO6E,EAAK9C,GAC1B,MAAyB,KAArB1D,UAAUzE,OACL,SAASQ,GACd,MAAO4F,IAAO6E,EAAKzK,IAEhByF,GAAMkC,GAAO/B,OAAO+F,GAASlB,IClNtC,QAKSvM,IAAM8B,GACb,MAAoB,gBAANA,GAGhB,QAAS4L,IAAM5L,GACb,MAAO9B,IAAM8B,GAAKA,EAAI2J,GAAO3J,GAG/B,QAAS6L,IAAK7H,EAAGhE,GACf,IAAK,GAAIG,MAAQH,IAAKG,EAAEH,GAAKA,EAAIgE,GACjC,MAAO7D,GAGT,QAAS2L,IAAM9H,EAAGhE,GAChB,IAAK,GAAIG,MAAQH,IAAKG,EAAEH,GAAKgE,EAAIhE,GACjC,MAAOG,GAGT,QAAS4L,IAAI5L,EAAG6D,GACd,MAAa,QAAN7D,GAAoB,OAAN6D,KAEjB7D,EAAI6D,EAAI6H,GAAK1L,EAAG6D,EAAI7D,EAAI,GAAK2L,GAAM3L,EAAGA,EAAI6D,EAAI,GAmBpD,QAAgBgI,IAAQzG,GACtB,MAAOE,IAAMF,GACVD,IAAIsG,IACJ1E,OAAO,SAAS9C,EAAGpE,EAAGS,GACrB,GAAU,IAANA,EAAS,MAAOsL,IAAI3H,EAAGpE,EAC3B,IAAIiM,GAAO7H,EAAEA,EAAE5E,OAAS,EACxB,OAAO4E,GAAEsC,OAAOqF,GAAIE,EAAMjM,GAAGmG,MAAM,MAezC,QAAgB+F,IAAU3G,EAAM8C,GAC9B,MAAO/C,GAAIhB,IAAgB,IAAX+D,GAAkB2D,GAAQzG,IAY5C,QAAgBvD,IAAO+F,EAAOoE,GAC5B,MAAOH,IAAQG,GAAO7G,IAAIjB,EAAS0D,IAgBrC,QAAgBqE,IAAS3B,EAAK0B,GAC5B,MAAyB,KAArBlI,UAAUzE,OACL,SAASgG,GACd,MAAO4G,IAAS3B,EAAKjF,IAGlBI,GAAO6E,EAAKyB,GAAUC,IClG/B,QAAgBE,IAAO7G,GACrB,GAAI1H,GAAI,UAAUwO,QAAQ9G,EAAEvG,cAC5B,OAAOnB,GAAI,EAAI,KAAOA,EAQxB,QAAgByO,IAAO9I,GACrB,QAASA,EAAI,GAAKA,EAAI,GAQxB,QAAgB+I,IAAS1O,GACvB,MAAOyO,IAAOzO,GAAK,UAAUwC,OAAOxC,GAAK,KAW3C,QAAgB2O,IAAS3O,GACvB,MAAO,OAAOsD,KAAKtD,GAOrB,QAAgB4O,IAAU5O,GACxB,MAAO,OAAOsD,KAAKtD,GAYrB,QAAgB6O,IAAM7O,GACpB,MAAa,KAANA,EACH,EACA2O,GAAS3O,IAAMA,EAAE0B,OAASkN,GAAU5O,GAAKA,EAAE0B,OAAS,KAG1D,QAAS3B,IAAQC,EAAGC,GAClB,MAAOC,OAAMD,EAAM,GAAGE,KAAKH,GAY7B,QAAgB8O,IAAM5M,GACpB,MAAQA,GAASA,EAAI,EAAInC,GAAQ,KAAMmC,GAAKnC,GAAQ,IAAKmC,GAA7C,GCtDd,QAAS6M,IAAM1L,EAAGvC,GAChB,MAAQuC,GAAQA,EAAI,IAAMvC,EAAdA,EAGd,QAASkO,IAAS9M,GAChB,MAAO6M,IAAMxI,EAAS,IAAKrE,GAAI,SAGjC,QAAS+M,IAAQC,GACf,MAAOtL,IAAOuL,GAAMX,QAAQU,IAG9B,QAASE,IAAUtO,GAEjB,MADAA,GAAIA,EAAEuO,OAAOC,eACgB,IAAtBH,GAAMX,QAAQ1N,GAAY,KAAOA,EAe1C,QAAgBmK,IAAMrK,GACpB,GAAmB,gBAARA,GAAkB,MAAO,KACpC,IACI2O,GADAC,EAAM5O,EAAI4N,QAAQ,IAEtB,KAAa,IAATgB,EAAY,CACd,GAAIvO,GAAIK,GAAGV,EACX2O,GAAMtO,GACAgJ,MAAOhJ,EAAGiO,KAAM,UAChBjF,OAAO,EAAOiF,KAAME,GAAUxO,QAEpC2O,IAAQtF,MAAO3I,GAAGV,EAAIyH,MAAM,EAAGmH,IAAON,KAAME,GAAUxO,EAAIyH,MAAMmH,EAAM,IAExE,OAAOD,GAAIL,KAAOK,EAAM,KAa1B,QAAgBE,IAAUrF,GACxB,MAAuB,QAAhBa,GAAMb,GAaf,QAAgBH,IAAMsF,GACpB,OAAQtE,GAAMsE,IAAQA,OAAWtF,OAAS,KAa5C,QAAgBiF,IAAKK,GACnB,OAAQtE,GAAMsE,IAAQA,OAAWL,MAAQ,KAkB3C,QAAgBQ,IAASC,EAAKJ,GAC5B,MAAyB,KAArBpJ,UAAUzE,OACL,SAASkO,GACd,MAAOF,IAASC,EAAKC,MAEzBD,EAAM1E,GAAM0E,KACAA,EAAI1F,MAAc,MAC9BsF,EAAMtE,GAAMsE,KACCA,EAAItF,MAEV8E,GADKxI,EAASgJ,EAAItF,MAAOgF,GAAQU,EAAIT,MAAQD,GAAQM,EAAIL,OAC5CS,EAAIT,MAFO,KAcjC,QAAgBW,IAAaN,GAC3B,GAAI9N,GAAMqO,GAAWP,EACrB,OAAe,QAAR9N,EACH,KACAA,EAAM,EACJyM,KAAU,EAAGzM,IAAM+F,IAAIjB,EAAS,MAChC2H,IAAS,EAAGzM,IAAM+F,IAAIjB,EAAS,MAevC,QAAgB2G,IAAM6C,GACpB,MAAOA,GAAQZ,GAAM9G,QAAU8G,GAAM9G,MAAM,GAAI,GAYjD,QAAgB2H,IAAU9N,GACxB,MAAoB,gBAANA,GAAiB8M,GAAS9M,GAAK,KAa/C,QAAgB+N,IAAQjQ,GACtB,MAAO4O,IAAU5O,GACbgP,GAAShP,EAAE0B,QACXiN,GAAS3O,GAAKgP,IAAUhP,EAAE0B,QAAU,KAc1C,QAAgBwO,IAAMX,GACpB,GAAItO,GAAIgK,GAAMsE,EACd,OAAKtO,IAAMA,EAAEgJ,MACND,GAAUmG,GAAOhB,GAAMX,QAAQvN,EAAEiO,OAAQjO,EAAEgJ,OADvB,KAa7B,QAAgB6F,IAAWP,GACzB,GAAIK,GAAI3E,GAAMsE,EACd,KAAKK,IAAMA,EAAE3F,MAAO,MAAO,KAC3B,IAAImG,GAAUnB,GAAQW,EAAEV,KAExB,OADUrE,IAAS+E,EAAE3F,OACRmG,EASf,QAAgBC,IAAUd,GACxB,MAAOT,IAAMgB,GAAWP,IClO1B,QAAgBnN,IAAMkO,EAAQ3P,GAAQN,GAAKA,EAAE6J,MAAM,OACjD,KAAMqG,GAAOC,OAAOD,KAAKD,GAAQnI,OAC3BsI,IACNF,GAAKxD,QAAQ6C,IACXa,EAAKb,GAAKjP,EAAM2P,EAAOV,GAAG,KACzBU,EAAOV,GAAG,QAAU7C,QAAQgD,GAAUU,EAAKV,GAASU,EAAKb,KAE5D,MAAMc,GAAUF,OAAOD,KAAKE,GAAMtI,OAC5BwI,EAAavG,GAAQqG,EAAKrG,EAEhC,OADAuG,GAAWJ,MAAOK,IAAYA,EAAUF,EAAUH,GAAMlI,SACjDsI,EAmDT,QAAgBA,IAAWE,EAAKlQ,GAC9BgK,QAAQC,KAAK,qCACbjK,EAAQA,IAAUN,GAAKA,EACvB,IAAIyQ,MACAC,EAAQP,OAAOD,KAAKM,GACpBD,IAWJ,OAVAG,GAAMhE,QAAQ,SAAS6C,GACrB,GAAI1E,GAAQvK,EAAMkQ,EAAIjB,GAAG,GACzBkB,GAAMlB,GAAK1E,EACP2F,EAAIjB,GAAG,IACTiB,EAAIjB,GAAG,GAAG7C,QAAQ,SAASgD,GACzBe,EAAMf,GAAS7E,EACf0F,EAAQ7G,KAAKgG,QAajBiB,IAAK,SAAS9O,GACZ,MAAO4O,GAAM5O,IAYfqO,KAAM,SAASU,EAAKnJ,GAClB,GAAIyI,GAAOU,EAAMF,EAAMnI,OAAOgI,GAAWG,EAAM1I,OAC/C,OAAyB,kBAAXP,GACVyI,EACAA,EAAKzI,OAAO,SAAS8H,GACnB,MAAO9H,GAAO8H,EAAGkB,EAAMlB,QAoBnC,QAAgBsB,IAASC,EAAM/O,GAC7B,GAAIgP,GAAyB,gBAAVhP,GACfiP,EAAwB,kBAAVjP,GACdkP,EAAeH,EAAKZ,MAAK,GAAOnH,OAAO,SAAS5B,EAAK+H,GAEvD,MADA/H,GAAI3F,GAAOsP,EAAKH,IAAIzB,KAASA,EACtB/H,MAGT,OAAO,UAASqC,GAGd,MAAOjC,GADIsF,GADXrD,EAAQ1B,GAAKX,EAAIlG,GAAIuI,KAGdrC,IAAI,SAASmF,EAAKhK,GACrB,GAAII,GAAOuO,EAAa3E,EACxB,KAAK5J,EAAM,MAAO,KAClB,IAAIkH,GAAQJ,EAAMlH,EAClB,OAAOyO,GACHnH,EAAQ7H,EAAQW,EAChBsO,EAAOjP,EAAMW,EAAMkH,IAAUlH,EAAMkH,OCrI/C,QAAgB+G,IAAIjO,EAAMkH,GAExB,GADAU,QAAQC,KAAK,mDACY,IAArBzE,UAAUzE,OACZ,MAAO,UAAS2B,GACd,MAAO2N,IAAIjO,EAAMM,GAErB,MAAMkO,GAAOJ,GAAKH,IAAIjO,EACtB,OAAOwO,GAAOvH,GAAUuH,EAAMtH,GAAS,KAgCzC,QAAgBJ,IAAMO,GACpB,KAAMoH,GAASC,GAAUrH,EAEzB,IADIoH,EAAOvH,OAAOU,QAAQyB,IAAIoF,EAAOvH,MAAO3I,GAAGkQ,EAAOvH,QAClDuH,EAAOvH,MAAO,CAChB,KAAMsH,GAAOrB,GAAMsB,EAAOzO,KAC1B,OAAOwO,GAAOA,EAAK/J,IAAIvB,EAAU3E,GAAGkQ,EAAOvH,YAG7C,OADciG,GAAMjG,MAAQ+G,GAAId,GAAMnN,KAAMzB,GAAG4O,GAAMjG,QAAU,OAG7DrC,EACEJ,EAAIlG,GAAI8I,GAAM5C,IAAI,SAAStF,EAAGS,EAAGkF,GAG/B,MAAOA,GAAI2G,QAAQtM,GAAKS,EAAI,KAAOT,KAkB3C,QAAgBoL,IAAUlD,GACxB,KAAMoH,GAASC,GAAUrH,EACzB,OAAO8F,IAAMsB,EAAOzO,UAYtB,QAAgB2O,IAAOtH,GACrB,WAAuBC,KAAhB6F,GAAM9F,GAGf,QAAgBuH,IAAYvH,GAE1B,MADAO,SAAQC,KAAK,8BACN8G,GAAOtH,GAiBhB,QAAgBqH,IAAU7Q,GACxB,GAAmB,gBAARA,GAAkB,MAAO,KACpC,MAAM+B,GAAI/B,EAAI4N,QAAQ,KAChBvE,EAAQzD,GAAK5F,EAAIgR,UAAU,EAAGjP,MAAO,CAE3C,QAASsH,MAAOA,EAAOlH,KADVkH,EAAQrJ,EAAIgR,UAAUjP,EAAI,GAAK/B,GC7G9C,QAAgBiR,MAAW,MAAO9Q,ICKlC,QAAgBiQ,IAAIjO,EAAMkH,GACxB,GAAyB,IAArB9D,UAAUzE,OACZ,MAAO,UAAS2B,GACd,MAAO2N,IAAIjO,EAAMM,GAErB,IAAIkO,GAAOJ,GAAKH,IAAIjO,EACpB,OAAOwO,GAAOvH,GAAUuH,EAAMtH,GAAS,KAezC,QAAgBJ,IAAMiI,GACpB,GAAI7Q,GAAIN,GAAMmR,GACVP,EAAOJ,GAAKH,IAAI/P,EAAE8B,KACtB,OAAOwO,GAAOvH,GAAUuH,EAAMtQ,EAAEgJ,OAASrC,EAAQJ,EAAIhB,GAAMsL,IAS7D,QAAgBxE,IAAUlD,GACxB,GAAInJ,GAAIN,GAAMyJ,EACd,OAAO+G,IAAKH,IAAI/P,EAAE8B,UAYpB,QAAgBgP,IAAa3H,GAC3B,MAAOkD,IAAUlD,GAAM1I,OAAS,EA4BlC,QAAgBsQ,IAASF,GACvB,GAAI9E,GAAMxF,EAAIlG,GAAIwQ,GACdG,EAASC,GAAWlF,EACxB,OAAOiF,GAASA,EAAOzD,QAAQxB,EAAI,IAAM,KAiB3C,QAAgBmF,IAAUlS,EAAK6R,GAC7B,GAAyB,IAArB3L,UAAUzE,OACZ,MAAO,UAAS2J,GACd,MAAO8G,IAAUlS,EAAKoL,GAE1B,IAAI4G,GAASC,GAAWJ,EACxB,OAAOG,GAASxJ,GAAOxI,EAAKgS,MAG9B,QAASC,IAAWJ,GAElB,IAAK,GADDb,GAAM9H,GAAaU,GAAMiI,GAAOtK,IAAIlG,KAC/BqB,EAAI,EAAGA,EAAIsO,EAAIvP,OAAQiB,IAE9B,GAAIyP,GADOxI,GAAYqH,EAAItO,KACN,MAAOsO,GAAItO,EAElC,OAAO,MAGT,QAASyP,IAAU3K,GACjB,IAAK,GAAI9E,GAAI,EAAGA,EAAI8E,EAAK/F,OAAQiB,IAC/B,GAAmB,MAAf8E,EAAK9E,GAAG,GAAY,OAAO,CAEjC,QAAO,EAmBT,QAAgBhC,IAAMyJ,GACpB,GAAInJ,GAAI4Q,KAAQ7Q,KAAKoJ,EACrB,OAAKnJ,GAGGA,EAAE,GAGG,MAATA,EAAE,IAAuB,MAATA,EAAE,IACd8B,KAAM9B,EAAE,GAAKA,EAAE,GAAIgJ,MAAOhJ,EAAE,GAAKA,EAAE,KACnC8B,KAAM9B,EAAE,GAAIgJ,MAAOhJ,EAAE,GAAKA,EAAE,GAAKA,EAAE,KAJrC8B,KAAM9B,EAAE,GAAIgJ,MAAOhJ,EAAE,GAAKA,EAAE,KAJjB8B,KAAMqH,EAAMH,OAAO,GClKtC,QAAgBoI,IAASC,EAAQrI,GAC/BA,EAAQ3I,GAAG2I,EAEX,IAAIsI,GAAS3K,GADb0K,EAAS9K,EAAI7G,GAAO2R,IAEX9K,IAAI,SAASnH,GAClB,MAAOA,GAAE4J,QAIb,OAAIsI,GAAO7Q,SAAW4Q,EAAO5Q,OAAe,KAErC6Q,EAAO/K,IAAI,SAASnE,EAAGV,GAC5B,GAAI1B,GAAIgK,GAAMxE,EAASwD,EAAO5G,GAC9B,OAAOmP,IAAWvR,EAAEhB,IAAM,EAAGgB,EAAEQ,IAAK6Q,EAAO3P,GAAGI,QAQlD,QAAgByP,IAAWvS,EAAKwB,EAAKgR,GACnC,MAAO3D,IAAMrN,GAAOiR,GAAKzS,EAAM,IAAMwS,GAAW,IAclD,QAAgBE,IAASL,EAAQrI,GAC/B,MAAOzC,GAAI,SAASD,GAClB,GAAIjB,GAAIsM,GAAgBrL,EACxB,OAAOjB,GAAIL,EAAUK,EAAEuM,KAAM5I,GAAS3D,EAAEvD,KAAO,MAC9CuP,GAsBL,QAAgBQ,MACd,MAAOC,IAoBT,QAAgBH,IAAgBhS,GAC9B,GAAIE,GAAIiS,GAAM/R,KAAKJ,EACnB,KAAKE,EAAG,MAAO,KACf,IAAIb,GAAM+S,GAAIlS,EAAE,GAAGwO,eAAiB,EAChC7N,EAAMX,EAAE,GAAGY,MAEf,OADgB,MAAZZ,EAAE,GAAG,KAAYW,GAAOA,IACnBoR,KAAM1H,IAAYlL,IAAKA,EAAKwB,IAAKA,EAAKoB,IAAK,IAAME,KAAMjC,EAAE,ICnFpE,QAAgBmS,IAAQxL,GACtB,GAAIpF,GAAG6D,EAAGvD,EACNkH,EAAQjC,EAAQJ,EAAInC,EAAaoC,IACjCkB,EAAMkB,EAAMnI,OACZwR,GAAU,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7B,KAAK7Q,EAAI,EAAGA,EAAIsG,EAAKtG,IACnB,IAAK6D,EAAI7D,EAAG6D,EAAIyC,EAAKzC,IAET,KADVvD,EAAI6I,GAAG1G,EAAI+E,EAAM3D,IAAMpB,EAAI+E,EAAMxH,MACpB6Q,EAAO,GAAKA,EAAO,GAAK,EAC5BvQ,EAAI,IAAGuQ,EAAO,EAAIvQ,GAAKuQ,EAAO,EAAIvQ,GAAK,EAGpD,OAAOuQ,GCxBT,QAAgBrJ,IAAMA,GACpB,MAAO1B,IAAK0B,GAAO/B,OAAO,SAAS5F,EAAGS,EAAGkF,GACvC,MAAa,KAANlF,GAAWT,IAAM2F,EAAIlF,EAAI,KxBbpC,GAAI5B,IAAQ,oDAqCRa,IAAa,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAgE/BW,GAAU,UC3GVG,GAAY,GAAIyQ,QAAO,+EA4CvB/P,IAAS,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAE3BJ,GAAQ,UCrCRY,IAAU,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAM7BC,GAAaD,GAAO4D,IAAI/D,GA2BxBO,IAAS,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GCoGpBmB,GAAYJ,EAAQ,SAAS/E,GACtC,GAAIiB,GAAImS,EAAUpT,EAClB,OAAOiB,GAAI0C,EAAO1C,EAAEM,KAAMN,EAAEQ,IAAKR,EAAEa,KAAO,OASjCsD,GAAWL,EAAQ,SAAS/E,GACrC,GAAIiB,GAAIoS,EAASrT,EACjB,OAAKiB,IACEA,EAAI0C,EAAO1C,EAAE6B,OAAS,EAAG7B,EAAEQ,IAAKR,EAAEa,IAAKb,EAAE4B,KADjC,OAmGNyQ,GAASzN,EAAUnB,EAAaS,GAAWK,GAS3C+N,GAAQ1N,EAAUlB,EAAYS,GAAUM,GASxC8N,GAAU3N,EAAUzB,EAASc,EAAYU,8ZGxPhD8D,GAAQxJ,MAAMmE,QA0BPsD,GAzCX,SAIe8L,GACb,MAAO,UAASnR,GACd,WAAa+H,KAAN/H,KAEHpC,MAAMmE,QAAQ/B,GACZA,EACa,gBAANA,GAAiBA,EAAE+M,OAAOnF,MAAMuJ,IAAQnR,KA+BhC,wBA8HdoR,GAAUpL,GAAO,SAAST,GAGnC,IAFA,GAAIlF,GAAGU,EACHvC,EAAI+G,EAAInG,OACLZ,GACL6B,EAAKlC,KAAKkT,SAAW7S,IAAO,EAC5BuC,EAAIwE,EAAI/G,GACR+G,EAAI/G,GAAK+G,EAAIlF,GACbkF,EAAIlF,GAAKU,CAEX,OAAOwE,4LE9JT,MAEM9G,IAAQ,mDAwBd,IAAIkE,MAQJ,MAAMuM,IAASxM,GAAM,CAACpE,EAAKK,IAA4B,QAApBA,EAAIN,GAAMC,IAAiBoE,EAAG/D,GAAK,KAEhE2S,IAAQ,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC1B/H,GAAS2F,GACbvQ,GAAgB,OAAVA,EAAEa,IAAe8R,GAAK3S,EAAEM,MAAQN,EAAEQ,IAAM,IAAMR,EAAEa,IAAM,GAAK,MActDvB,GAAOiG,GAAQqF,GAAOrF,KAAUA,GAAQ,IAErD,IAAIkE,IAAQ,+BAA+BR,MAAM,KAC7CO,GAAS,+BAA+BP,MAAM,IAiClD,MAAanI,IAAO,CAACnB,EAAKE,IACJ,QAAnBA,EAAIP,GAAKK,IAA8C,IAA7BH,KAAKC,IAAI,GAAII,EAAI,IAAM,IAAY,KAanDe,GAAS2P,GAAOvQ,IAAM2S,GAAK3S,EAAEM,MAAQN,EAAEQ,IAAM,KAAO,IAuBpDK,GAAM0P,GAAOvQ,GAAKA,EAAEa,KAMpB+R,GAAQ,CAAC/R,EAAK0E,IAASlF,GAAGkF,GAAQ1E,EAelCP,GAAOiQ,GAAOvQ,GAAKA,EAAEM,MA4BrBE,GAAM+P,GAAOvQ,GAAKA,EAAEQ,KAS3BP,GAASK,GAPC,UAOeA,GAEzBxB,GAAU,CAACC,EAAGkC,IAAMhC,MAAMgC,EAAI,GAAG/B,KAAKH,GACtC8T,GAAW,CAAC7T,EAAK8T,IAAuB,gBAAR9T,GAAmB,GAAK8T,EAAG9T,GAE3DmB,GAAMK,GACVqS,GAASrS,EAAKA,GAAQA,EAAM,EAAI1B,GAAQ,KAAM0B,GAAO1B,GAAQ,IAAK0B,IAWvDW,GAAQnB,GAAKC,GAAOD,EAAEM,MAAQH,GAAIH,EAAEQ,KAAOqS,GAAS7S,EAAEa,IAAKQ,GAAKA,GAkBhE8H,GAAOoH,GAAOvQ,GAAKmB,GAAMnB,IAYzBK,GAAKkQ,GAAOvQ,GAAKC,GAAOD,EAAEM,MAAQH,GAAIH,EAAEQ,gKCnNjDuB,GAAQ,UCoGRsI,IAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEvCC,GAAK,0BAA0BrB,MAAM,KAqBrCwB,IAAW,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAyB5C1I,GAAQ,UA6BDgR,GAAST,GAAM,SAAS5Q,GACjC,GAAIgD,GAAI5B,EAAOpB,EAIf,OAAOgB,IAFK,EAAIgC,EAAE,IAAM,EACE,MAAhB3C,GAAM2C,EAAE,KAAeA,EAAE,KAAOA,EAAE,GAAK,GACxBA,EAAE,GAAI9C,EAAIF,MAiB1BsR,GAAWV,GAAM,SAAS5Q,GAEnC,GAAI4B,GAAMR,EAAOpB,EAIjB,OAFe,KAAX4B,EAAI,IAAuB,IAAXA,EAAI,KAAUA,EAAI,GAAK,GAEpCZ,EAAOY,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAI1B,EAAIF,gJCrPxC5B,GAAQ,oDAqCRa,IAAa,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,ICZ/B8I,GAAQ,+BAA+BR,MAAM,KAC7CO,GAAS,+BAA+BP,MAAM,2CCiCvCuC,GAASV,GAAW,IAAK,GA4BzBF,GAASM,GAAiB,IAAK,8FCAtCpL,GAAQ,aAaRwM,GAAO,sCAAsCrD,MAAM,wTGxFnDiF,IACF,SACA,SACA,WACA,SACA,aACA,UACA,UACA,QACA,SAGEvL,IAAU,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GACnCuM,IAAU,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAG3I,IAAI,SAAStF,GACpD,MAAOyH,IAAUlB,GAAOvG,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,SAsOjDgS,GAAc7D,k3HC5NzB,MAAaH,IAAQ9N,+tHC1Bf+O,ID2Be/O,GAAM+R,IC3BdxD,8tHAAiB,SAAS/P,GACrC,MAAOA,GAAIsJ,MAAM,QA0CN6G,GAAQb,GAAMK,KA0Gd6D,GAASlD,GAASC,GAAM,mHC/JjCpQ,GAAQ,oDCSRoQ,GAAOR,+sHAAiB,SAAS/P,GACnC,MAAOA,GAAIsJ,MAAM,OAcR6G,GAAQI,GAAKZ,KA8Eb6D,GAASlD,GAASC,GAAM,0HCpE/BuB,IAAQ,IAAK,KAAM,MAAO,KAAM,IAAK,KAAM,OA0B3CK,GAAQ,yEAuBRC,IAAQrQ,EAAG,EAAG0R,GAAI,EAAGC,IAAK,EAAGC,GAAI,EAAGxO,EAAG,EAAGyO,GAAI,EAAGC,IAAK,0JGpDtDC,GAASlE,OAAOkE,OAChBC,GAAQD,MAAWE,GAAO3O,GAAW4O,GAAYC,UACrDH,IAAM1Q,MAAQA,GACd0Q,GAAMI,SAAWA,GACjBJ,GAAMnO,KAAOA,GACbmO,GAAM3J,IAAMvE,GACZkO,GAAMpU,KAAOA,GACboU,GAAM5S,KAAOA,GACb4S,GAAMtG,MAAQA,GACdsG,GAAMpF,IAAMA,GACZoF,GAAMK,YAAcA,GACpBL,GAAMM,SAAWA,GACjBN,GAAMO,SAAWA,GACjBP,GAAMQ,MAAQA,GAEdR,GAAMzE,MAAQ,SAAS9F,GACrB,MAAOuK,IAAMzE,MAAMrG,MAAMO,IAE3BsK,GAAOC,GAAMzE,MAAOA,IACpByE,GAAM7C,MAAQ,SAAS1H,GACrB,MAAOuK,IAAM7C,MAAMjI,MAAMO,IAE3BsK,GAAOC,GAAM7C,MAAOA,IAEE,mBAAXsD,UAAwBA,OAAOC,MAAQV"}
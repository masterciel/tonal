{"version":3,"file":"tonal.min.js","sources":["../packages/note/index.js","../packages/array/index.js","../packages/interval/index.js","../packages/distance/index.js","../packages/pcset/index.js","../packages/scale/index.js","../packages/chord/index.js","../packages/key/index.js","../packages/dictionary/index.js","../packages/tonal/index.js"],"sourcesContent":["/**\n * [![npm version](https://img.shields.io/npm/v/tonal-note.svg)](https://www.npmjs.com/package/tonal-note)\n * [![tonal](https://img.shields.io/badge/tonal-note-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-note` is a collection of functions to manipulate musical notes in scientific notation\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * import * as note from 'tonal-note'\n * // or const note = require('tonal-note')\n * note.name('bb2') // => 'Bb2'\n * note.chroma('bb2') // => 10\n * note.midi('a4') // => 69\n * note.freq('a4') // => 440\n * note.oct('G3') // => 3\n * \n * // part of tonal\n * const tonal = require('tonal')\n * tonal.note.midi('d4') // => 62\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-note](https://nodei.co/npm/tonal-note.png?mini=true)](https://npmjs.org/package/tonal-note/)\n *\n * ## API Documentation\n *\n * @module note\n */\n\nconst REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/;\n\nexport function tokenize(str) {\n  const m = REGEX.exec(str);\n  if (!m) return null;\n  return [m[1].toUpperCase(), m[2].replace(/x/g, \"##\"), m[3], m[4]];\n}\n\nconst NO_NOTE = Object.freeze({\n  pc: null,\n  name: null,\n  step: null,\n  alt: null,\n  oct: null,\n  chroma: null,\n  midi: null,\n  freq: null\n});\n\nconst SEMI = [0, 2, 4, 5, 7, 9, 11];\nconst properties = str => {\n  const tokens = tokenize(str);\n  if (tokens === null || tokens[3] !== \"\") return NO_NOTE;\n  const [letter, acc, oct] = tokens;\n  const p = { letter, acc };\n  p.pc = p.letter + p.acc;\n  p.name = p.pc + oct;\n  p.step = (p.letter.charCodeAt(0) + 3) % 7;\n  p.alt = p.acc[0] === \"b\" ? -p.acc.length : p.acc.length;\n  p.oct = oct.length ? +oct : null;\n  p.chroma = (SEMI[p.step] + p.alt + 120) % 12;\n  p.midi = p.oct !== null ? SEMI[p.step] + p.alt + 12 * (p.oct + 1) : null;\n  p.freq = midiToFreq(p.midi);\n  return Object.freeze(p);\n};\n\nconst cache = {};\nexport function props(str) {\n  if (typeof str !== \"string\") return NO_NOTE;\n  return cache[str] === undefined ? (cache[str] = properties(str)) : cache[str];\n}\n\n/**\n * Test if the given string is a note\n * @param {String} name \n * @return {boolean}\n */\nexport const isNote = str => props(str) !== NO_NOTE;\n\n/**\n * Given a note name, return the note name or null if not valid note.\n * The note name will ALWAYS have the letter in upercase and accidentals\n * using # or b\n * \n * Can be used to test if a string is a valid note name.\n *\n * @function\n * @param {Pitch|string}\n * @return {string}\n *\n * @example\n * const note = require('tonal-note')\n * note.name('cb2') // => 'Cb2'\n * ['c', 'db3', '2', 'g+', 'gx4'].map(note.name) // => ['C', 'Db3', null, null, 'G##4']\n */\nexport const name = str => props(str).name;\n\n/**\n * Get pitch class of a note. The note can be a string or a pitch array.\n *\n * @function\n * @param {string|Pitch}\n * @return {string} the pitch class\n * @example\n * tonal.pc('Db3') // => 'Db'\n * tonal.map(tonal.pc, 'db3 bb6 fx2') // => [ 'Db', 'Bb', 'F##']\n */\nexport const pc = str => props(str).pc;\n\n/**\n * Get the note midi number\n * (an alias of tonal-midi `toMidi` function)\n *\n * @function\n * @param {string|Number} note - the note to get the midi number from\n * @return {Integer} the midi number or null if not valid pitch\n * @example\n * note.midi('C4') // => 60\n * note.midi(60) // => 60\n * @see midi.toMidi\n */\nexport const midi = note => props(note).midi || +note || null;\n\n/**\n * Get the frequency from midi number\n * \n * @param {Number} midi - the note midi number\n * @param {Number} tuning - (Optional) 440 by default\n * @return {Number} the frequency or null if not valid note midi\n */\nexport const midiToFreq = (midi, tuning = 440) =>\n  typeof midi === \"number\" ? Math.pow(2, (midi - 69) / 12) * tuning : null;\n\n/**\n * Get the frequency of a note\n *\n * @function\n * @param {string|Number} note - the note name or midi note number\n * @return {Number} the frequency\n * @example\n * note.freq('A4') // => 440\n * note.freq(69) // => 440\n */\nexport const freq = note => props(note).freq || midiToFreq(note);\n\nconst L2 = Math.log(2);\nconst L440 = Math.log(440);\n/**\n * Get the midi number from a frequency in hertz. The midi number can\n * contain decimals (with two digits precission)\n * \n * @param {Number} frequency\n * @return {Number}\n * @example\n * note.freqToMidi(220)); //=> 57;\n * note.freqToMidi(261.62)); //=> 60;\n * note.freqToMidi(261)); //=> 59.96;\n */\nexport const freqToMidi = freq => {\n  const v = 12 * (Math.log(freq) - L440) / L2 + 69;\n  return Math.round(v * 100) / 100;\n};\n\n/**\n * Return the chroma of a note. The chroma is the numeric equivalent to the\n * pitch class, where 0 is C, 1 is C# or Db, 2 is D... 11 is B\n *\n * @param {string} note - the note name\n * @return {Integer} the chroma number\n * @example\n * const note = require('tonal-note')\n * note.chroma('Cb') // => 11\n * ['C', 'D', 'E', 'F'].map(note.chroma) // => [0, 2, 4, 5]\n */\nexport const chroma = str => props(str).chroma;\n\n/**\n * Get the octave of the given pitch\n *\n * @function\n * @param {string} note - the note\n * @return {Integer} the octave or null if doesn't have an octave or not a valid note\n * @example\n * note.oct('C#4') // => 4\n * note.oct('C') // => null\n * note.oct('blah') // => undefined\n */\nexport const oct = str => props(str).oct;\n\n/**\n * Get the note step: a number equivalent of the note letter. 0 means C and\n * 6 means B. This is different from `chroma` (see example)\n *\n * @function\n * @param {string} note - the note\n * @return {Integer} a number between 0 and 6 or null if not a note\n * @example\n * note.step('C') // => 0\n * note.step('Cb') // => 0\n * // usually what you need is chroma\n * note.chroma('Cb') // => 6\n */\nexport const step = str => props(str).step;\n\n/**\n * Get the note alteration: a number equivalent to the accidentals. 0 means\n * no accidentals, negative numbers are for flats, positive for sharps\n *\n * @function\n * @param {string|Pitch} note - the note\n * @return {Integer} the alteration\n * @example\n * note.alt('C') // => 0\n * note.alt('C#') // => 1\n * note.alt('Cb') // => -1\n */\nexport const alt = str => props(str).alt;\n\nconst LETTERS = \"CDEFGAB\";\n/**\n * Given a step number return it's letter (0 = C, 1 = D, 2 = E)\n * @param {number} step \n * @return {string} the letter\n * @example\n * note.stepToLetter(3) // => \"F\"\n */\nexport const stepToLetter = step => LETTERS[step];\n\nconst fillStr = (s, n) => Array(n + 1).join(s);\nconst numToStr = (num, op) => (typeof num !== \"number\" ? \"\" : op(num));\n\n/**\n * Given an alteration number, return the accidentals\n * @param {Number} alt \n * @return {String}\n * @example\n * note.altToAcc(-3) // => 'bbb'\n */\nexport const altToAcc = alt =>\n  numToStr(alt, alt => (alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt)));\n\nexport const build = ({ step, alt, oct }) => {\n  const pc = stepToLetter(step) + altToAcc(alt);\n  return oct === undefined ? pc : pc + oct;\n};\n\nconst FLATS = \"C Db D Eb E F Gb G Ab A Bb B\".split(\" \");\nconst SHARPS = \"C C# D D# E F F# G G# A A# B\".split(\" \");\n\n/**\n * Given a midi number, returns a note name. The altered notes will have\n * flats unless explicitly set with the optional `useSharps` parameter.\n *\n * @function\n * @param {number} midi - the midi note number\n * @param [boolean] useSharps - (Optional) set to true to use sharps instead of flats\n * @return {string} the note name\n * @example\n * const note = require('tonal-note')\n * note.fromMidi(61) // => 'Db4'\n * note.fromMidi(61, true) // => 'C#4'\n * // it rounds to nearest note\n * note.fromMidi(61.7) // => 'D4'\n */\nexport function fromMidi(num, sharps) {\n  num = Math.round(num);\n  const pcs = sharps === true ? SHARPS : FLATS;\n  const pc = pcs[num % 12];\n  const o = Math.floor(num / 12) - 1;\n  return pc + o;\n}\n","import { midi, name } from \"tonal-note\";\n\n/**\n * Rotates a list a number of times. It's completly agnostic about the\n * contents of the list.\n * @param {Integer} times - the number of rotations\n * @param {Array} array\n * @return {Array} the rotated array\n */\nexport const rotate = (times, arr) => {\n  var len = arr.length;\n  var n = (times % len + len) % len;\n  return arr.slice(n, len).concat(arr.slice(0, n));\n};\n\n/**\n * Return a copy of the array with the null values removed\n * @param {Array} array\n * @return {Array}\n * @example\n * tonal.compact(['a', 'b', null, 'c']) // => ['a', 'b', 'c']\n */\nexport const compact = arr => arr.filter(n => n === 0 || n);\n\n// a function that get note heights (with negative number for pitch classes)\nconst height = n => {\n  const m = midi(n);\n  return m !== null ? m : midi(n + \"-100\");\n};\n\n/**\n * Sort an array of notes in ascending order\n * \n * @private\n * @param {String|Array} notes\n * @return {Array} sorted array of notes\n */\nexport function sort(src) {\n  return compact(src.map(name)).sort((a, b) => height(a) > height(b));\n}\n\n/**\n * Get sorted notes with duplicates removed\n * \n * @private\n * @function\n * @param {Array} notes\n */\nexport function unique(arr) {\n  return sort(arr).filter((n, i, a) => i === 0 || n !== a[i - 1]);\n}\n\n/**\n * Randomizes the order of the specified array in-place, using the Fisherâ€“Yates shuffle.\n *\n * @private\n * @function\n * @param {Array|String} arr - the array\n * @return {Array} the shuffled array\n *\n * @example\n * import * as array from 'tonal-array'\n * array.shuffle([\"C\", \"D\", \"E\", \"F\"])\n */\nexport var shuffle = arr => {\n  var i, t;\n  var m = arr.length;\n  while (m) {\n    i = (Math.random() * m--) | 0;\n    t = arr[m];\n    arr[m] = arr[i];\n    arr[i] = t;\n  }\n  return arr;\n};\n\n/**\n * Get all permutations of a list\n * http://stackoverflow.com/questions/9960908/permutations-in-javascript\n * \n * @param {Array|Strng} list - the list\n * @return {Array<Array>} an array with all the permutations\n */\nexport const permutations = arr => {\n  if (arr.length === 0) return [[]];\n  return permutations(arr.slice(1)).reduce(function(acc, perm) {\n    return acc.concat(\n      arr.map(function(e, pos) {\n        var newPerm = perm.slice();\n        newPerm.splice(pos, 0, arr[0]);\n        return newPerm;\n      })\n    );\n  }, []);\n};\n\n// ascending range\nfunction ascR(b, n) {\n  for (var a = []; n--; a[n] = n + b);\n  return a;\n}\n// descending range\nfunction descR(b, n) {\n  for (var a = []; n--; a[n] = b - n);\n  return a;\n}\n\n// create a range between a and b\nexport function range(a, b) {\n  return a === null || b === null\n    ? []\n    : a < b ? ascR(a, b - a + 1) : descR(a, a - b + 1);\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-interval.svg)](https://www.npmjs.com/package/tonal-interval)\n * [![tonal](https://img.shields.io/badge/tonal-interval-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-interval` is a collection of functions to create and manipulate music intervals.\n *\n * The intervals are strings in shorthand notation. Two variations are supported:\n *\n * - standard shorthand notation: type and number, for example: 'M3', 'd-4'\n * - inverse shorthand notation: number and then type, for example: '3M', '-4d'\n *\n * The problem with the standard shorthand notation is that some strings can be\n * parsed as notes or intervals, for example: 'A4' can be note A in 4th octave\n * or an augmented four. To remove ambiguity, the prefered notation in tonal is the\n * inverse shortand notation.\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * ## Usage\n *\n * ```js\n * import * as interval from 'tonal-interval'\n * // or const interval = require('tonal-interval')\n * interval.semitones('4P') // => 5\n * interval.invert('3m') // => '6M'\n * interval.simplify('9m') // => '2m'\n * ```\n *\n * ## Install\n *\n * [![npm install tonal-interval](https://nodei.co/npm/tonal-interval.png?mini=true)](https://npmjs.org/package/tonal-interval/)\n *\n * ## API Documentation\n *\n * @module interval\n */\n// shorthand tonal notation (with quality after number)\nconst IVL_TNL = \"([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})\";\n// standard shorthand notation (with quality before number)\nconst IVL_STR = \"(AA|A|P|M|m|d|dd)([-+]?\\\\d+)\";\nconst REGEX = new RegExp(\"^\" + IVL_TNL + \"|\" + IVL_STR + \"$\");\nconst SIZES = [0, 2, 4, 5, 7, 9, 11];\nconst TYPES = \"PMMPPMM\";\nconst CLASSES = [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1];\n\nexport const tokenize = str => {\n  const m = REGEX.exec(str);\n  return m === null ? null : m[1] ? [m[1], m[2]] : [m[4], m[3]];\n};\n\nconst NO_IVL = Object.freeze({\n  name: null,\n  num: null,\n  q: null,\n  step: null,\n  alt: null,\n  dir: null,\n  type: null,\n  simple: null,\n  semitones: null,\n  chroma: null,\n  ic: null\n});\n\nconst fillStr = (s, n) => Array(Math.abs(n) + 1).join(s);\n\nconst qToAlt = (type, q) => {\n  if (q === \"M\" && type === \"M\") return 0;\n  if (q === \"P\" && type === \"P\") return 0;\n  if (q === \"m\" && type === \"M\") return -1;\n  if (/^A+$/.test(q)) return q.length;\n  if (/^d+$/.test(q)) return type === \"P\" ? -q.length : -q.length - 1;\n  return null;\n};\n\nconst altToQ = (type, alt) => {\n  if (alt === 0) return type === \"M\" ? \"M\" : \"P\";\n  else if (alt === -1 && type === \"M\") return \"m\";\n  else if (alt > 0) return fillStr(\"A\", alt);\n  else if (alt < 0) return fillStr(\"d\", type === \"P\" ? alt : alt + 1);\n  else return null;\n};\n\nconst numToStep = num => (Math.abs(num) - 1) % 7;\n\nconst properties = str => {\n  const t = tokenize(str);\n  if (t === null) return NO_IVL;\n  const p = { num: +t[0], q: t[1] };\n  p.step = numToStep(p.num);\n  p.type = TYPES[p.step];\n  if (p.type === \"M\" && p.q === \"P\") return NO_IVL;\n\n  p.name = \"\" + p.num + p.q;\n  p.dir = p.num < 0 ? -1 : 1;\n  p.simple = p.num === 8 || p.num === -8 ? p.num : p.dir * (p.step + 1);\n  p.alt = qToAlt(p.type, p.q);\n  p.oct = Math.floor((Math.abs(p.num) - 1) / 7);\n  p.semitones = p.dir * (SIZES[p.step] + p.alt + 12 * p.oct);\n  p.chroma = ((p.dir * (SIZES[p.step] + p.alt)) % 12 + 12) % 12;\n  p.ic = CLASSES[p.chroma];\n  return Object.freeze(p);\n};\n\nconst cache = {};\n/**\n * Get interval properties. It returns an object with:\n *\n * - name: name\n * - num: number\n * - q: quality\n * - step: step \n * - alt: alteration\n * - dir: direction (1 ascending, -1 descending)\n * - type: \"P\" or \"M\" for perfectable or majorable\n * - simple: the simplified number\n * - semitones: the size in semitones\n * - chroma: the interval chroma\n * - ic: the interval class\n *\n * @function\n * @param {String} interval - the interval\n * @return {Object} the interval in the form [number, alt]\n */\nexport function props(str) {\n  if (typeof str !== \"string\") return NO_IVL;\n  return cache[str] || (cache[str] = properties(str));\n}\n\n/**\n * Get the number of the interval \n *\n * @function\n * @param {String} interval - the interval\n * @return {Integer} \n * @example\n * interval.num('m2') // => 2\n * interval.num('P9') // => 9\n * interval.num('P-4') // => -4\n */\nexport const num = str => props(str).num;\n\n/**\n * Get interval name. Can be used to test if it's an interval. It accepts intervals\n * as pitch or string in shorthand notation or tonal notation. It returns always\n * intervals in tonal notation.\n *\n * @function\n * @param {String} interval - the interval string or array\n * @return {String} the interval name or null if not valid interval\n * @example\n * interval.name('m-3') // => '-3m'\n * interval.name('3') // => null\n */\nexport const name = str => props(str).name;\n\n/**\n * Get interval type. Can be perfectable (1, 4, 5) or majorable (2, 3, 6, 7)\n * It does NOT return the actual quality.\n *\n * @function\n * @param {String} interval\n * @return {String} 'P' for perfectables, 'M' for majorables or null if not\n * valid interval\n * @example\n * interval.type('5A') // => 'P'\n */\nexport const type = str => props(str).type;\n\n/**\n * Get size in semitones of an interval\n * \n * @function\n * @param {String} ivl\n * @return {Integer} the number of semitones or null if not an interval\n * @example\n * import { semitones } from 'tonal-interval'\n * semitones('P4') // => 5\n * // or using tonal\n * tonal.interval.semitones('P5') // => 7\n */\nexport const semitones = str => props(str).semitones;\n\n/**\n * Get the chroma of the interval. The chroma is a number between 0 and 7\n * that represents the position within an octave (pitch set)\n * \n * @function\n * @param {String} str \n * @return {Number}\n */\nexport const chroma = str => props(str).chroma;\n\n/**\n * Get the [interval class](https://en.wikipedia.org/wiki/Interval_class)\n * number of a given interval.\n *\n * In musical set theory, an interval class is the shortest distance in\n * pitch class space between two unordered pitch classes\n *\n * As paramter you can pass an interval in shorthand notation, an interval in\n * array notation or the number of semitones of the interval\n *\n * @function\n * @param {String|Integer} interval - the interval or the number of semitones\n * @return {Integer} A value between 0 and 6\n *\n * @example\n * interval.ic('P8') // => 0\n * interval.ic('m6') // => 4\n * ['P1', 'M2', 'M3', 'P4', 'P5', 'M6', 'M7'].map(ic) // => [0, 2, 4, 5, 5, 3, 1]\n */\nexport const ic = str => props(str).ic;\n\n/**\n * Given a interval property object, get the interval name\n *\n * The properties must contain a `num` *or* `step`, and `alt`:\n * \n * - num: the interval number\n * - step: the interval step (overrides the num property)\n * - alt: the interval alteration\n * - oct: (Optional) the number of octaves\n * - dir: (Optional) the direction\n * \n * @function\n * @param {Object} props - the interval property object\n *\n * @return {String} the interval name\n * @example\n * interval.build({ step: 1, alt: -1, oct: 0, dir: 1 }) // => \"1d\"\n * interval.build({ num: 9, alt: -1 }) // => '9m'\n */\nexport const build = ({ num, step, alt, oct = 1, dir } = {}) => {\n  if (step !== undefined) num = step + 1 + 7 * oct;\n  if (num === undefined) return null;\n\n  const d = dir < 0 ? \"-\" : \"\";\n  const type = TYPES[numToStep(num)];\n  return d + num + altToQ(type, alt);\n};\n\n/**\n * Get the simplified version of an interval.\n *\n * @function\n * @param {String} interval - the interval to simplify\n * @return {String} the simplified interval\n *\n * @example\n * interval.simplify('9M') // => '2M'\n * ['8P', '9M', '10M', '11P', '12P', '13M', '14M', '15P'].map(interval.simplify)\n * // => [ '8P', '2M', '3M', '4P', '5P', '6M', '7M', '8P' ]\n * interval.simplify('2M') // => '2M'\n * interval.simplify('-2M') // => '7m'\n */\nexport const simplify = str => {\n  const p = props(str);\n  if (p === NO_IVL) return null;\n  return p.simple + p.q;\n};\n\n/**\n * Get the inversion (https://en.wikipedia.org/wiki/Inversion_(music)#Intervals)\n * of an interval.\n *\n * @function\n * @param {String} interval - the interval to invert in interval shorthand\n * notation or interval array notation\n * @return {String} the inverted interval\n *\n * @example\n * interval.invert('3m') // => '6M'\n * interval.invert('2M') // => '7m'\n */\nexport const invert = str => {\n  const p = props(str);\n  if (p === NO_IVL) return null;\n  const step = (7 - p.step) % 7;\n  const alt = p.type === \"P\" ? -p.alt : -(p.alt + 1);\n  return build({ step, alt, oct: p.oct, dir: p.dir });\n};\n\n// interval numbers\nvar IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];\n// interval qualities\nvar IQ = \"P m M m M P d P m M m M\".split(\" \");\n\n/**\n * Get interval name from semitones number. Since there are several interval\n * names for the same number, the name it's arbitraty, but deterministic.\n * \n * @function\n * @param {Integer} num - the number of semitones (can be negative)\n * @return {String} the interval name\n * @example\n * import { fromSemitones } from 'tonal-interval'\n * fromSemitones(7) // => '5P'\n * // or using tonal\n * tonal.fromSemitones(-7) // => '-5P'\n */\nexport const fromSemitones = num => {\n  var d = num < 0 ? -1 : 1;\n  var n = Math.abs(num);\n  var c = n % 12;\n  var o = Math.floor(n / 12);\n  return d * (IN[c] + 7 * o) + IQ[c];\n};\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-distance.svg)](https://www.npmjs.com/package/tonal-distance)\n * [![tonal](https://img.shields.io/badge/tonal-distance-yellow.svg)](https://github.com/danigb/tonal/tree/master/packages/tonal/distance)\n * \n * Transpose notes by intervals and find distances between notes\n *\n * @example\n * // using ES6 import\n * import { interval, semitones, transpose } from 'tonal-distance'\n * semitones('C' ,'D') // => 2\n * interval('C4', 'G4') // => '5P'\n * transpose('C4', 'P5') // => 'G4'\n *\n * // included in tonal facade\n * const tonal = require('tonal');\n * tonal.distance.transpose('C4', 'P5')\n * tonal.distance.transposeBy('P5', 'C4')\n * \n * @module distance\n */\nimport { props as nprops, build as nbuild } from \"tonal-note\";\nimport { props as iprops, build as ibuild } from \"tonal-interval\";\n\n// Map from letter step to number of fifths starting from 'C':\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\nconst FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n\n// Given a number of fifths, return the octaves they span\nconst fOcts = f => Math.floor(f * 7 / 12);\n\n// Get the number of octaves it span each step\nconst FIFTH_OCTS = FIFTHS.map(fOcts);\n\nconst encode = ({ step, alt, oct, dir = 1 }) => {\n  const f = FIFTHS[step] + 7 * alt;\n  if (oct === null) return [dir * f];\n  const o = oct - FIFTH_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n};\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for ['F', 'C', 'G', 'D', 'A', 'E', 'B'] we have:\nconst STEPS = [3, 0, 4, 1, 5, 2, 6];\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f) {\n  const i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n\nconst decode = (f, o, dir) => {\n  const step = STEPS[unaltered(f)];\n  const alt = Math.floor((f + 1) / 7);\n  if (o === undefined) return { step, alt, dir };\n  const oct = o + 4 * alt + FIFTH_OCTS[step];\n  return { step, alt, oct, dir };\n};\n\nconst memo = (fn, cache = {}) => str => cache[str] || (cache[str] = fn(str));\n\nconst encoder = props =>\n  memo(str => {\n    const p = props(str);\n    return p.name === null ? null : encode(p);\n  });\n\nconst encodeNote = encoder(nprops);\nconst encodeIvl = encoder(iprops);\n\n/**\n * Transpose a note by an interval. The note can be a pitch class.\n * \n * This function can be partially applied.\n * \n * @param {String} note\n * @param {String} interval\n * @return {String} the transposed note\n * @example\n * import { tranpose } from 'tonal-distance'\n * transpose('d3', '3M') // => 'F#3'\n * // it works with pitch classes\n * transpose('D', '3M') // => 'F#'\n * // can be partially applied\n * ['C', 'D', 'E', 'F', 'G'].map(transpose('M3)) // => ['E', 'F#', 'G#', 'A', 'B']\n */\nexport function transpose(note, interval) {\n  if (arguments.length === 1) return i => transpose(note, i);\n  const n = encodeNote(note);\n  const i = encodeIvl(interval);\n  if (n === null || i === null) return null;\n  const tr = n.length === 1 ? [n[0] + i[0]] : [n[0] + i[0], n[1] + i[1]];\n  return nbuild(decode(tr[0], tr[1]));\n}\n\n/**\n * Transpose a pitch class by a number of perfect fifths. \n * \n * It can be partially applied.\n *\n * @function\n * @param {String} pitchClass - the pitch class \n * @param {Integer} fifhts - the number of fifths\n * @return {String} the transposed pitch class\n * \n * @example\n * import { trFifths } from 'tonal-transpose'\n * [0, 1, 2, 3, 4].map(trFifths('C')) // => ['C', 'G', 'D', 'A', 'E']\n * // or using tonal\n * tonal.trFifths('G4', 1) // => 'D'\n */\n\nexport function trFifths(note, fifths) {\n  if (arguments.length === 1) return f => trFifths(note, f);\n  const n = encodeNote(note);\n  if (n === null) return null;\n  return nbuild(decode(n[0] + fifths));\n}\n\n/**\n * Get the distance in fifths between pitch classes\n * \n * Can be partially applied.\n * \n * @param {String} to - note or pitch class\n * @param {String} from - note or pitch class \n */\nexport function fifths(from, to) {\n  if (arguments.length === 1) return to => fifths(from, to);\n  const f = encodeNote(from);\n  const t = encodeNote(to);\n  if (t === null || f === null) return null;\n  return t[0] - f[0];\n}\n\n/**\n * The same as transpose with the arguments inverted.\n * \n * Can be partially applied.\n * \n * @param {String} note\n * @param {String} interval\n * @return {String} the transposed note\n * @example\n * import { tranposeBy } from 'tonal-distance'\n * transposeBy('3m', '5P') // => '7m'\n */\nexport function transposeBy(interval, note) {\n  if (arguments.length === 1) return n => transpose(n, interval);\n  return transpose(note, interval);\n}\n\nconst isDescending = e => e[0] * 7 + e[1] * 12 < 0;\nconst decodeIvl = i =>\n  isDescending(i) ? decode(-i[0], -i[1], -1) : decode(i[0], i[1], 1);\n\nexport function addIntervals(ivl1, ivl2, dir) {\n  const i1 = encodeIvl(ivl1);\n  const i2 = encodeIvl(ivl2);\n  if (i1 === null || i2 === null) return null;\n  const i = [i1[0] + dir * i2[0], i1[1] + dir * i2[1]];\n  return ibuild(decodeIvl(i));\n}\n\n/**\n * Add two intervals \n * \n * Can be partially applied.\n * \n * @param {String} interval1\n * @param {String} interval2\n * @return {String} the resulting interval\n * @example\n * import { add } from 'tonal-distance'\n * add('3m', '5P') // => '7m'\n */\nexport function add(ivl1, ivl2) {\n  if (arguments.length === 1) return i2 => add(ivl1, i2);\n  return addIntervals(ivl1, ivl2, 1);\n}\n\n/**\n * Subtract two intervals\n * \n * Can be partially applied\n * \n * @param {String} minuend\n * @param {String} subtrahend\n * @return {String} interval diference\n */\nexport function subtract(ivl1, ivl2) {\n  if (arguments.length === 1) return i2 => add(ivl1, i2);\n  return addIntervals(ivl1, ivl2, -1);\n}\n\n/**\n * Find the interval between two pitches. It works with pitch classes \n * (both must be pitch classes and the interval is always ascending)\n * \n * Can be partially applied\n *\n * @param {String} from - distance from\n * @param {String} to - distance to\n * @return {String} the interval distance\n *\n * @example\n * import { interval } from 'tonal-distance'\n * interval('C2', 'C3') // => 'P8'\n * interval('G', 'B') // => 'M3'\n * \n * // or use tonal\n * var tonal = require('tonal')\n * tonal.distance.interval('M2', 'P5') // => 'P4'\n */\nexport function interval(from, to) {\n  if (arguments.length === 1) return t => interval(from, t);\n  const f = encodeNote(from);\n  const t = encodeNote(to);\n  if (f === null || t === null || f.length !== t.length) return null;\n  const d =\n    f.length === 1\n      ? [t[0] - f[0], -Math.floor((t[0] - f[0]) * 7 / 12)]\n      : [t[0] - f[0], t[1] - f[1]];\n  return ibuild(decodeIvl(d));\n}\n\n/**\n * Get the distance between two notes in semitones\n * \n * @param {String|Pitch} from - first note\n * @param {String|Pitch} to - last note\n * @return {Integer} the distance in semitones or null if not valid notes\n * @example\n * import { semitones } from 'tonal-distance'\n * semitones('C3', 'A2') // => -3\n * // or use tonal\n * tonal.distance.semitones('C3', 'G3') // => 7\n */\nexport function semitones(from, to) {\n  if (arguments.length === 1) return t => semitones(from, t);\n  const f = nprops(from);\n  const t = nprops(to);\n  return f.midi !== null && t.midi !== null\n    ? t.midi - f.midi\n    : f.chroma !== null && t.chroma !== null\n      ? (t.chroma - f.chroma + 12) % 12\n      : null;\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-pcset.svg?style=flat-square)](https://www.npmjs.com/package/tonal-pcset)\n * [![tonal](https://img.shields.io/badge/tonal-pcset-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-pcset` is a collection of functions to work with pitch class sets, oriented\n * to make comparations (isEqual, isSubset, isSuperset)\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * You can install via npm: `npm i --save tonal-pcset`\n *\n * ```js\n * var pcset = require('tonal-pcset')\n * pcset.isEqual('c2 d5 e6', 'c6 e3 d1') // => true\n * ```\n *\n * ## API documentation\n *\n * @module pcset\n */\nimport { chroma as notechr } from \"tonal-note\";\nimport { chroma as ivlchr } from \"tonal-interval\";\nimport { rotate } from \"tonal-array\";\n\nconst chr = str => notechr(str) || ivlchr(str) || 0;\nconst pcsetNum = set => parseInt(chroma(set), 2);\nconst compact = arr => arr.filter(x => x);\n\n/**\n * Get chroma of a pitch class set. A chroma identifies each set uniquely.\n * It's a 12-digit binary each presenting one semitone of the octave.\n *\n * Note that this function accepts a chroma as parameter and return it\n * without modification.\n *\n * @param {Array|String} set - the pitch class set\n * @return {String} a binary representation of the pitch class set\n * @example\n * pcset.chroma([\"C\", \"D\", \"E\"]) // => '1010100000000'\n */\nexport function chroma(set) {\n  if (isChroma(set)) return set;\n  if (!Array.isArray(set)) return \"\";\n  var b = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  set.map(chr).forEach(i => {\n    b[i] = 1;\n  });\n  return b.join(\"\");\n}\n\n/**\n * Given a a list of notes or a pcset chroma, produce the rotations\n * of the chroma discarding the ones that starts with '0'\n *\n * This is used, for example, to get all the modes of a scale.\n *\n * @param {Array|String} set - the list of notes or pitchChr of the set\n * @param {Boolean} normalize - (Optional, true by default) remove all\n * the rotations that starts with '0'\n * @return {Array<String>} an array with all the modes of the chroma\n *\n * @example\n * pcset.modes([\"C\", \"D\", \"E\"]).map(pcset.intervals)\n */\nexport function modes(set, normalize) {\n  normalize = normalize !== false;\n  var binary = chroma(set).split(\"\");\n  return compact(\n    binary.map(function(_, i) {\n      var r = rotate(i, binary);\n      return normalize && r[0] === \"0\" ? null : r.join(\"\");\n    })\n  );\n}\n\nvar REGEX = /^[01]{12}$/;\n/**\n * Test if the given string is a pitch class set chroma.\n * @param {String} chroma - the pitch class set chroma\n * @return {Boolean} true if its a valid pcset chroma\n * @example\n * pcset.isChroma('101010101010') // => true\n * pcset.isChroma('101001') // => false\n */\nexport function isChroma(set) {\n  return REGEX.test(set);\n}\n\nvar IVLS = \"1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M\".split(\" \");\n/**\n * Given a pcset (notes or chroma) return it's intervals\n * @param {String|Array} pcset - the pitch class set (notes or chroma)\n * @return {Array} intervals or empty array if not valid pcset\n * @example\n * pcset.intervals('1010100000000') => [\"1P\", \"2M\", \"3M\"]\n */\nexport function intervals(set) {\n  if (!isChroma(set)) return [];\n  return compact(\n    set.split(\"\").map(function(d, i) {\n      return d === \"1\" ? IVLS[i] : null;\n    })\n  );\n}\n\n/**\n * Test if two pitch class sets are identical\n *\n * @param {Array|String} set1 - one of the pitch class sets\n * @param {Array|String} set2 - the other pitch class set\n * @return {Boolean} true if they are equal\n * @example\n * pcset.isEqual('c2 d3', 'c5 d2') // => true\n */\nexport function isEqual(s1, s2) {\n  if (arguments.length === 1) return s => isEqual(s1, s);\n  return chroma(s1) === chroma(s2);\n}\n\n/**\n * Test if a pitch class set is a subset of another\n *\n * @param {Array|String} test - the set to test\n * @param {Array|String} set - the base set to test against\n * @return {Boolean} true if the test set is a subset of the set\n * @example\n * pcset.subset('c d e', 'C2 D4 D5 C6') // => true\n */\nexport function isSubset(test, set) {\n  test = pcsetNum(test);\n  return (test & pcsetNum(set)) === test;\n}\n\n/**\n * Test if a pitch class set is a superset\n *\n * @param {Array|String} test - the set to test\n * @param {Array|String} set - the base set to test against\n * @return {Boolean} true if the test set is a superset of the set\n * @example\n * pcset.isSuperset('c d e', 'C2 D4 F4 D5 E5 C6') // => true\n */\nexport function isSuperset(test, set) {\n  test = pcsetNum(test);\n  return (test | pcsetNum(set)) === test;\n}\n\n/**\n * Test if a given pitch class set includes a note\n * @param {Array|String} set - the base set to test against\n * @param {String|Pitch} note - the note to test\n * @return {Boolean} true if the note is included in the pcset\n * @example\n * pcset.includes('c d e', 'C4') // => true\n * pcset.includes('c d e', 'C#4') // => false\n */\nexport function includes(set, note) {\n  if (arguments.length > 1) return includes(set)(note);\n  set = chroma(set);\n  return function(note) {\n    return set[chr(note)] === \"1\";\n  };\n}\n\n/**\n * Filter a list with a pitch class set\n *\n * @param {Array|String} set - the pitch class set notes\n * @param {Array|String} notes - the note list to be filtered\n * @return {Array} the filtered notes\n *\n * @example\n * pcset.filter(c d e', 'c2 c#2 d2 c3 c#3 d3') // => [ 'c2', 'd2', 'c3', 'd3' ])\n * pcset.filter([\"C2\"], [\"c2\", \"c#2\", \"d2\", \"c3\", \"c#3\", \"d3\"]) // => [ 'c2', 'c3' ])\n */\nexport function filter(set, notes) {\n  if (arguments.length === 1) return n => filter(set, n);\n  return notes.filter(includes(set));\n}\n","/**\n * A scale is a collection of pitches in ascending or descending order.\n *\n * This module provides functions to get and manipulate scales.\n *\n * @example\n * scale.notes('Ab bebop') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'G' ]\n * scale.names() => ['major', 'minor', ...]\n * @module scale\n */\nimport { name as noteName, pc } from \"tonal-note\";\nimport { modes as pcsetModes, chroma, isSubset, isSuperset } from \"tonal-pcset\";\nimport { transpose } from \"tonal-distance\";\nimport { scale, chord } from \"tonal-dictionary\";\nimport { compact, unique, rotate } from \"tonal-array\";\n\nconst NO_SCALE = Object.freeze({\n  name: null,\n  intervals: [],\n  names: [],\n  chroma: null,\n  setnum: null\n});\n\nconst properties = name => {\n  const intervals = scale(name);\n  if (!intervals) return NO_SCALE;\n  const s = { intervals, name };\n  s.chroma = chroma(intervals);\n  s.setnum = parseInt(s.chroma, 2);\n  s.names = scale.names(s.chroma);\n  return Object.freeze(s);\n};\n\nconst memoize = (fn, cache) => str => cache[str] || (cache[str] = fn(str));\n\n/**\n * Get scale properties. It returns an object with:\n * - name: the scale name\n * - names: a list with all possible names (includes the current)\n * - intervals: an array with the scale intervals\n * - chroma:  scale croma (see pcset)\n * - setnum: scale chroma number\n *\n * @function\n * @param {String} name - the scale name (without tonic)\n * @return {Object} \n */\nexport const props = memoize(properties, {});\n\n/**\n * Return the available scale names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the scale names\n *\n * @example\n * const scale = require('tonal-scale')\n * scale.names() // => ['maj7', ...]\n */\nexport const names = scale.names;\n\n/**\n * Given a scale name, return its intervals. The name can be the type and\n * optionally the tonic (which is ignored)\n *\n * It retruns an empty array when no scale found\n *\n * @function\n * @param {String} name - the scale name (tonic and type, tonic is optional)\n * @return {Array<String>} the scale intervals if is a known scale or an empty\n * array if no scale found\n * @example\n * scale.intervals('major') // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]\n */\nexport const intervals = name => {\n  const p = tokenize(name);\n  return props(p[1]).intervals;\n};\n\n/**\n * Get the notes (pitch classes) of a scale. \n *\n * Note that it always returns an array, and the values are only pitch classes.\n *\n * @function\n * @param {String} tonic \n * @param {String} name - the scale name\n * @return {Array} a pitch classes array\n * \n * @example\n * scale.notes(\"C\", 'major') // => [ 'C', 'D', 'E', 'F', 'G', 'A', 'B' ]\n * scale.notes(\"C4\", 'major') // => [ 'C', 'D', 'E', 'F', 'G', 'A', 'B' ]\n * scale.notes(\"A4\", \"no-scale\") // => []\n * scale.notes(\"blah\", \"major\") // => []\n */\nexport function notes(nameOrTonic, name) {\n  const p = tokenize(nameOrTonic);\n  name = name || p[1];\n  return intervals(name).map(transpose(p[0]));\n}\n\n/**\n * Check if the given name is a known scale from the scales dictionary\n * \n * @function\n * @param {String} name - the scale name\n * @return {Boolean}\n */\nexport function exists(name) {\n  const p = tokenize(name);\n  return scale(p[1]) !== undefined;\n}\n\n/**\n * Given a string with a scale name and (optionally) a tonic, split \n * that components.\n * \n * It retuns an array with the form [ name, tonic ] where tonic can be a \n * note name or null and name can be any arbitrary string \n * (this function doesn't check if that scale name exists)\n *\n * @function\n * @param {String} name - the scale name\n * @return {Array} an array [tonic, name]\n * @example\n * scale.tokenize('C mixolydean') // => [\"C\", \"mixolydean\"]\n * scale.tokenize('anything is valid') // => [null, \"anything is valid\"]\n * scale.tokenize() // => [null, null]\n */\nexport function tokenize(str) {\n  if (typeof str !== \"string\") return [null, null];\n  const i = str.indexOf(\" \");\n  const tonic = noteName(str.substring(0, i)) || noteName(str);\n  const name = tonic !== null ? str.substring(tonic.length + 1) : str;\n  return [tonic, name.length ? name : null];\n}\n\n/**\n * Find mode names of a scale\n * \n * @function\n * @param {String} name - scale name\n */\nexport const modeNames = name => {\n  const ivls = intervals(name);\n\n  return pcsetModes(ivls).map(chroma => {\n    return scale.names(chroma)[0];\n  });\n};\n\n/**\n * Get all chords that fits a given scale\n * \n * @function\n * @param {String} name\n */\nexport const chords = name => {\n  const ivls = intervals(name);\n  return chord.names().filter(name => isSubset(chord(name), ivls));\n};\n\n/**\n * Given an array of notes, return the scale: a pitch class set starting from \n * the first note of the array\n * \n * @function\n * @param {Array} notes \n * @return {Array}\n */\nexport const toScale = notes => {\n  const pcset = compact(notes.map(pc));\n  if (!pcset.length) return pcset;\n  const tonic = pcset[0];\n  const scale = unique(pcset);\n  return rotate(scale.indexOf(tonic), scale);\n};\n\n/**\n * Find all scales names that has the same notes and more \n * (they are a superset of the given one)\n * \n * *This function name may change*\n * \n * @function\n * @param {String} name \n * @return {Array} a list of scale names\n */\nexport const extensions = name => {\n  const ivls = intervals(name);\n  if (!ivls.length) return [];\n  return scale.names().filter(name => isSuperset(scale(name), ivls));\n};\n\n/**\n * Find all scales names that fits into this scale \n * (they are a subset of the given one)\n * \n * *This function name may change*\n * \n * @function\n * @param {String} name \n * @return {Array} a list of scale names\n */\nexport const reductions = name => {\n  const ivls = intervals(name);\n  if (!ivls.length) return [];\n  return scale.names().filter(name => isSubset(scale(name), ivls));\n};\n\nexport const detect = notes => {\n  notes = toScale(notes);\n  const modes = pcsetModes(notes);\n  if (modes.length < 2) throw Error(\"It should have at least two notes\");\n\n  const results = [];\n\n  names().forEach(name => {\n    const p = props(name);\n    modes.forEach((mode, i) => {\n      if (isSubset(mode, p.chroma)) results.push([notes[i], name]);\n    });\n  });\n\n  return results;\n};\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-chord.svg)](https://www.npmjs.com/package/tonal-chord)\n * [![tonal](https://img.shields.io/badge/tonal-chord-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-chord` is a collection of functions to manipulate musical chords\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * @example\n * const chord = require('tonal-chord')\n * chord.notes('CMaj7') // => ['C', 'E', 'G', 'B']\n *\n * @module chord\n */\nimport { tokenize as split } from \"tonal-note\";\nimport { transpose } from \"tonal-distance\";\nimport { chord } from \"tonal-dictionary\";\nimport { chroma } from \"tonal-pcset\";\n\n/**\n * Return the available chord names\n *\n * @function\n * @param {boolean} aliases - true to include aliases\n * @return {Array} the chord names\n *\n * @example\n * import * as chord from 'tonal-chord'\n * chord.names() // => ['maj7', ...]\n */\nexport const names = chord.names;\n\nconst NO_CHORD = Object.freeze({\n  name: null,\n  names: [],\n  intervals: [],\n  chroma: null,\n  setnum: null\n});\n\nconst properties = name => {\n  const intervals = chord(name);\n  if (!intervals) return NO_CHORD;\n  const s = { intervals, name };\n  s.chroma = chroma(intervals);\n  s.setnum = parseInt(s.chroma, 2);\n  s.names = chord.names(s.chroma);\n  return s;\n};\n\nconst memo = (fn, cache = {}) => str => cache[str] || (cache[str] = fn(str));\n\n/**\n * Get chord properties. It returns an object with :\n * - name: the chord name\n * - names: a list with all possible names (includes the current)\n * - intervals: an array with the chord intervals\n * - chroma:  chord croma (see pcset)\n * - setnum: chord chroma number\n * \n * @function\n * @param {String} name - the chord name (without tonic)\n * @return {Object}\n */\nexport const props = memo(properties);\n\n/**\n * Get chord intervals. It always returns an array\n * \n * @function\n * @param {String} name - the chord name (optionally a tonic and type)\n * @return {Array<String>} a list of intervals or null if the type is not known\n */\nexport const intervals = name => props(tokenize(name)[1]).intervals;\n\n/**\n * Get the chord notes of a chord. This function accepts either a chord name\n * (for example: 'Cmaj7') or a list of notes.\n *\n * It always returns an array, even if the chord is not found.\n *\n * @function\n * @param {String} nameOrTonic - name of the chord or the tonic\n * @return [String] name - (Optional) name if the first parameter is the tonic\n *\n * @example\n * chord.notes('Cmaj7') // => ['C', 'E', 'G', 'B']\n * chord.notes('C', 'maj7') // => ['C', 'E', 'G', 'B']\n */\nexport function notes(nameOrTonic, name) {\n  const p = tokenize(nameOrTonic);\n  name = name || p[1];\n  return intervals(name).map(transpose(p[0]));\n}\n\n/**\n * Check if a given name correspond to a chord in the dictionary\n * \n * @function\n * @param {String} name\n * @return {Boolean}\n * @example\n * chord.exists('CMaj7') // => true\n * chord.exists('Maj7') // => true\n * chord.exists('Ablah') // => false\n */\nexport const exists = name => chord(tokenize(name)[1]) !== undefined;\n\n/*\n * Detect a chord. Given a list of notes, return the chord name(s) if any.\n * It only detects chords with exactly same notes.\n *\n * @function\n * @private\n * @param {Array|String} notes - the list of notes\n * @return {Array<String>} an array with the possible chords\n * @example\n * chord.detect('b g f# d') // => [ 'GMaj7' ]\n * chord.detect('e c a g') // => [ 'CM6', 'Am7' ]\n */\n//export const detect = () => [];\n\n/**\n * Get the position (inversion number) of a chord (0 is root position, 1 is first\n * inversion...). It assumes the chord is formed by superposed thirds.\n *\n * @function\n * @param {Array|String} chord - the chord notes\n * @return {Integer} the inversion number (0 for root inversion, 1 for first\n * inversion...) or null if not a valid chord\n *\n * @example\n * chord.position('e g c') // => 1\n * chord.position('g3 e2 c5') // => 1 (e is the lowest note)\n */\nfunction position(chord) {\n  const pcs = map(pc, chord);\n  const sorted = sortTriads(pcs);\n  return sorted ? sorted.indexOf(pcs[0]) : null;\n}\n\n/**\n * Given a chord in any inverstion, set to the given inversion. It accepts\n * chord names\n *\n * @private\n * @param {Integer} num - the inversion number (0 root position, 1 first\n * inversion, ...)\n * @param {String|Array} chord - the chord name or notes\n * @return {Array} the chord pitch classes in the desired inversion or\n * an empty array if no inversion found (not triadic)\n *\n * @example\n * chord.inversion(1, 'Cmaj7') // => [ 'E', 'G', 'B', 'C' ]\n * chord.inversion(0, 'e g c') // => [ 'C', 'E', 'G' ]\n */\nfunction inversion(num, chord) {\n  if (arguments.length === 1)\n    return function(c) {\n      return inversion(num, c);\n    };\n  const sorted = sortTriads(chord);\n  return sorted ? rotate(num, sorted) : [];\n}\n\nfunction sortTriads(chord) {\n  const all = permutations(notes(chord).map(pc));\n  for (let i = 0; i < all.length; i++) {\n    const ivls = intervallic(all[i]);\n    if (areTriads(ivls)) return all[i];\n  }\n  return null;\n}\n\nfunction areTriads(list) {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i][0] !== \"3\") return false;\n  }\n  return true;\n}\n\n/**\n * Tokenize a chord name. It returns an array with the tonic and chord type \n * If not tonic is found, all the name is considered the chord name.\n *\n * This function does NOT check if the chord type exists or not. It only tries\n * to split the tonic and chord type.\n *\n * @function\n * @param {String} name - the chord name\n * @return {Array} an array with [type, tonic]\n * @example\n * chord.tokenize('Cmaj7') // => [ 'C', 'maj7' ]\n * chord.tokenize('C7') // => [ 'C', '7' ]\n * chord.tokenize('mMaj7') // => [ null, 'mMaj7' ]\n * chord.tokenize('Cnonsense') // => [ 'C', 'nonsense' ]\n */\nexport function tokenize(name) {\n  const p = split(name);\n  if (!p) return [null, name];\n\n  // 6 and 7 is consider part of the chord\n  if (p[0] !== \"\" && (p[2][0] === \"6\" || p[2][0] === \"7\")) {\n    return [p[0] + p[1], p[2] + p[3]];\n  } else {\n    return [p[0] + p[1] + p[2], p[3]];\n  }\n}\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-key.svg?style=flat-square)](https://www.npmjs.com/package/tonal-key)\n * [![tonal](https://img.shields.io/badge/tonal-key-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-key` is a collection of functions to query about tonal keys.\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * @example\n * const key = require('tonal-key')\n * key.scale('E mixolydian') // => [ 'E', 'F#', 'G#', 'A', 'B', 'C#', 'D' ]\n * key.relative('minor', 'C major') // => 'A minor'\n *\n * @module key\n */\nimport { rotate, range } from \"tonal-array\";\nimport { tokenize as split, altToAcc } from \"tonal-note\";\nimport { trFifths, fifths, interval, transpose } from \"tonal-distance\";\n\nconst MODES = \"major dorian phrygian lydian mixolydian minor locrian ionian aeolian\".split(\n  \" \"\n);\nconst NUMS = [0, 1, 2, 3, 4, 5, 6, 0, 5];\nconst NOTES = \"C D E F G A B\".split(\" \");\nconst CHORDS = \"Maj7 m7 m7 Maj7 7 m7 m7b5\".split(\" \");\nconst FIFTHS = [0, 2, 4, -1, 1, 3, 5, 0, 3];\n\nconst modenum = mode => NUMS[MODES.indexOf(mode)];\n\n/**\n * Get a list of valid mode names. The list of modes will be always in\n * increasing order (ionian to locrian)\n *\n * @function\n * @param {Boolean} alias - true to get aliases names\n * @return {Array} an array of strings\n * @example\n * key.modes() // => [ 'ionian', 'dorian', 'phrygian', 'lydian',\n * // 'mixolydian', 'aeolian', 'locrian' ]\n * key.modes(true) // => [ 'ionian', 'dorian', 'phrygian', 'lydian',\n * // 'mixolydian', 'aeolian', 'locrian', 'major', 'minor' ]\n */\nexport const modeNames = aliases =>\n  aliases === true ? MODES.slice() : MODES.slice(0, 7);\n\n/**\n * Create a major key from alterations\n * \n * @function\n * @param {Integer} alt - the alteration number (positive sharps, negative flats)\n * @return {Key} the key object\n * @example\n * var key = require('tonal-key')\n * key.fromAlter(2) // => 'D major'\n */\nexport const fromAlter = i => trFifths(\"C\", i) + \" major\";\n\nexport const names = (alt = 4) => {\n  alt = Math.abs(alt);\n  const result = [];\n  for (let i = -alt; i <= alt; i++) result.push(fromAlter(i));\n  return result;\n};\n\nconst NO_KEY = Object.freeze({\n  name: null,\n  tonic: null,\n  mode: null,\n  modenum: null,\n  intervals: [],\n  scale: [],\n  alteration: null,\n  accidentals: null\n});\n\nconst properties = name => {\n  const p = tokenize(name);\n  if (p[0] === null) return NO_KEY;\n  const k = { tonic: p[0], mode: p[1] };\n  k.name = k.tonic + \" \" + k.mode;\n  k.modenum = modenum(k.mode);\n  const cs = rotate(k.modenum, NOTES);\n  k.intervals = cs.map(interval(cs[0]));\n  k.scale = k.intervals.map(transpose(k.tonic));\n  k.alteration = fifths(\"C\", k.tonic) - FIFTHS[MODES.indexOf(k.mode)];\n  k.accidentals = altToAcc(k.alteration);\n  return Object.freeze(k);\n};\n\nconst memo = (fn, cache = {}) => str => cache[str] || (cache[str] = fn(str));\n\n/**\n * Return the a key properties object with the following information:\n *\n * - name: name\n * - tonic: key tonic\n * - mode: key mode\n * - modenum: mode number (0 major, 1 dorian, ...)\n * - intervals: the scale intervals\n * - scale: the scale notes\n * - alteration: alteration number\n * - accidentals: accidentals \n *\n * @function\n * @param {String} name - the key name\n * @return {Object} the key properties object or null if not a valid key\n * @example\n * var key = require('tonal-key')\n * key.props('C3 dorian') // => { tonic: 'C', mode: 'dorian', ... }\n */\nexport const props = memo(properties);\n\n/**\n * Get scale of a key\n *\n * @function\n * @param {String|Object} key\n * @return {Array} the key scale\n * @example\n * key.scale('A major') // => [ 'A', 'B', 'C#', 'D', 'E', 'F#', 'G#' ]\n * key.scale('Bb minor') // => [ 'Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab' ]\n * key.scale('C dorian') // => [ 'C', 'D', 'Eb', 'F', 'G', 'A', 'Bb' ]\n * key.scale('E mixolydian') // => [ 'E', 'F#', 'G#', 'A', 'B', 'C#', 'D' ]\n */\nexport const scale = str => props(str).scale;\n\n/**\n * Get key alteration. The alteration is a number indicating the number of\n * sharpen notes (positive) or flaten notes (negative)\n * \n * @function\n * @param {String|Integer} key\n * @return {Integer}\n * @example\n * var key = require('tonal-keys')\n * key.alteration('A major') // => 3\n */\nexport const alteration = str => props(str).alteration;\n\n/**\n * Get key accidentals: a string with sharps or flats\n * \n * @function\n * @param {String} key\n * @return {String}\n * @example\n * import * as key from 'tonal-keys'\n * key.accidentals('A major') // => \"###\"\n */\nexport const accidentals = str => props(str).accidentals;\n\n/**\n * Get a list of the altered notes of a given key. The notes will be in\n * the same order than in the key signature.\n * \n * @function\n * @param {String} key - the key name\n * @return {Array}\n * @example\n * var key = require('tonal-keys')\n * key.alteredNotes('Eb major') // => [ 'Bb', 'Eb', 'Ab' ]\n */\nexport const alteredNotes = name => {\n  const alt = props(name).alteration;\n  if (alt === null) return null;\n  return alt === 0\n    ? []\n    : alt > 0\n      ? range(1, alt).map(trFifths(\"B\"))\n      : range(-1, alt).map(trFifths(\"F\"));\n};\n\n/**\n * Get key chords\n * \n * @function\n * @param {String} name - the key name\n * @return {Array}\n * @example\n * key.chords(\"A major\") // => [\"AMaj7\", \"Bm7\", \"C#m7\", \"DMaj7\", ..,]\n */\nexport const chords = str => {\n  const p = props(str);\n  if (!p.name) return [];\n  const chords = rotate(p.modenum, CHORDS);\n  return p.scale.map((tonic, i) => tonic + chords[i]);\n};\n\n/**\n * Get secondary dominant key chords\n * \n * @function\n * @param {String} name - the key name\n * @return {Array}\n * @example\n * key.secDomChords(\"A major\") // => [\"E7\", \"F#7\", ...]\n */\n\nexport const secDomChords = name => {\n  const p = props(name);\n  if (!p.name) return [];\n  return p.scale.map(t => transpose(t, \"P5\") + \"7\");\n};\n\n/**\n * Get relative of a key. Two keys are relative when the have the same\n * key signature (for example C major and A minor)\n *\n * It can be partially applied.\n *\n * @function\n * @param {String} mode - the relative destination\n * @param {String} key - the key source\n * @example\n * key.relative('dorian', 'B major') // => 'C# dorian'\n * // partial application\n * var minor = key.relative('minor')\n * minor('C major') // => 'A minor'\n * minor('E major') // => 'C# minor'\n */\nexport const relative = (mode, key) => {\n  if (arguments.length === 1) return key => relative(mode, key);\n  const num = modenum(mode.toLowerCase());\n  if (num === undefined) return null;\n  const k = props(key);\n  if (k.name === null) return null;\n  return trFifths(k.tonic, FIFTHS[num] - FIFTHS[k.modenum]) + \" \" + mode;\n};\n\n/**\n * Split the key name into its components (pitch class tonic and mode name)\n * \n * @function\n * @param {String} name \n * @return {Array} an array in the form [tonic, key]\n * @example\n * key.tokenize('C major') // => ['C', 'major']\n */\nexport const tokenize = name => {\n  const p = split(name);\n  p[3] = p[3].toLowerCase();\n  if (p[0] === \"\" || MODES.indexOf(p[3]) === -1) return [null, null];\n  return [p[0] + p[1], p[3]];\n};\n","/**\n * @private\n * [![npm version](https://img.shields.io/npm/v/tonal-dictionary.svg)](https://www.npmjs.com/package/tonal-dictionary)\n * [![tonal](https://img.shields.io/badge/tonal-dictionary-yellow.svg)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-dictionary` contains a dictionary of musical scales and chords\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n *\n * @example\n * const dictionary= require('tonal-dictionary')\n * dictionary.chord('Maj7') // => ['1P', '3M', '5P', '7M']\n *\n * @module dictionary\n */\nimport sdata from \"./data/scales.json\";\nimport cdata from \"./data/chords.json\";\nimport { chroma } from \"tonal-pcset\";\n\nexport const dictionary = raw => {\n  const keys = Object.keys(raw).sort();\n  const data = [];\n  const index = [];\n\n  const add = (name, ivls, chroma) => {\n    data[name] = ivls;\n    index[chroma] = index[chroma] || [];\n    index[chroma].push(name);\n  };\n\n  keys.forEach(key => {\n    const ivls = raw[key][0].split(\" \");\n    const alias = raw[key][1];\n    const chr = chroma(ivls);\n\n    add(key, ivls, chr);\n    if (alias) alias.forEach(a => add(a, ivls, chr));\n  });\n  const allKeys = Object.keys(data).sort();\n\n  const dict = name => data[name];\n  dict.names = p => {\n    if (typeof p === \"string\") return (index[p] || []).slice();\n    else return (p === true ? allKeys : keys).slice();\n  };\n  return dict;\n};\n\nexport const combine = (a, b) => {\n  const dict = name => a(name) || b(name);\n  dict.names = p => a.names(p).concat(b.names(p));\n  return dict;\n};\n\n/**\n * A dictionary of scales.\n *\n * @private\n * @function\n * @param {String} name\n * @return {Array} intervals\n * @example\n * import { scale } from 'tonal-dictionary'\n * scale('major') // => [\"1P\", \"2M\", ...]\n * scale.names(); // => [\"major\", ...]\n */\nexport const scale = dictionary(sdata);\n/**\n * A dictionary of chords.\n *\n * @private\n * @function\n * @param {String} name\n * @return {Array} intervals\n * @example\n * import { chord } from 'tonal-dictionary'\n * chord('Maj7') // => [\"1P\", \"3M\", ...]\n * chord.names(); // => [\"Maj3\", ...]\n */\nexport const chord = dictionary(cdata);\nexport const pcset = combine(scale, chord);\n","/**\n * [![npm version](https://img.shields.io/npm/v/tonal-key.svg?style=flat-square)](https://www.npmjs.com/package/tonal-key)\n * [![tonal](https://img.shields.io/badge/tonal-key-yellow.svg?style=flat-square)](https://www.npmjs.com/browse/keyword/tonal)\n *\n * `tonal-key` is a collection of functions to work with pitch class sets, oriented\n * to make comparations (isEqual, isSubset, isSuperset)\n *\n * This is part of [tonal](https://www.npmjs.com/package/tonal) music theory library.\n * The `tonal` module is a facade to the rest of the modules. They are namespaced,\n * so for example to use `pc` function from `tonal-note` you have to write:\n * `tonal.note.pc`\n *\n * It exports the following modules:\n * - note\n * - interval\n * - distance\n * - scale\n * - chord\n * - pcset\n * - key\n *\n * @example\n * var tonal = require('tonal')\n * tonal.distance.transpose(tonal.note.pc('C#2'), 'M3') // => 'E#'\n * tonal.chord.notes('Dmaj7') // => ['D', 'F#', 'A', 'C#']\n *\n * @module tonal\n */\nimport * as array from \"tonal-array\";\nimport * as note from \"tonal-note\";\nimport * as interval from \"tonal-interval\";\nimport * as distance from \"tonal-distance\";\nimport * as key from \"tonal-key\";\nimport * as scale from \"tonal-scale\";\nimport * as chord from \"tonal-chord\";\nimport * as pcset from \"tonal-pcset\";\n\nexport { array, note, interval, distance, key, scale, chord, pcset };\nexport default { array, note, interval, distance, key, scale, chord, pcset };\n"],"names":["tokenize","str","m","REGEX","exec","toUpperCase","replace","props","NO_NOTE","undefined","cache","properties","fromMidi","num","sharps","Math","round","SHARPS","FLATS","floor","sort","src","compact","map","name","a","b","height","unique","arr","filter","n","i","ascR","descR","range","NO_IVL","unaltered","f","transpose","note","interval","arguments","length","encodeNote","encodeIvl","tr","nbuild","decode","trFifths","fifths","from","to","t","transposeBy","addIntervals","ivl1","ivl2","dir","i1","i2","ibuild","decodeIvl","add","subtract","d","semitones","nprops","midi","chroma","set","isChroma","Array","isArray","chr","forEach","join","modes","normalize","binary","split","_","r","rotate","test","intervals","IVLS","isEqual","s1","s2","s","isSubset","pcsetNum","isSuperset","includes","notes","nameOrTonic","p","exists","scale","indexOf","tonic","noteName","substring","Object","freeze","pc","step","alt","oct","freq","SEMI","tokens","letter","acc","charCodeAt","midiToFreq","isNote","tuning","pow","L2","log","L440","freqToMidi","v","stepToLetter","fillStr","numToStr","op","altToAcc","build","times","len","slice","concat","shuffle","random","permutations","reduce","perm","e","pos","newPerm","splice","RegExp","SIZES","CLASSES","q","type","simple","ic","abs","qToAlt","altToQ","numToStep","simplify","invert","IN","IQ","fromSemitones","c","o","FIFTHS","fOcts","FIFTH_OCTS","encode","STEPS","memo","fn","encoder","iprops","isDescending","MODES","NUMS","NOTES","CHORDS","modenum","mode","modeNames","aliases","fromAlter","names","result","push","NO_KEY","alteration","accidentals","k","cs","alteredNotes","chords","secDomChords","relative","key","toLowerCase","notechr","ivlchr","parseInt","x","dictionary","raw","keys","data","index","ivls","alias","allKeys","dict","chord","cdata","NO_SCALE","setnum","pcsetModes","toScale","pcset","extensions","reductions","detect","Error","results","NO_CHORD","array","distance"],"mappings":"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"}
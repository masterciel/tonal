<!DOCTYPE html>

<html>
<head>
  <title>tonal</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          
          <h1 id="tonal">tonal</h1>
<p><strong>tonal</strong> is a functional music theory library. It deals with abstract music concepts like picthes and intervals, not actual music.</p>
<p><code>tonal</code> have no dependencies (it weights 6kb minified), but there are other modules that depends on it and extends it’s functionality.</p>
<p><code>tonal</code> is also the result of my journey of learning how to implement a music theory library in javascript in a functional way. And it’s been a long journey.</p>
<p>You are currently reading the source code of the library. It’s written in <a href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a> as a tribute to the The Haskell School of Music and it’s impressive book/source code <a href="http://haskell.cs.yale.edu/wp-content/uploads/2015/03/HSoM.pdf">“From Signals to Symphonies”</a> that has a big influence over tonal development.</p>
<p>This page is generated using the documentation tool <a href="http://jashkenas.github.io/docco/">docco</a></p>
<h2 id="music-theory-for-javascript-programmers">Music Theory for Javascript Programmers</h2>
<p><em>This is a music theory crash-course. The minimum to understand what this source is about. It’s main purpose it’s to be short, so probably contain lot of inexactitudes. Of course, pull request are welcomed.</em></p>
<p>This library is about tonal music (when talking about the library, <code>tonal</code> will appear with monospace font). In tonal music we make some assumptions about how music works. That assumptions are only applicable to part of the music (mostly western music) and they are useful in some contexts. Yes, sufji music doesn’t fit in this theory and probably doesn’t need to.</p>
<p>The most important assumption is that music is made up of units sound called <strong>notes</strong>, and each note has some properties: pitch, duration, timbre, loudness.</p>
<p>Sometimes we can use the words <em>note</em> and <em>pitch</em> interchangeably. For example “i’m playin C# note”, because you can’t play a pitch if it’s not as a property of a note (and “i’m playing a note with pitch C#” it’s too pedantic), but here we’ll <a href="http://music.stackexchange.com/questions/3262/what-are-the-differences-between-tone-note-and-pitch">differentiate between both</a> most of the time.</p>
<p>The <strong>pitch</strong> is how high the note is, and the difference between the pitch of two notes is called an <strong>interval</strong>.</p>
<p><code>tonal</code> library focuses mostly on pitches and intervals: create, compare and transform pitches is it’s main purpose.</p>
<p>In tonal music there’s a special interval called <strong>octave</strong> that has a very important function in music. Two pitches are separated by one octave when the frequency of the higher is the double of the lower. To the ears, they sound very similar, even if played together they are hard to distinguish. When we name them, they have very similar names, like <code>C1</code> and <code>C2</code>.</p>
<p>In tonal music we divide the <strong>octave</strong> in 12 equal parts (this is not always true, but it work for now). The distance of octave divided by 12 is called a <strong>semitone</strong> and it’s the minimum distance between pitches. All the notes inside an octave is called <strong>chromatic scale</strong>. Here’s one example: C3, Db3, D3, Eb3, E3, F3, F#3, G3, Ab3, A3, Bb3, B3.</p>
<p><em>(Talk about note names, octaves and pitch classes)</em></p>
<p>The hardest part to understand is that in tonal music we <strong>name</strong> pitches in terms of a subset of the chromatic scale. Instead of givin a name to all the pitches of a chromatic scale, we only give a name to a few (‘C D E F G A B’) and name the rest in relation to one of it. For example, the hole between ‘C3’ and ‘D3’ (as you see in previous chromatic scale, there’s a pitch between them) can be called ‘C#3’ (C-sharp 3, ‘C3’ plus 1 semitone) or ‘Db3’ (D-flat 3, ‘D3’ less 1 semitone). Yes, you read right: the same pitch can have different names. When this happen, they are called <strong>enharmonics</strong>.</p>
<p>The names with sharps <code>#</code> or flats <code>b</code> within them are called <strong>altered</strong>.
If you look at a piano keyboard, the white keys corresponds with unaltered pitches while black keys are the altered ones.</p>
<h3 id="prelude">Prelude</h3>
<p>We’ll see lot of arrays:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> isArr = <span class="hljs-built_in">Array</span>.isArray
</code></pre>
<h2 id="1-pitches">1. Pitches</h2>
<h3 id="multiple-notations">Multiple notations</h3>
<p>One of the goal of tonal is to represent pitches as strings, so you can write code like: <code>transpose(&#39;c#2 e3 g4&#39;, &#39;3P&#39;)</code>. I wanted to support the standard notation, but keep open to other implementations. The solution was support a simple numeric notation (the array notation) and decorate function arguments to support string notations.</p>
<p>To change the notation you can wrap any function to convert between the new notation and array notation, and keep using the same functions.</p>
<h3 id="array-notation">Array notation</h3>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pitch = (s, a, o) =&gt; o || o === <span class="hljs-number">0</span> ? [s, a, o] : [s, a]
</code></pre>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> hasOct = (p) =&gt; isArr(p) &amp;&amp; <span class="hljs-keyword">typeof</span> p[<span class="hljs-number">2</span>] !== <span class="hljs-string">'undefined'</span>
</code></pre>
<h3 id="scientific">Scientific</h3>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> PITCH_REGEX = <span class="hljs-regexp">/^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d{0,1})$/</span>
<span class="hljs-comment">/**
 * Get the a regex to parse pitch in scientific notation
 *
 * @return {Regex} the regex
 *
 * After exec against a valid string we get:
 * - 0: the complete string
 * - 1: the letter (in upper or lower case)
 * - 2: the alterations (a list of #, b or x)
 * - 3: an optional octave number
 * @example
 * pitchRegex().exec('C#2') // =&gt; ['C#2', 'C', '#', '2']
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pitchRegex = () =&gt; PITCH_REGEX
</code></pre>
<p>Then we’ll need a numeric representation of a letter. The <strong>step</strong> is a number from 0 to 6 representing letters <code>C D E F G A B</code>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> STEPS = <span class="hljs-string">'CDEFGAB'</span>
<span class="hljs-comment">/**
 * Given a pitch letter string, return it's letter index.
 * @param {String} letter - the pitch letter
 * @return {Integer} the letter index
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> step = (l) =&gt; STEPS.indexOf(l.toUpperCase())
</code></pre>
<p>Within <code>tonal</code> <em>alteration</em> is a numeric representation of accidentals. <code>0</code> means no accidentals, positive numbers are for sharps and negative numbers for flats (<code>x</code> means double sharp):</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Convert accidental string to alteration number
 * @function
 * @param {String} acc - the accidental string
 * @return {Integer} the alteration number
 * @example
 * accToAlt('#') // =&gt; 1
 * accToAlt('bbb') // =&gt; -2
 * accToAlt('') // =&gt; 0
 * accToAlt('x') // =&gt; 2
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accToAlt</span> (<span class="hljs-params">acc</span>) </span>{
  <span class="hljs-keyword">var</span> alt = acc.replace(<span class="hljs-regexp">/x/g</span>, <span class="hljs-string">'##'</span>).length
  <span class="hljs-keyword">return</span> acc[<span class="hljs-number">0</span>] === <span class="hljs-string">'b'</span> ? -alt : alt
}
</code></pre>
<p>With those tools we can write our <strong>pitchParse</strong> function:</p>
<pre><code class="lang-js"><span class="hljs-comment">// parse a string with a pitch in scientific notation (SN)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePSN</span> (<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">var</span> m = PITCH_REGEX.exec(str)
  <span class="hljs-keyword">if</span> (!m) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  <span class="hljs-keyword">var</span> l = step(m[<span class="hljs-number">1</span>])
  <span class="hljs-keyword">var</span> a = accToAlt(m[<span class="hljs-number">2</span>])
  <span class="hljs-keyword">var</span> o = m[<span class="hljs-number">3</span>] ? +m[<span class="hljs-number">3</span>] : <span class="hljs-literal">null</span>
  <span class="hljs-keyword">return</span> pitch(l, a, o)
}
</code></pre>
<h4 id="just-one-optimization">Just one optimization</h4>
<p>With previous versions of tonal I was too much worried about performance, and I’ve ended doing lot of micro optimizations that made the code difficult to follow. Now I prefer code clarity and brevity over performance. With one exception.</p>
<p>Since <code>tonal</code> is always converting between string notation to array notation, if we cache this process we’ll get a big performance gain:</p>
<pre><code class="lang-js"><span class="hljs-comment">// decorate a parser to cache results</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cache</span> (<span class="hljs-params">parser</span>) </span>{
  <span class="hljs-keyword">var</span> cache = {}
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">'string'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    <span class="hljs-keyword">return</span> cache[str] || (cache[str] = parser(str))
  }
}
</code></pre>
<p>Now we can have our optimized <strong>pitchParse</strong> function:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Given a pitch string in scientific notation, get the pitch in array notation
 * @function
 * @param {String} str - the string to parse
 * @return {Array} the pitch in array notation or null if not valid string
 * @example
 * pitchParse('C2') // =&gt; [2, 1]
 * pitchParse('bla') // =&gt; null
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pitchParse = cache(parsePSN)
</code></pre>
<h4 id="two-notations">Two notations</h4>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> pitchArr = (p) =&gt; isArr(p) ? p : pitchParse(p)
<span class="hljs-keyword">const</span> prop = (fn) =&gt; (p) =&gt; fn(pitchArr(p))
</code></pre>
<h4 id="pitch-properties">Pitch properties</h4>
<p><strong>pitch letter</strong></p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> letter = prop((p) =&gt; STEPS[p[<span class="hljs-number">0</span>]])
</code></pre>
<p><strong>pitch alteration and accidentals</strong></p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Get alteration of a pitch.
 *
 * The alteration is an integer indicating the number of sharps or flats
 *
 * @name alt
 * @function
 * @param {Array|String} pitch - the pitch (either in scientific notation or array notation)
 * @return {Integer} the alteration
 * @example
 * alt('C#2') // =&gt; 2
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> alt = prop((p) =&gt; p[<span class="hljs-number">1</span>])
</code></pre>
<p>Before we wrote a function to convert from accidentals to alteration. Now we need the oposite function:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Convert alteration number to accidentals
 * @function
 * @param {Integer} alt - the alteration number
 * @return {String} the accidentals string
 * @example
 * altToAcc(2) // =&gt; '##'
 * altToAcc(-2) // =&gt; 'bb'
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> altToAcc = (alt) =&gt; <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Math</span>.abs(alt) + <span class="hljs-number">1</span>).join(alt &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'b'</span> : <span class="hljs-string">'#'</span>)
</code></pre>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> accidentals = (p) =&gt; altToAcc(alt(p))
</code></pre>
<p><strong>pitch octave</strong></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> octOr = (d) =&gt; (p) =&gt; hasOct(p) ? p[<span class="hljs-number">2</span>] : d
<span class="hljs-keyword">const</span> octStr = octOr(<span class="hljs-string">''</span>)
<span class="hljs-keyword">const</span> octNum = octOr(<span class="hljs-number">0</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> oct = prop(octOr(<span class="hljs-literal">null</span>))
</code></pre>
<h3 id="pitch-to-scientific">Pitch to scientific</h3>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pitchStr = (p) =&gt; letter(p) + accidentals(p) + octStr(p)
</code></pre>
<h4 id="midi-pitch-numbers">Midi pitch numbers</h4>
<p>The midi number can have a value between 1-128:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Test if the given number is a valid midi note number
 * @function
 * @param {Object} num - the number to test
 * @return {Boolean} true if it's a valid midi note number
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isMidi = (m) =&gt; !isArr(m) &amp;&amp; m &gt; <span class="hljs-number">0</span> &amp;&amp; m &lt; <span class="hljs-number">129</span>
</code></pre>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> HEIGHTS = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>]
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> chroma = prop((p) =&gt; HEIGHTS[p[<span class="hljs-number">0</span>]] + p[<span class="hljs-number">1</span>])
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> height = prop((p) =&gt; chroma(p) + <span class="hljs-number">12</span> * octNum(p))
</code></pre>
<p>To match the general midi specification where <code>C4</code> is 60 we must add 12 to that height:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Get midi number for a pitch
 * @function
 * @param {Array|String} pitch - the pitch
 * @return {Integer} the midi number or null if not valid pitch
 * @example
 * midi('C4') // =&gt; 60
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> midi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>{
  <span class="hljs-keyword">var</span> a = pitchArr(p)
  <span class="hljs-keyword">return</span> hasOct(a) ? height(a) + <span class="hljs-number">12</span>
    : isMidi(p) ? +p
    : <span class="hljs-literal">null</span>
}
</code></pre>
<p>Since any midi number can be mapped to different pitch names, we should select one arbitrarily:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> CHROMATIC = [ <span class="hljs-string">'C'</span>, <span class="hljs-string">'Db'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'Eb'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'Gb'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'Ab'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'Bb'</span>, <span class="hljs-string">'B'</span> ]
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromMidi</span> (<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">var</span> midi = +num
  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">isNaN</span>(midi) || midi &lt; <span class="hljs-number">0</span> || midi &gt; <span class="hljs-number">127</span>) ? <span class="hljs-literal">null</span>
    : CHROMATIC[midi % <span class="hljs-number">12</span>] + (<span class="hljs-built_in">Math</span>.floor(midi / <span class="hljs-number">12</span>) - <span class="hljs-number">1</span>)
}
</code></pre>
<h4 id="frequency-conversions">Frequency conversions</h4>
<p>The most popular way (in western music) to calculate the frequency of a pitch is using the <a href="https://en.wikipedia.org/wiki/Well_temperament">well temperament</a> tempered tuning. It assumes the octave to be divided in 12 equally sized semitones and tune all the notes against a reference:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Get a frequency calculator function that uses well temperament and a tuning reference.
 * @function
 * @param {Float} ref - the tuning reference
 * @return {Function} the frequency calculator. It accepts a pitch in array or scientific notation and returns the frequency in herzs.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> wellTempered = (ref) =&gt; (pitch) =&gt; {
  <span class="hljs-keyword">var</span> m = midi(pitch)
  <span class="hljs-keyword">return</span> m ? <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, (m - <span class="hljs-number">69</span>) / <span class="hljs-number">12</span>) * ref : <span class="hljs-literal">null</span>
}
</code></pre>
<p>The most popular tuning reference is <code>A4 = 440Hz</code>:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Get the frequency of a pitch using well temperament scale and A4 equal to 440Hz
 * @function
 * @param {Array|String} pitch - the pitch to get the frequency from
 * @return {Float} the frequency in herzs
 * @example
 * toFreq('C4') // =&gt; 261.6255653005986
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> toFreq = wellTempered(<span class="hljs-number">440</span>)
</code></pre>
<h1 id="2-intervals">2. Intervals</h1>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> ivl = (s, a, o, d) =&gt; [s, a, o, d]
</code></pre>
<h4 id="parse-intervals">Parse intervals</h4>
<p>Parsing intervals is more complicated. First we need to get the simplified index from the interval number. This concept is equivalent to the letter class where each interval number (with independence of the quality) has a simplified index:</p>
<pre><code class="lang-js"><span class="hljs-comment">// get a simplified index from an interval number. Basically:</span>
<span class="hljs-comment">// unison is 0, second is 1, thirth is 2, ...</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ivlStep = (n) =&gt; (n - <span class="hljs-number">1</span>) % <span class="hljs-number">7</span>
</code></pre>
<p>Intervals can be <code>perfectables</code> (can have perfect quality: unisons, fourths and fifths) or <code>majorable</code> (can have major quality: seconds, thirds, sixths and sevenths):</p>
<pre><code class="lang-js"><span class="hljs-comment">// Interval steps is the index of the letter types</span>
<span class="hljs-keyword">var</span> TYPES = <span class="hljs-string">'PMMPPMM'</span>
</code></pre>
<p>The we need to get the alteration number from the quality string. Since some qualities are only valid for some kind of intervals, to parse we need to know the type:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Get an alteration number from an interval quality string.
 * It accepts the standard `dmMPA` but also sharps and flats.
 *
 * @param {String} type - the interval type ('P' or 'M')
 * @param {String} quality - the quality string
 * @return {Integer} the interval alteration
 * @example
 * qToAlt('M', 'm') // =&gt; -1 (for majorables, 'm' is -1)
 * qToAlt('P', 'A') // =&gt; 1 (for perfectables, 'A' means 1)
 * qToAlt('M', 'P') // =&gt; null (majorables can't be perfect)
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qToAlt</span> (<span class="hljs-params">type, q</span>) </span>{
  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'P'</span>) {
    <span class="hljs-keyword">if</span> (q === <span class="hljs-string">'P'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q[<span class="hljs-number">0</span>] === <span class="hljs-string">'A'</span>) <span class="hljs-keyword">return</span> q.length
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q[<span class="hljs-number">0</span>] === <span class="hljs-string">'d'</span>) <span class="hljs-keyword">return</span> -q.length
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'M'</span>) {
    <span class="hljs-keyword">if</span> (q === <span class="hljs-string">'M'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q === <span class="hljs-string">'m'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q[<span class="hljs-number">0</span>] === <span class="hljs-string">'A'</span>) <span class="hljs-keyword">return</span> q.length
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q[<span class="hljs-number">0</span>] === <span class="hljs-string">'d'</span>) <span class="hljs-keyword">return</span> -(q.length + <span class="hljs-number">1</span>)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}
</code></pre>
<p>Then we build our regex. We want to accept tonal shorthand notation (where number is before the quality: <code>3M</code>) and standard shorthand notation (quality before number: <code>M3</code>). We prefer the first notation because it’s unambiguous (the string <code>A4</code> can be interpreted as a pitch or as a interval in shorthand notation):</p>
<pre><code class="lang-js"><span class="hljs-comment">// shorthand tonal notation (with quality after number)</span>
<span class="hljs-keyword">var</span> IVL_TNL = <span class="hljs-string">'([-+]?)(\\d+)(d{1,4}|m|M|P|A{1,4})'</span>
<span class="hljs-comment">// standard shorthand notation (with quality before number)</span>
<span class="hljs-keyword">var</span> IVL_STR = <span class="hljs-string">'(AA|A|P|M|m|d|dd)([-+]?)(\\d+)'</span>
<span class="hljs-keyword">var</span> COMPOSE = <span class="hljs-string">'(?:('</span> + IVL_TNL + <span class="hljs-string">')|('</span> + IVL_STR + <span class="hljs-string">'))'</span>
<span class="hljs-keyword">var</span> IVL_REGEX = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + COMPOSE + <span class="hljs-string">'$'</span>)

<span class="hljs-comment">/**
 * Get regex to parse intervals in shorthand notation
 * @return {Regex} the regex
 *
 * After executing the regex, we will have an array-like object with:
 * - 0: the complete string
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ivlRegex</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> IVL_REGEX }
</code></pre>
<p>And our interval parse function:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Parse a string with an interval in shorthand notation. It support two types: standard shorthand interval notation `quality+[direction]+number` or the tonal shorthand notation `[direction]+number+quality`
 * @function
 * @param {String} str - the string to parse
 * @return {Array} the interval in array notation or null if not valid interval string
 * @example
 * ivlParse('3M') // =&gt; [ 4, -2, 1 ]
 * ivlParse('-3M') // =&gt; [ 4, -2, -1 ]
 * ivlParse('M3') // =&gt; [ 4, -2, 1 ]
 * ivlParse('M-3') // =&gt; [ 4, -2, -1 ]
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ivlParse = cache(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">var</span> m = IVL_REGEX.exec(str)
  <span class="hljs-keyword">if</span> (!m) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  <span class="hljs-keyword">var</span> num = +(m[<span class="hljs-number">3</span>] || m[<span class="hljs-number">8</span>])
  <span class="hljs-keyword">var</span> step = ivlStep(num)
  <span class="hljs-keyword">var</span> alt = qToAlt(TYPES[step], m[<span class="hljs-number">4</span>] || m[<span class="hljs-number">6</span>])
  <span class="hljs-keyword">var</span> oct = <span class="hljs-built_in">Math</span>.floor((num - <span class="hljs-number">1</span>) / <span class="hljs-number">7</span>)
  <span class="hljs-keyword">var</span> dir = (m[<span class="hljs-number">2</span>] || m[<span class="hljs-number">7</span>]) === <span class="hljs-string">'-'</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> ivl(step, alt, oct, dir)
})
</code></pre>
<h3 id="interval-properties">Interval properties</h3>
<p><strong>interval number</strong></p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> number = (i) =&gt; i[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> + <span class="hljs-number">7</span> * octNum(i[<span class="hljs-number">2</span>])
</code></pre>
<p><strong>interval type</strong></p>
<p>Intervals can be <em>perfectables</em> (unison, octaves, fourths, and fifths) or <em>majorables</em> (seconds, thirds, sixths and sevenths):</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Get the interval type
 * @function
 * @param {Array|String} ivl - the interval
 * @param {String} 'P' if it's perfectable, 'M' if it's majorable
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ivlType = (i) =&gt; TYPES[i[<span class="hljs-number">0</span>]]
</code></pre>
<p><strong>interval quality</strong></p>
<p>Using that information we can get the interval quality:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> ALTER = {
  P: [<span class="hljs-string">'dddd'</span>, <span class="hljs-string">'ddd'</span>, <span class="hljs-string">'dd'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'AA'</span>, <span class="hljs-string">'AAA'</span>, <span class="hljs-string">'AAAA'</span>],
  M: [<span class="hljs-string">'ddd'</span>, <span class="hljs-string">'dd'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'m'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'AA'</span>, <span class="hljs-string">'AAA'</span>, <span class="hljs-string">'AAAA'</span>]
}
<span class="hljs-comment">/**
 * Get interval quality
 * @function
 * @param {Array|String} ivl - the interval
 * @return {String} the quality string
 * @example
 * quality('3M') // =&gt; 'M'
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> quality = (i) =&gt; ALTER[ivlType(i)][<span class="hljs-number">4</span> + alt(i)]
</code></pre>
<p><strong>interval direction</strong></p>
<pre><code class="lang-js"><span class="hljs-comment">/*
 * get interval direction
 * @function
 * @param {Array|String} ivl - the interval
 * @return {Integer}
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> direction = (i) =&gt; { <span class="hljs-keyword">return</span> i[<span class="hljs-number">4</span>] }
<span class="hljs-keyword">const</span> dirStr = (p) =&gt; direction(p) === <span class="hljs-number">-1</span> ? <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>
</code></pre>
<h4 id="convert-intervals-to-strings">Convert intervals to strings</h4>
<p>Finally, we have the puzzle:</p>
<pre><code class="lang-js"><span class="hljs-comment">/**
 * Convert an interval in array notation to shorthand notation
 * @function
 * @param {Array} ivl - the interval in array notation
 * @return {String} the interval in shorthand notation
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ivlStr = (p) =&gt; dirStr(p) + number(p) + quality(p)
</code></pre>
<h2 id="3-distances">3. Distances</h2>
<h4 id="pitch-coordinates">Pitch coordinates</h4>
<p>Pitch coordinates hines when performing pitch transformations related to distances. Transpose or find interval between pitches are implemented simply by adding or subtracting the arrays as if they were vector values.</p>
<pre><code class="lang-js"><span class="hljs-comment">// map from pitch number to number of fifths and octaves</span>
<span class="hljs-keyword">var</span> BASES = [ [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">-2</span>] ]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCoord</span> (<span class="hljs-params">step, alt, oct, dir</span>) </span>{
  <span class="hljs-keyword">var</span> base = BASES[step]
  <span class="hljs-keyword">var</span> f = base[<span class="hljs-number">0</span>] + <span class="hljs-number">7</span> * alt
  <span class="hljs-keyword">if</span> (!oct &amp;&amp; oct !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [f]
  <span class="hljs-keyword">var</span> o = oct + base[<span class="hljs-number">1</span>] - <span class="hljs-number">4</span> * alt
  <span class="hljs-keyword">if</span> (!dir) <span class="hljs-keyword">return</span> [f, o]
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> [f, o, dir]
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> coord = (p) =&gt; p ? toCoord.apply(<span class="hljs-literal">null</span>, p) : <span class="hljs-literal">null</span>
</code></pre>
<pre><code class="lang-js"><span class="hljs-comment">// fifths mapped to pitch classes</span>
<span class="hljs-keyword">var</span> PCS = [[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">-3</span>]]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span> (<span class="hljs-params">f, o, d</span>) </span>{
  <span class="hljs-keyword">var</span> index = (f + <span class="hljs-number">1</span>) % <span class="hljs-number">7</span>
  <span class="hljs-keyword">var</span> pc = PCS[index &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">7</span> + index : index]
  <span class="hljs-keyword">var</span> step = pc[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">var</span> alt = <span class="hljs-built_in">Math</span>.floor((f + <span class="hljs-number">1</span>) / <span class="hljs-number">7</span>)
  <span class="hljs-keyword">if</span> (!o &amp;&amp; o !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [step, alt]
  <span class="hljs-keyword">var</span> oct = o - pc[<span class="hljs-number">1</span>] + alt * <span class="hljs-number">4</span>
  <span class="hljs-keyword">return</span> !d ? [step, alt, oct] : [step, alt, oct, d]
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> coordArr = (c) =&gt; c ? toArray.apply(<span class="hljs-literal">null</span>, c) : <span class="hljs-literal">null</span>
</code></pre>
<h4 id="transposition">Transposition</h4>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> add = (a, b) =&gt; {
  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">Math</span>.min(a.length, b.length)) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> [a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>]]
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> [a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>] + b[<span class="hljs-number">1</span>]]
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> [a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>] + b[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>] + b[<span class="hljs-number">2</span>]]
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> [a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>] + b[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>] + b[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>] + b[<span class="hljs-number">3</span>]]
    <span class="hljs-keyword">default</span>: []
  }
}
</code></pre>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trBy</span> (<span class="hljs-params">i, p</span>) </span>{
  <span class="hljs-keyword">if</span> (!isArr(i) || !isArr(p)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  <span class="hljs-keyword">return</span> pitchStr(coordArr(add(coord(i), coord(p))))
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transpose</span> (<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (c) =&gt; transpose(a, c)
  <span class="hljs-keyword">return</span> trBy(ivlParse(a) || a, pitchParse(b) || b) ||
    trBy(ivlParse(b) || b, pitchParse(a) || a)
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> tr = transpose
</code></pre>
<h2 id="4-collections">4. Collections</h2>
<p>Since <code>tonal</code> is string oriented, it would be nice to <strong>represent list as strings</strong>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// items can be separated by spaces, bars and commas</span>
<span class="hljs-keyword">var</span> SEP = <span class="hljs-regexp">/\s*\|\s*|\s*,\s*|\s+/</span>
<span class="hljs-comment">/**
 * Split a string by spaces (or commas or bars). Always returns an array, even if its empty
 * @param {String|Array|Object} source - the thing to get an array from
 * @return {Array} the object as an array
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">split</span> (<span class="hljs-params">source</span>) </span>{
  <span class="hljs-keyword">return</span> isArr(source) ? source
    : <span class="hljs-keyword">typeof</span> source === <span class="hljs-string">'string'</span> ? source.trim().split(SEP)
    : (source === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> source === <span class="hljs-string">'undefined'</span>) ? []
    : [ source ]
}
</code></pre>
<h4 id="map-collections">Map collections</h4>
<p>With the above function we can map collection easily: <code>split(&#39;C D E F G&#39;).map(transpose(&#39;3M&#39;))</code>.</p>
<p>We will write a <strong>map</strong> helper function that do more or less the same:</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span> (<span class="hljs-params">fn, list</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) </span>{ <span class="hljs-keyword">return</span> map(fn, l) }
  <span class="hljs-keyword">return</span> split(list).map(fn)
}
</code></pre>
<p>But it have two gems inside:</p>
<ul>
<li>The function is currified. In fact, most of the functions in tonal are <a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html">currified</a></li>
<li>The parameters are arranged to make it convenient for currying. The data to be operated on is supplied last (so instead of <code>map(list, fn)</code> we will write <code>map(fn, list)</code>)</li>
</ul>
<p>Both things are related and they are in the heart of tonal library. Javascript programmers will find awkward, at the beginning, to have the array as last argument of <code>map</code> function, but now you can write:</p>
<pre><code><span class="hljs-comment">// notice this is only an example, not part of the library</span>
<span class="hljs-keyword">var</span> letters = map(letter);
letters(<span class="hljs-string">'c2 eb4 g7'</span>) <span class="hljs-comment">// =&gt; ['C', 'Eb', 'G']</span>
</code></pre><h4 id="some-helpers">Some helpers</h4>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">harmonize</span> (<span class="hljs-params">list, tonic</span>) </span>{
  <span class="hljs-keyword">return</span> split(list).map(tr(tonic))
}
</code></pre>
<p>Fin.</p>

          
        

        
      </div>

      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>

[
  {
    "description": "Get a set binary number from a collection of notes or intervals\n\nA set binary number is a 12 digit binary, each digit representing a step\nin the chromatic scale. For example, `101010000000` is `['1P', '2M', '3M']`\n\nThe set binary number is very useful to check if two sets are equal or\ncontains same intervals (regarding of note names)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 9,
        "name": "binarySet.toBinary"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 10,
        "name": null
      },
      {
        "title": "param",
        "description": "a gamut",
        "lineNumber": 12,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "returns",
        "description": "the binary number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var binarySet = require('binary-set')\nbinarySet.toBinary('C2 E4 D3') // => '101010000000'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "bs"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 12,
        "column": 0
      },
      "end": {
        "line": 29,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 30,
          "column": 0
        },
        "end": {
          "line": 40,
          "column": 0
        }
      },
      "file": "./packages/binary-set/index.js",
      "code": "'use strict'\n\nvar G = require('music-gamut')\nvar transpose = require('note-transpose')\n\n/*\n */\nfunction bs () {\n\n}\n\n/**\n * Get a set binary number from a collection of notes or intervals\n *\n * A set binary number is a 12 digit binary, each digit representing a step\n * in the chromatic scale. For example, `101010000000` is `['1P', '2M', '3M']`\n *\n * The set binary number is very useful to check if two sets are equal or\n * contains same intervals (regarding of note names)\n *\n * @name binarySet.toBinary\n * @function\n * @param {String|Array|Array<Array>} source - a gamut\n * @return {String} the binary number\n *\n * @example\n * var binarySet = require('binary-set')\n * binarySet.toBinary('C2 E4 D3') // => '101010000000'\n */\nbs.toBinary = G.operation(function (gamut) {\n  var number = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  var intervals = G.set(G.harmonizer(gamut, false))\n  var semitones = intervals.map(height)\n  semitones.forEach(function (s) {\n    number[s] = 1\n  })\n  return number.join('')\n})\n\nfunction height (p) {\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\nvar INTERVALS = ['1P', '2m', '2M', '3m', '3M', '4P', '4#', '5P', '6m', '6M', '7m', '7M']\n\n/**\n * Get a set from a binary set number and (optionally) a tonic. If the tonic is\n * a note, you get a pitch set. If its false you get a interval set.\n *\n * @name set.fromBinary\n * @function\n * @param {String|Array|Array<Array>} source - the gamut\n * @param {String} tonic - the first note of the set or false to get the intervals\n * @return {Array<String>} the set pitch classes (note names without octaves)\n *\n * @example\n * var fromBinary = require('tonal.set/fromBinary')\n * // use a 12 digit binary number:\n * fromBinary('101011010101', 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // or its decimal equivalent:\n * fromBinary(2773, 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // get the interval set by passing `false` as tonic:\n * fromBinary(2773, false) // => ['1P', '2M', '3M', '4', '5', '6M', '7M']\n */\nbs.fromBinary = function (number, tonic) {\n  if (arguments.length === 1) return function (t) { return bs.fromBinary(number, t) }\n\n  if (/^1[01]{11}$/.test(number)) number = parseInt(number, 2)\n  else if (typeof number !== 'number') return []\n  var binary = ((number % 2048) + 2048).toString(2)\n\n  var set = []\n  for (var i = 0; i < 12; i++) {\n    if (binary.charAt(i) === '1') {\n      if (i === 6 && binary.charAt(5) === '1') set.push('5d')\n      else set.push(INTERVALS[i])\n    }\n  }\n  return tonic === false ? set : set.map(transpose(tonic))\n}\n\nmodule.exports = bs\n"
    },
    "name": "binarySet.toBinary",
    "params": [
      {
        "title": "param",
        "description": "a gamut",
        "lineNumber": 12,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the binary number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> binarySet = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'binary-set'</span>)\nbinarySet.toBinary(<span class=\"hljs-string\">'C2 E4 D3'</span>) <span class=\"hljs-comment\">// =&gt; '101010000000'</span>"
    ],
    "kind": "function",
    "memberof": "bs",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "binarySet.toBinary"
    ]
  },
  {
    "description": "A chord dictionary. Get chord data from a chord name.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "chord"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the chord name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "see",
        "description": "music-dictionary",
        "lineNumber": 7
      },
      {
        "title": "example",
        "description": "// get chord data\nvar chord = require('chord-dictionary')\nchord('Maj7') // => { name: 'Maj7', aliases: ['M7', 'maj7']\n               //      intervals:  [ ...],\n               //      binary: '100010010001', decimal: 2193 }",
        "lineNumber": 9
      },
      {
        "title": "example",
        "description": "// get it from aliases, binary or decimal numbers\nchord('Maj7') === chord('M7') === chord('100010010001') === chord(2913)",
        "lineNumber": 16
      },
      {
        "title": "example",
        "description": "// get chord names\nchord.names // => ['Maj7', 'm7', ...]",
        "lineNumber": 20
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 28,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 29,
          "column": 0
        },
        "end": {
          "line": 30,
          "column": 0
        }
      },
      "file": "./packages/chord-dictionary/index.js",
      "code": "'use strict'\n\nvar chords = require('./chords.json')\nvar dictionary = require('music-dictionary')\n\n/**\n * A chord dictionary. Get chord data from a chord name.\n *\n * @name chord\n * @function\n * @param {String} name - the chord name\n * @see music-dictionary\n *\n * @example\n * // get chord data\n * var chord = require('chord-dictionary')\n * chord('Maj7') // => { name: 'Maj7', aliases: ['M7', 'maj7']\n *                //      intervals:  [ ...],\n *                //      binary: '100010010001', decimal: 2193 }\n *\n * @example\n * // get it from aliases, binary or decimal numbers\n * chord('Maj7') === chord('M7') === chord('100010010001') === chord(2913)\n *\n * @example\n * // get chord names\n * chord.names // => ['Maj7', 'm7', ...]\n */\nmodule.exports = dictionary(chords)\n"
    },
    "name": "chord",
    "params": [
      {
        "title": "param",
        "description": "the chord name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "examples": [
      "<span class=\"hljs-comment\">// get chord data</span>\n<span class=\"hljs-keyword\">var</span> chord = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'chord-dictionary'</span>)\nchord(<span class=\"hljs-string\">'Maj7'</span>) <span class=\"hljs-comment\">// =&gt; { name: 'Maj7', aliases: ['M7', 'maj7']</span>\n               <span class=\"hljs-comment\">//      intervals:  [ ...],</span>\n               <span class=\"hljs-comment\">//      binary: '100010010001', decimal: 2193 }</span>",
      "<span class=\"hljs-comment\">// get it from aliases, binary or decimal numbers</span>\nchord(<span class=\"hljs-string\">'Maj7'</span>) === chord(<span class=\"hljs-string\">'M7'</span>) === chord(<span class=\"hljs-string\">'100010010001'</span>) === chord(<span class=\"hljs-number\">2913</span>)",
      "<span class=\"hljs-comment\">// get chord names</span>\nchord.names <span class=\"hljs-comment\">// =&gt; ['Maj7', 'm7', ...]</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "chord"
    ]
  },
  {
    "description": "Get the type of the chord (can be 'M', 'm', '7' or 'o' to represent major,\nminot, dominant and dimished respectively)\n\nIt assumes that the chord is not inversed (first note is always the tonic)\n\nIt detects major, minor, augmented, diminished and dominant chords. All\nchord notes beyond the 5th (except 7th for dominant chords) are ignored",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 9,
        "name": "chord.type"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 10,
        "name": null
      },
      {
        "title": "param",
        "description": "the chord notes",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "chord"
      },
      {
        "title": "returns",
        "description": "the chord type ('M', 'm', '7', 'dim', 'aug' or null)",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var chord = require('music.chord')\nchord.type('C E G') // => 'M'\nchord.type('C Eb G') // => 'm'\nchord.type('C Eb Gb') // => 'dim'\nchord.type('C E G#') // => 'aug'\nchord.type('C E G B') // => 'M'\nchord.type('C E G B7') // => '7'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 27,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 28,
          "column": 0
        },
        "end": {
          "line": 41,
          "column": 0
        }
      },
      "file": "./packages/chord-type/index.js",
      "code": "'use strict'\n\nvar G = require('music-gamut')\n\n/**\n * Get the type of the chord (can be 'M', 'm', '7' or 'o' to represent major,\n * minot, dominant and dimished respectively)\n *\n * It assumes that the chord is not inversed (first note is always the tonic)\n *\n * It detects major, minor, augmented, diminished and dominant chords. All\n * chord notes beyond the 5th (except 7th for dominant chords) are ignored\n *\n * @name chord.type\n * @function\n * @param {Array} chord - the chord notes\n * @return {String} the chord type ('M', 'm', '7', 'dim', 'aug' or null)\n *\n * @example\n * var chord = require('music.chord')\n * chord.type('C E G') // => 'M'\n * chord.type('C Eb G') // => 'm'\n * chord.type('C Eb Gb') // => 'dim'\n * chord.type('C E G#') // => 'aug'\n * chord.type('C E G B') // => 'M'\n * chord.type('C E G B7') // => '7'\n */\nmodule.exports = function (chord) {\n  var g = G.harmonizer(chord, false)\n  var steps = g.map(function (i) { return i ? i.charAt(0) : i })\n  if (steps[0] !== '1' || steps[2] !== '5') return null\n  if (g[1] === '3M') {\n    if (g[2] === '5A') return 'aug'\n    else return g[3] === '7m' ? '7' : 'M'\n  } else if (g[1] === '3m') {\n    return g[2] === '5P' ? 'm' : 'dim'\n  } else if (g[1] === '4P') {\n    return 'sus4'\n  }\n}\n"
    },
    "name": "chord.type",
    "params": [
      {
        "title": "param",
        "description": "the chord notes",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "chord"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the chord type ('M', 'm', '7', 'dim', 'aug' or null)",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> chord = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music.chord'</span>)\nchord.type(<span class=\"hljs-string\">'C E G'</span>) <span class=\"hljs-comment\">// =&gt; 'M'</span>\nchord.type(<span class=\"hljs-string\">'C Eb G'</span>) <span class=\"hljs-comment\">// =&gt; 'm'</span>\nchord.type(<span class=\"hljs-string\">'C Eb Gb'</span>) <span class=\"hljs-comment\">// =&gt; 'dim'</span>\nchord.type(<span class=\"hljs-string\">'C E G#'</span>) <span class=\"hljs-comment\">// =&gt; 'aug'</span>\nchord.type(<span class=\"hljs-string\">'C E G B'</span>) <span class=\"hljs-comment\">// =&gt; 'M'</span>\nchord.type(<span class=\"hljs-string\">'C E G B7'</span>) <span class=\"hljs-comment\">// =&gt; '7'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "chord.type"
    ]
  },
  {
    "description": "Create a musical dictionary. A musical dictionary is a function that given\na name (and optionally a tonic) returns an array of notes.\n\nA dictionary is created from a HashMap. It maps a name to a string with\nan interval list and, optionally, an alternative name list (see example)\n\nAdditionally, the dictionary has properties (see examples):\n\n- data: a hash with the dictionary data\n- names: an array with all the names\n- aliases: an array with all the names including aliases\n- source: the source of the dictionary\n\nEach value of the data hash have the following properties:\n\n- name: the name\n- aliases: an array with the alternative names\n- intervals: an array with the intervals\n- steps: an array with the intervals in __array notation__\n- binary: a binary representation of the set\n- decimal: the decimal representation of the set",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 23,
        "name": "dictionary"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 24,
        "name": null
      },
      {
        "title": "param",
        "description": "the dictionary source",
        "lineNumber": 26,
        "type": {
          "type": "NameExpression",
          "name": "Hash"
        },
        "name": "source"
      },
      {
        "title": "returns",
        "description": "the dictionary",
        "lineNumber": 27,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      },
      {
        "title": "example",
        "description": "var dictionary = require('music-dictionary')\nvar chords = dictionary({'Maj7': ['1 3 5 7', ['M7']], 'm7': ['1 3b 5 7b'] })\nchords('CMaj7') // => ['C', 'E', 'G', 'B']\nchords('DM7') // => ['D', 'F#', 'A', 'C#']\nchords('Bm7') // => ['B', 'D', 'F#', 'A']",
        "lineNumber": 29
      },
      {
        "title": "example",
        "description": "// dictionary data\nchords.data['M7'] // => { name: 'Maj7', aliases: ['M7'],\n                  //      intervals: ['1', '3', '5', '7'], steps: [ ...],\n                  //      binary: '10010010001', decimal: 2193 }\n\n// get chord by binary numbers\nchords.data['100010010001'] === chords.data['Maj7']\nchords.data[2193] === chords.data['Maj7']",
        "lineNumber": 36
      },
      {
        "title": "example",
        "description": "// available names\nchords.names // => ['Maj7', 'm7']\nchords.aliases // => ['Maj7', 'm7', 'M7']",
        "lineNumber": 46
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 7,
        "column": 0
      },
      "end": {
        "line": 56,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 57,
          "column": 0
        },
        "end": {
          "line": 72,
          "column": 0
        }
      },
      "file": "./packages/music-dictionary/index.js",
      "code": "'use strict'\n\nvar parse = require('array-notation/interval/parse')\nvar R = require('array-notation/note/regex')\nvar transpose = require('note-transpose')\n\n/**\n * Create a musical dictionary. A musical dictionary is a function that given\n * a name (and optionally a tonic) returns an array of notes.\n *\n * A dictionary is created from a HashMap. It maps a name to a string with\n * an interval list and, optionally, an alternative name list (see example)\n *\n * Additionally, the dictionary has properties (see examples):\n *\n * - data: a hash with the dictionary data\n * - names: an array with all the names\n * - aliases: an array with all the names including aliases\n * - source: the source of the dictionary\n *\n * Each value of the data hash have the following properties:\n *\n * - name: the name\n * - aliases: an array with the alternative names\n * - intervals: an array with the intervals\n * - steps: an array with the intervals in __array notation__\n * - binary: a binary representation of the set\n * - decimal: the decimal representation of the set\n *\n * @name dictionary\n * @function\n * @param {Hash} source - the dictionary source\n * @return {Function} the dictionary\n *\n * @example\n * var dictionary = require('music-dictionary')\n * var chords = dictionary({'Maj7': ['1 3 5 7', ['M7']], 'm7': ['1 3b 5 7b'] })\n * chords('CMaj7') // => ['C', 'E', 'G', 'B']\n * chords('DM7') // => ['D', 'F#', 'A', 'C#']\n * chords('Bm7') // => ['B', 'D', 'F#', 'A']\n *\n * @example\n * // dictionary data\n * chords.data['M7'] // => { name: 'Maj7', aliases: ['M7'],\n *                   //      intervals: ['1', '3', '5', '7'], steps: [ ...],\n *                   //      binary: '10010010001', decimal: 2193 }\n *\n * // get chord by binary numbers\n * chords.data['100010010001'] === chords.data['Maj7']\n * chords.data[2193] === chords.data['Maj7']\n *\n * @example\n * // available names\n * chords.names // => ['Maj7', 'm7']\n * chords.aliases // => ['Maj7', 'm7', 'M7']\n */\nmodule.exports = function (src) {\n  function dict (name, tonic) {\n    var v = dict.props(name)\n    if (!v) {\n      var n = R.exec(name)\n      v = n ? dict.props(n[5]) : null\n      if (!v) return []\n      tonic = tonic === false ? tonic : tonic || n[1] + n[2] + n[3]\n    }\n    if (tonic !== false && !tonic) return function (t) { return dict(name, t) }\n    return v.intervals.map(transpose(tonic))\n  }\n  return build(src, dict)\n}\n\nfunction build (src, dict) {\n  var data = {}\n  var names = Object.keys(src)\n  var aliases = names.slice()\n\n  dict.props = function (name) { return data[name] }\n  dict.names = function (a) { return (a ? aliases : names).slice() }\n\n  names.forEach(function (k) {\n    var d = src[k]\n    var c = { name: k, aliases: d[1] || [] }\n    c.intervals = d[0].split(' ')\n    c.steps = c.intervals.map(parse)\n    c.binary = binary([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], c.steps)\n    c.decimal = parseInt(c.binary, 2)\n    data[k] = data[c.binary] = data[c.decimal] = c\n    c.aliases.forEach(function (a) { data[a] = c })\n    if (c.aliases.length > 0) aliases = aliases.concat(c.aliases)\n  })\n  return dict\n}\n\nfunction binary (num, intervals) {\n  intervals.forEach(function (i) { num[(i[0] * 7 + i[1] * 12) % 12] = '1' })\n  return num.join('')\n}"
    },
    "name": "dictionary",
    "params": [
      {
        "title": "param",
        "description": "the dictionary source",
        "lineNumber": 26,
        "type": {
          "type": "NameExpression",
          "name": "Hash"
        },
        "name": "source"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the dictionary",
        "lineNumber": 27,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> dictionary = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-dictionary'</span>)\n<span class=\"hljs-keyword\">var</span> chords = dictionary({<span class=\"hljs-string\">'Maj7'</span>: [<span class=\"hljs-string\">'1 3 5 7'</span>, [<span class=\"hljs-string\">'M7'</span>]], <span class=\"hljs-string\">'m7'</span>: [<span class=\"hljs-string\">'1 3b 5 7b'</span>] })\nchords(<span class=\"hljs-string\">'CMaj7'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G', 'B']</span>\nchords(<span class=\"hljs-string\">'DM7'</span>) <span class=\"hljs-comment\">// =&gt; ['D', 'F#', 'A', 'C#']</span>\nchords(<span class=\"hljs-string\">'Bm7'</span>) <span class=\"hljs-comment\">// =&gt; ['B', 'D', 'F#', 'A']</span>",
      "<span class=\"hljs-comment\">// dictionary data</span>\nchords.data[<span class=\"hljs-string\">'M7'</span>] <span class=\"hljs-comment\">// =&gt; { name: 'Maj7', aliases: ['M7'],</span>\n                  <span class=\"hljs-comment\">//      intervals: ['1', '3', '5', '7'], steps: [ ...],</span>\n                  <span class=\"hljs-comment\">//      binary: '10010010001', decimal: 2193 }</span>\n\n<span class=\"hljs-comment\">// get chord by binary numbers</span>\nchords.data[<span class=\"hljs-string\">'100010010001'</span>] === chords.data[<span class=\"hljs-string\">'Maj7'</span>]\nchords.data[<span class=\"hljs-number\">2193</span>] === chords.data[<span class=\"hljs-string\">'Maj7'</span>]",
      "<span class=\"hljs-comment\">// available names</span>\nchords.names <span class=\"hljs-comment\">// =&gt; ['Maj7', 'm7']</span>\nchords.aliases <span class=\"hljs-comment\">// =&gt; ['Maj7', 'm7', 'M7']</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "dictionary"
    ]
  },
  {
    "description": "A gamut is a collection of intervals, pitch classes or notes.\nScales, chords, pitch sets are examples of gamuts.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "gamut"
      },
      {
        "title": "param",
        "description": "a list of elements",
        "lineNumber": 5,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the operation to perfom",
        "lineNumber": 6,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "operation"
      },
      {
        "title": "returns",
        "description": "a list of pitches",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var gamut = require('music-gamut')\ngamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 23,
        "column": 0
      },
      "end": {
        "line": 35,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 36,
          "column": 0
        },
        "end": {
          "line": 41,
          "column": 1
        }
      },
      "file": "./packages/music-gamut/index.js",
      "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
    },
    "name": "gamut",
    "params": [
      {
        "title": "param",
        "description": "a list of elements",
        "lineNumber": 5,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the operation to perfom",
        "lineNumber": 6,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "operation"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a list of pitches",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> gamut = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\ngamut(<span class=\"hljs-string\">'c2 bb fx blah'</span>) <span class=\"hljs-comment\">// =&gt; ['C2', 'Bb', 'F##', null]</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Decorate a function to work with gamuts.\n\nThe function to decorate receives an array of pitches in\n[array notation]()  and should return the desired transformed array.",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 6,
              "name": "gamut.operation"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 7,
              "name": null
            },
            {
              "title": "param",
              "description": "the function to decorate",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              },
              "name": "fn"
            },
            {
              "title": "returns",
              "description": "the decorated function",
              "lineNumber": 10,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              }
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 70,
              "column": 0
            },
            "end": {
              "line": 80,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 81,
                "column": 0
              },
              "end": {
                "line": 93,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.operation",
          "params": [
            {
              "title": "param",
              "description": "the function to decorate",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              },
              "name": "fn"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the decorated function",
              "lineNumber": 10,
              "type": {
                "type": "NameExpression",
                "name": "Function"
              }
            }
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.operation"
          ]
        },
        {
          "description": "Rotate the gamut",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "gamut.rotate"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "the number of rotations",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Integer"
              },
              "name": "count"
            },
            {
              "title": "param",
              "description": "a list of notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            },
            {
              "title": "returns",
              "description": "the gamut rotated count times",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var rotate = require('music.kit/gamut/rotate')\nrotate(1, 'C D E') // => ['D', 'E', 'C']",
              "lineNumber": 10
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 104,
              "column": 0
            },
            "end": {
              "line": 116,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 117,
                "column": 0
              },
              "end": {
                "line": 136,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.rotate",
          "params": [
            {
              "title": "param",
              "description": "the number of rotations",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "Integer"
              },
              "name": "count"
            },
            {
              "title": "param",
              "description": "a list of notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the gamut rotated count times",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> rotate = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music.kit/gamut/rotate'</span>)\nrotate(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'C D E'</span>) <span class=\"hljs-comment\">// =&gt; ['D', 'E', 'C']</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.rotate"
          ]
        },
        {
          "description": "Select some elements from a gamut",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "gamut.select"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "a __1-based__ index of the elements",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "numbers"
            },
            {
              "title": "param",
              "description": "the notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            },
            {
              "title": "returns",
              "description": "the selected elements",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var gamut = require('tonal.gamut')\ngamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']",
              "lineNumber": 10
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 142,
              "column": 0
            },
            "end": {
              "line": 154,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 155,
                "column": 0
              },
              "end": {
                "line": 177,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.select",
          "params": [
            {
              "title": "param",
              "description": "a __1-based__ index of the elements",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "numbers"
            },
            {
              "title": "param",
              "description": "the notes or intervals",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the selected elements",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> gamut = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'tonal.gamut'</span>)\ngamut.select(<span class=\"hljs-string\">'1 3 5'</span>, <span class=\"hljs-string\">'C D E F G A B'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'E', 'G']</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.select"
          ]
        },
        {
          "description": "Create a set: a set is a list of uniq pitch classes or simplified intervals\nin ascending pitch order",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 4,
              "name": "gamut.set"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 5,
              "name": null
            },
            {
              "title": "param",
              "description": "the note list",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "notes"
            },
            {
              "title": "returns",
              "description": "the set",
              "lineNumber": 8,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              }
            },
            {
              "title": "example",
              "description": "var set = require('tonal.gamut/set')\nset('E7 C2 e D5 c1') // => ['C', 'D', 'E']\nset('11 10 9') // => [ '2M', '3M', '4P' ]",
              "lineNumber": 10
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 163,
              "column": 0
            },
            "end": {
              "line": 176,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 177,
                "column": 0
              },
              "end": {
                "line": 185,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.set",
          "params": [
            {
              "title": "param",
              "description": "the note list",
              "lineNumber": 7,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "notes"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the set",
              "lineNumber": 8,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'tonal.gamut/set'</span>)\nset(<span class=\"hljs-string\">'E7 C2 e D5 c1'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'D', 'E']</span>\nset(<span class=\"hljs-string\">'11 10 9'</span>) <span class=\"hljs-comment\">// =&gt; [ '2M', '3M', '4P' ]</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.set"
          ]
        },
        {
          "description": "Get a gamut in ascdening pitch order",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 3,
              "name": "gamut.sort"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 4,
              "name": null
            },
            {
              "title": "param",
              "description": "the gamut to sort",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            },
            {
              "title": "returns",
              "description": "the gamut in sort pitch order",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var gamut = require('music-gamut')\ngamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']",
              "lineNumber": 9
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 124,
              "column": 0
            },
            "end": {
              "line": 135,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 136,
                "column": 0
              },
              "end": {
                "line": 155,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.sort",
          "params": [
            {
              "title": "param",
              "description": "the gamut to sort",
              "lineNumber": 6,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "gamut"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the gamut in sort pitch order",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> gamut = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\ngamut.sort(<span class=\"hljs-string\">'c5 d2 f4 D2'</span>) <span class=\"hljs-comment\">// =&gt; ['D2', 'D2', 'F4', 'C5']</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.sort"
          ]
        },
        {
          "description": "Convert a source to an array. If the source is an array, return it.\n\nAside from an array itself, the source can be a\nstring with elements separated by spaces, commas or bars (`|`) or a single\nelement that will be wrapped inside an array\n\nThis function __does not perform any transformation__ of the array elements.\nand __it always return an array, even if its empty__.",
          "tags": [
            {
              "title": "name",
              "description": null,
              "lineNumber": 10,
              "name": "gamut.split"
            },
            {
              "title": "function",
              "description": null,
              "lineNumber": 11,
              "name": null
            },
            {
              "title": "param",
              "description": "the source",
              "lineNumber": 13,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "source"
            },
            {
              "title": "returns",
              "description": "the source as array",
              "lineNumber": 14,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            },
            {
              "title": "example",
              "description": "var G = require('music-gamut')\nG.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\nG.split() // => []",
              "lineNumber": 16
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 43,
              "column": 0
            },
            "end": {
              "line": 62,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 63,
                "column": 0
              },
              "end": {
                "line": 81,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "gamut.split",
          "params": [
            {
              "title": "param",
              "description": "the source",
              "lineNumber": 13,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  },
                  {
                    "type": "NameExpression",
                    "name": "Array"
                  }
                ]
              },
              "name": "source"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the source as array",
              "lineNumber": 14,
              "type": {
                "type": "NameExpression",
                "name": "Array"
              }
            }
          ],
          "examples": [
            "<span class=\"hljs-keyword\">var</span> G = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-gamut'</span>)\nG.split(<span class=\"hljs-string\">'a | B C , Dmaj7'</span>) <span class=\"hljs-comment\">// =&gt; ['a', 'B', 'C', 'Dmaj7']</span>\nG.split() <span class=\"hljs-comment\">// =&gt; []</span>"
          ],
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "gamut.split"
          ]
        },
        {
          "description": "Create an harmonizer",
          "tags": [
            {
              "title": "name",
              "name": "harmonizer"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "gamut"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 90,
              "column": 0
            },
            "end": {
              "line": 92,
              "column": 3
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 93,
                "column": 0
              },
              "end": {
                "line": 117,
                "column": 0
              }
            },
            "file": "./packages/music-gamut/index.js",
            "code": "'use strict'\n\nvar parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar distanceTo = require('note-interval')\nvar transpose = require('note-transpose')\nvar SEP = /\\s*\\|\\s*|\\s*,\\s*|\\s+/\n\nvar toStr = function (s) { return Array.isArray(s) ? str(s) : s }\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction height (p) {\n  if (!p) return -Infinity\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n/**\n * A gamut is a collection of intervals, pitch classes or notes.\n * Scales, chords, pitch sets are examples of gamuts.\n *\n * @name gamut\n * @param {String|Array} source - a list of elements\n * @param {String|Function} operation - the operation to perfom\n * @return {Array} a list of pitches\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut('c2 bb fx blah') // => ['C2', 'Bb', 'F##', null]\n */\nfunction gamut (source, op) {\n  if (op === false) return gamut.harmonizer(source, false)\n  if (typeof op === 'function') return gamut.operation(op)(source)\n  var g = gamut.split(source)\n  return g.map(function (e) { return str(parse(e)) })\n}\n\n/**\n * Convert a source to an array. If the source is an array, return it.\n *\n * Aside from an array itself, the source can be a\n * string with elements separated by spaces, commas or bars (`|`) or a single\n * element that will be wrapped inside an array\n *\n * This function __does not perform any transformation__ of the array elements.\n * and __it always return an array, even if its empty__.\n *\n * @name gamut.split\n * @function\n * @param {String|Array} source - the source\n * @return {Array} the source as array\n *\n * @example\n * var G = require('music-gamut')\n * G.split('a | B C , Dmaj7') // => ['a', 'B', 'C', 'Dmaj7']\n * G.split() // => []\n */\ngamut.split = function (source) {\n  if (Array.isArray(source)) return source\n  else if (typeof source === 'string') return source.trim().split(SEP)\n  else if (source === null || typeof source === 'undefined') return []\n  else return [ source ]\n}\n\n/**\n * Decorate a function to work with gamuts.\n *\n * The function to decorate receives an array of pitches in\n * [array notation]()  and should return the desired transformed array.\n *\n * @name gamut.operation\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n */\ngamut.operation = function (fn) {\n  return function (source) {\n    var g = gamut.split(source)\n    if (Array.isArray(g[0])) return fn(g)\n    var v = fn(g.map(parse))\n    return Array.isArray(v) ? v.map(toStr) : v\n  }\n}\n\n/**\n * Create an harmonizer\n */\ngamut.harmonizer = function (source, tonic) {\n  if (arguments.length === 1) return function (t) { return gamut.harmonizer(source, t) }\n  return gamut.operation(function (g) {\n    var base = g[0]\n    var intervals = g.map(distanceTo(base))\n    if (tonic === false) return intervals\n    tonic = parse(tonic)\n    return intervals.map(transpose(tonic))\n  })(source)\n}\n\n/**\n * Rotate the gamut\n *\n * @name gamut.rotate\n * @function\n * @param {Integer} count - the number of rotations\n * @param {String|Array} gamut - a list of notes or intervals\n * @return {Array} the gamut rotated count times\n *\n * @example\n * var rotate = require('music.kit/gamut/rotate')\n * rotate(1, 'C D E') // => ['D', 'E', 'C']\n */\ngamut.rotate = function (count, source) {\n  var g = gamut.split(source)\n  var len = g.length\n  var n = ((count % len) + len) % len\n  return g.slice(n, len).concat(g.slice(0, n))\n}\n\n/**\n * Get a gamut in ascdening pitch order\n *\n * @name gamut.sort\n * @function\n * @param {String|Array} gamut - the gamut to sort\n * @return {Array} the gamut in sort pitch order\n *\n * @example\n * var gamut = require('music-gamut')\n * gamut.sort('c5 d2 f4 D2') // => ['D2', 'D2', 'F4', 'C5']\n */\ngamut.sort = gamut.operation(function (g) {\n  return g.sort(function (a, b) {\n    return height(a) - height(b)\n  })\n})\n\n/**\n * Select some elements from a gamut\n *\n * @name gamut.select\n * @function\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} gamut - the notes or intervals\n * @return {Array} the selected elements\n *\n * @example\n * var gamut = require('tonal.gamut')\n * gamut.select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n */\ngamut.select = function s (nums, src) {\n  if (arguments.length === 1) return function (g) { return s(nums, g) }\n  var g = gamut.split(src)\n  return gamut.split(nums).map(function (n) {\n    return g[n - 1]\n  })\n}\n\n/**\n * Create a set: a set is a list of uniq pitch classes or simplified intervals\n * in ascending pitch order\n *\n * @name gamut.set\n * @function\n * @param {String|Array} notes - the note list\n * @return {String|Array} the set\n *\n * @example\n * var set = require('tonal.gamut/set')\n * set('E7 C2 e D5 c1') // => ['C', 'D', 'E']\n * set('11 10 9') // => [ '2M', '3M', '4P' ]\n */\ngamut.set = gamut.operation(function (notes) {\n  var sorted = gamut.sort(notes.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n})\n\nif (typeof module === 'object' && module.exports) module.exports = gamut\nif (typeof window !== 'undefined') window.gamut = gamut\n"
          },
          "name": "harmonizer",
          "kind": "function",
          "memberof": "gamut",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "gamut",
            "harmonizer"
          ]
        }
      ]
    },
    "events": [],
    "path": [
      "gamut"
    ]
  },
  {
    "description": "Create a key from a string. A key is a string with a tonic and a mode",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey('C major') // => 'C major'\nkey('c Major') // => 'C major'\nkey('C') // => 'C major'\nkey('dbb miXolydian') // => 'Dbb mixolydian'",
        "lineNumber": 8
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 17,
        "column": 0
      },
      "end": {
        "line": 29,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 30,
          "column": 0
        },
        "end": {
          "line": 40,
          "column": 1
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transpose')\nvar interval = require('note-interval')\nvar parse = require('array-notation/note/parse')\nvar parseI = require('array-notation/interval/parse')\nvar str = require('array-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey(<span class=\"hljs-string\">'c Major'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey(<span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey(<span class=\"hljs-string\">'dbb miXolydian'</span>) <span class=\"hljs-comment\">// =&gt; 'Dbb mixolydian'</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key"
    ]
  },
  {
    "description": "Get the number of alterations of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.alteratons"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "the number of alterations or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.alterations('C major') // => 0\nkey.alterations('F major') // => -1\nkey.alterations('Eb major') // => -3\nkey.alterations('A major') // => 3\nkey.alterations('nonsense') // => null",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 107,
        "column": 0
      },
      "end": {
        "line": 122,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 123,
          "column": 0
        },
        "end": {
          "line": 144,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transpose')\nvar interval = require('note-interval')\nvar parse = require('array-notation/note/parse')\nvar parseI = require('array-notation/interval/parse')\nvar str = require('array-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.alteratons",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the number of alterations or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.alterations(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; 0</span>\nkey.alterations(<span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; -1</span>\nkey.alterations(<span class=\"hljs-string\">'Eb major'</span>) <span class=\"hljs-comment\">// =&gt; -3</span>\nkey.alterations(<span class=\"hljs-string\">'A major'</span>) <span class=\"hljs-comment\">// =&gt; 3</span>\nkey.alterations(<span class=\"hljs-string\">'nonsense'</span>) <span class=\"hljs-comment\">// =&gt; null</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.alteratons"
    ]
  },
  {
    "description": "Get a list of altered notes in the appropriate order",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.altered"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "an array with the altered notes ordered or an empty array\nif its not a valid key name",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "key.altered('F major') // => ['Bb']\nkey.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\nkey.altered('A major') // => ['F#', 'C#', 'G#']",
        "lineNumber": 10
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 149,
        "column": 0
      },
      "end": {
        "line": 162,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 163,
          "column": 0
        },
        "end": {
          "line": 187,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transpose')\nvar interval = require('note-interval')\nvar parse = require('array-notation/note/parse')\nvar parseI = require('array-notation/interval/parse')\nvar str = require('array-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.altered",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "an array with the altered notes ordered or an empty array\nif its not a valid key name",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "key.altered(<span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; ['Bb']</span>\nkey.altered(<span class=\"hljs-string\">'Eb major'</span>) <span class=\"hljs-comment\">// =&gt; ['Bb', 'Eb', 'Ab']</span>\nkey.altered(<span class=\"hljs-string\">'A major'</span>) <span class=\"hljs-comment\">// =&gt; ['F#', 'C#', 'G#']</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.altered"
    ]
  },
  {
    "description": "Get chords of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.chords"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "an array with the key chords",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "key.chords('C major') // => ['C', 'Dm', 'Em', 'F', 'G7', 'Am', 'Bo'\nkey.chords('major', false) // => ['C', 'Dm', ...]",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 7,
        "column": 0
      },
      "end": {
        "line": 18,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 19,
          "column": 0
        },
        "end": {
          "line": 24,
          "column": 0
        }
      },
      "file": "./packages/scale-chords/chords.js",
      "code": "'use strict'\n\nvar scale = require('./scale')\nvar chord = require('music-scale/chord')\nvar modes = require('music-scale/modes')\n\n/**\n * Get chords of a key\n *\n * @name key.chords\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the key chords\n *\n * @example\n * key.chords('C major') // => ['C', 'Dm', 'Em', 'F', 'G7', 'Am', 'Bo'\n * key.chords('major', false) // => ['C', 'Dm', ...]\n */\nmodule.exports = function (k) {\n  return modes(scale(k)).map(function (s) {\n    return chord(s)\n  })\n}\n"
    },
    "name": "key.chords",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "an array with the key chords",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "key.chords(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'Dm', 'Em', 'F', 'G7', 'Am', 'Bo'</span>\nkey.chords(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'Dm', ...]</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.chords"
    ]
  },
  {
    "description": "Parse a key name",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.parse"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "an array with the tonic and mode or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.parse('C major') // => ['C', 'major']\nkey.parse('fx MINOR') // => ['F##', 'minor']\nkey.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\nkey.parse('f bebop') // => 'null'",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 43,
        "column": 0
      },
      "end": {
        "line": 57,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 58,
          "column": 0
        },
        "end": {
          "line": 74,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transpose')\nvar interval = require('note-interval')\nvar parse = require('array-notation/note/parse')\nvar parseI = require('array-notation/interval/parse')\nvar str = require('array-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.parse",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "an array with the tonic and mode or null if not valid key",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.parse(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'major']</span>\nkey.parse(<span class=\"hljs-string\">'fx MINOR'</span>) <span class=\"hljs-comment\">// =&gt; ['F##', 'minor']</span>\nkey.parse(<span class=\"hljs-string\">'Ab mixolydian'</span>) <span class=\"hljs-comment\">// =&gt; ['Ab', 'mixolydian']</span>\nkey.parse(<span class=\"hljs-string\">'f bebop'</span>) <span class=\"hljs-comment\">// =&gt; 'null'</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.parse"
    ]
  },
  {
    "description": "Get a chord progression from within a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.progression"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the roman numerals",
        "lineNumber": 6,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "numerals"
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "key"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 10,
        "column": 0
      },
      "end": {
        "line": 17,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 18,
          "column": 0
        },
        "end": {
          "line": 30,
          "column": 0
        }
      },
      "file": "./packages/chord-progression/progression.js",
      "code": "'use strict'\n\nvar split = require('music-gamut/split')\nvar roman = require('array-notation/roman/parse')\nvar interval = require('array-notation/interval/parse')\nvar parse = require('./parse')\nvar chords = require('./chords')\nvar scale = require('./scale')\n\n/**\n * Get a chord progression from within a key\n *\n * @name key.progression\n * @function\n * @param {String|Array} numerals - the roman numerals\n * @param {String} key - the key name\n */\nmodule.exports = function (numerals, key) {\n  var k = parse(key)\n  if (!k || !k.tonic) return null\n  var s = scale(k.mode).map(interval)\n  var c = chords(key)\n  var degrees = split(numerals).map(roman)\n  return degrees.map(function (d) {\n    var i = indexOf(d[0], s)\n    return i < 0 ? null : c[i]\n  })\n}\n\nfunction indexOf (v, s) {\n  for (var i = 0; i < 7; i++) {\n    if (s[i][0] === v) return i\n  }\n  return -1\n}"
    },
    "name": "key.progression",
    "params": [
      {
        "title": "param",
        "description": "the roman numerals",
        "lineNumber": 6,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "numerals"
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "key"
      }
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.progression"
    ]
  },
  {
    "description": "Get relative of a key\n\nThis function is currified, so it can be partially applied (see examples)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "key.relative"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the name of the relative mode desired",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "relative"
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "key"
      },
      {
        "title": "returns",
        "description": "the relative key name or null if the key or the relative name\nare not valid",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.relative('minor', 'C major') // => 'A minor'\nkey.relative('major', 'A minor') // => 'C major'\nkey.relative('dorian', 'F major') // => 'G dorian'\n\n// partially application\nvar minorOf = key.relative('minor')\nminorOf('Bb major') // => 'G minor'",
        "lineNumber": 13
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 76,
        "column": 0
      },
      "end": {
        "line": 97,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 98,
          "column": 0
        },
        "end": {
          "line": 123,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transpose')\nvar interval = require('note-interval')\nvar parse = require('array-notation/note/parse')\nvar parseI = require('array-notation/interval/parse')\nvar str = require('array-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.relative",
    "params": [
      {
        "title": "param",
        "description": "the name of the relative mode desired",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "relative"
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "key"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the relative key name or null if the key or the relative name\nare not valid",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.relative(<span class=\"hljs-string\">'minor'</span>, <span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; 'A minor'</span>\nkey.relative(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-string\">'A minor'</span>) <span class=\"hljs-comment\">// =&gt; 'C major'</span>\nkey.relative(<span class=\"hljs-string\">'dorian'</span>, <span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; 'G dorian'</span>\n\n<span class=\"hljs-comment\">// partially application</span>\n<span class=\"hljs-keyword\">var</span> minorOf = key.relative(<span class=\"hljs-string\">'minor'</span>)\nminorOf(<span class=\"hljs-string\">'Bb major'</span>) <span class=\"hljs-comment\">// =&gt; 'G minor'</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.relative"
    ]
  },
  {
    "description": "Get the scale of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.scale"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.scale('C major') // => ['C', 'D', 'E', ...]",
        "lineNumber": 8
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 177,
        "column": 0
      },
      "end": {
        "line": 186,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 187,
          "column": 0
        },
        "end": {
          "line": 193,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transpose')\nvar interval = require('note-interval')\nvar parse = require('array-notation/note/parse')\nvar parseI = require('array-notation/interval/parse')\nvar str = require('array-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.scale",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.scale(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'D', 'E', ...]</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.scale"
    ]
  },
  {
    "description": "Get signature of a key",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 3,
        "name": "key.signature"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 4,
        "name": null
      },
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "returns",
        "description": "a string with the alterations",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var key = require('music-key')\nkey.signature('F major') // => 'b'\nkey.signature('Eb major') // => 'bbb'\nkey.signature('A major') // => '###'\nkey.signature('C major') // => ''\nkey.signature('nonsense') // => null",
        "lineNumber": 9
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "Key"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 128,
        "column": 0
      },
      "end": {
        "line": 143,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 144,
          "column": 0
        },
        "end": {
          "line": 163,
          "column": 0
        }
      },
      "file": "./packages/music-key/index.js",
      "code": "'use strict'\n\nvar transpose = require('note-transpose')\nvar interval = require('note-interval')\nvar parse = require('array-notation/note/parse')\nvar parseI = require('array-notation/interval/parse')\nvar str = require('array-notation/note/str')\n\nvar REGEX = /^#{1,7}|b{1,7}$/\nvar KEYS = { major: 1, minor: 6, ionian: 1, dorian: 2, phrygian: 3, lydian: 4,\n  mixolydian: 5, aeolian: 6, locrian: 7 }\nvar SCALES = [\n  '1 2 3 4 5 6 7', '1 2 3b 4 5 6 7b', '1 2b 3b 4 5 6b 7b', '1 2 3 4# 5 6 7',\n  '1 2 3 4 5 6 7b', '1 2 3b 4 5 6b 7b', '1 2b 3b 4 5b 6b 7b'\n].map(function (g) { return g.split(' ') })\n\n/**\n * Create a key from a string. A key is a string with a tonic and a mode\n *\n * @name key\n * @function\n *\n * @example\n * var key = require('music-key')\n * key('C major') // => 'C major'\n * key('c Major') // => 'C major'\n * key('C') // => 'C major'\n * key('dbb miXolydian') // => 'Dbb mixolydian'\n */\nfunction Key (str) {\n  if (/^-?\\d$/.exec(str)) {\n    return major(+str)\n  } else if (REGEX.exec(str)) {\n    var dir = str[0] === 'b' ? -1 : 1\n    return major(str.length * dir)\n  } else {\n    var p = Key.parse(str)\n    return p ? p.tonic + ' ' + p.mode : null\n  }\n}\nfunction major (n) { return transpose('C', [n, 0]) + ' major' }\n\n/**\n * Parse a key name\n *\n * @name key.parse\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the tonic and mode or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.parse('C major') // => ['C', 'major']\n * key.parse('fx MINOR') // => ['F##', 'minor']\n * key.parse('Ab mixolydian') // => ['Ab', 'mixolydian']\n * key.parse('f bebop') // => 'null'\n */\nKey.parse = function (name) {\n  var m, s, t\n  if (!name) return null\n  s = name.trim().split(/\\s+/)\n  t = str(parse((s[0])))\n  if (s.length === 1) {\n    m = s[0].toLowerCase()\n    if (KEYS[m]) return k(null, m)\n    else if (t) return k(t, 'major')\n    else return null\n  }\n  m = s[1].toLowerCase()\n  if (t && KEYS[m]) return k(t, m)\n  return null\n}\n\nfunction k (t, m) { return {tonic: t || false, mode: m, alt: KEYS[m]} }\n\n/**\n * Get relative of a key\n *\n * This function is currified, so it can be partially applied (see examples)\n *\n * @name key.relative\n * @function\n * @param {String} relative - the name of the relative mode desired\n * @param {String} key - the key name\n * @return {String} the relative key name or null if the key or the relative name\n * are not valid\n *\n * @example\n * var key = require('music-key')\n * key.relative('minor', 'C major') // => 'A minor'\n * key.relative('major', 'A minor') // => 'C major'\n * key.relative('dorian', 'F major') // => 'G dorian'\n *\n * // partially application\n * var minorOf = key.relative('minor')\n * minorOf('Bb major') // => 'G minor'\n */\nKey.relative = function (rel, key) {\n  if (arguments.length === 1) return function (k) { return Key.relative(rel, k) }\n  var k = Key.parse(key)\n  var r = Key.parse(rel)\n  if (!k || !k.tonic || !r) return null\n  var major = k.mode === 'major' ? k.tonic : transpose(k.tonic, '-' + k.alt)\n  return r.mode === 'major' ? major + ' major' : transpose(major, '' + r.alt) + ' ' + rel\n}\n\n/**\n * Get the number of alterations of a key\n *\n * @name key.alteratons\n * @function\n * @param {String} name - the key name\n * @return {Integer} the number of alterations or null if not valid key\n *\n * @example\n * var key = require('music-key')\n * key.alterations('C major') // => 0\n * key.alterations('F major') // => -1\n * key.alterations('Eb major') // => -3\n * key.alterations('A major') // => 3\n * key.alterations('nonsense') // => null\n */\nKey.alterations = function (key) {\n  var k = Key.relative('major', key)\n  return k ? parseI(interval('C', k.split(' ')[0]))[0] : null\n}\n\n/**\n * Get signature of a key\n *\n * @name key.signature\n * @function\n * @param {String} name - the key name\n * @return {String} a string with the alterations\n *\n * @example\n * var key = require('music-key')\n * key.signature('F major') // => 'b'\n * key.signature('Eb major') // => 'bbb'\n * key.signature('A major') // => '###'\n * key.signature('C major') // => ''\n * key.signature('nonsense') // => null\n */\nKey.signature = function (key) {\n  var n = Key.alterations(key)\n  return n !== null ? new Array(Math.abs(n) + 1).join(n < 0 ? 'b' : '#') : null\n}\n\n/**\n * Get a list of altered notes in the appropriate order\n *\n * @name key.altered\n * @function\n * @param {String} name - the key name\n * @return {Array} an array with the altered notes ordered or an empty array\n * if its not a valid key name\n *\n * @example\n * key.altered('F major') // => ['Bb']\n * key.altered('Eb major') // => ['Bb', 'Eb', 'Ab']\n * key.altered('A major') // => ['F#', 'C#', 'G#']\n */\nKey.altered = function (k) {\n  var a = Key.alterations(k)\n  if (a === null) return null\n  var notes = []\n  var tonic = a > 0 ? 'B' : 'F'\n  var interval = a > 0 ? [1, 0] : [-1, 0]\n  var l = Math.abs(a)\n  for (var i = 0; i < l; i++) {\n    tonic = transpose(tonic, interval)\n    notes.push(tonic)\n  }\n  return notes\n}\n\n/**\n * Get the scale of a key\n *\n * @name key.scale\n * @function\n *\n * @example\n * var key = require('music-key')\n * key.scale('C major') // => ['C', 'D', 'E', ...]\n */\nKey.scale = function (name) {\n  var k = Key.parse(name)\n  if (!k) return []\n  return SCALES[k.alt - 1].map(transpose(k.tonic))\n}\n\nmodule.exports = Key\n"
    },
    "name": "key.signature",
    "params": [
      {
        "title": "param",
        "description": "the key name",
        "lineNumber": 6,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "a string with the alterations",
        "lineNumber": 7,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'music-key'</span>)\nkey.signature(<span class=\"hljs-string\">'F major'</span>) <span class=\"hljs-comment\">// =&gt; 'b'</span>\nkey.signature(<span class=\"hljs-string\">'Eb major'</span>) <span class=\"hljs-comment\">// =&gt; 'bbb'</span>\nkey.signature(<span class=\"hljs-string\">'A major'</span>) <span class=\"hljs-comment\">// =&gt; '###'</span>\nkey.signature(<span class=\"hljs-string\">'C major'</span>) <span class=\"hljs-comment\">// =&gt; ''</span>\nkey.signature(<span class=\"hljs-string\">'nonsense'</span>) <span class=\"hljs-comment\">// =&gt; null</span>"
    ],
    "kind": "function",
    "memberof": "Key",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "key.signature"
    ]
  },
  {
    "description": "Get the midi number of a note\n\nIf the argument passed to this function is a valid midi number, it returns it\n\nThe note can be an string in scientific notation or\n[array pitch notation](https://github.com/danigb/music.array.notation)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 8,
        "name": "midi"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 9,
        "name": null
      },
      {
        "title": "param",
        "description": "the note in string or array notation.\nIf the parameter is a valid midi number it return it as it.",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Integer"
            }
          ]
        },
        "name": "note"
      },
      {
        "title": "returns",
        "description": "the midi number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      },
      {
        "title": "example",
        "description": "var midi = require('note-midi')\nmidi('A4') // => 69\nmidi('a3') // => 57\nmidi([0, 2]) // => 36 (C2 in array notation)\nmidi(60) // => 60",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 25,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 26,
          "column": 0
        },
        "end": {
          "line": 32,
          "column": 1
        }
      },
      "file": "./packages/note-midi/index.js",
      "code": "'use strict'\n\nvar parse = require('array-notation/note/parse')\n\n/**\n * Get the midi number of a note\n *\n * If the argument passed to this function is a valid midi number, it returns it\n *\n * The note can be an string in scientific notation or\n * [array pitch notation](https://github.com/danigb/music.array.notation)\n *\n * @name midi\n * @function\n * @param {String|Array|Integer} note - the note in string or array notation.\n * If the parameter is a valid midi number it return it as it.\n * @return {Integer} the midi number\n *\n * @example\n * var midi = require('note-midi')\n * midi('A4') // => 69\n * midi('a3') // => 57\n * midi([0, 2]) // => 36 (C2 in array notation)\n * midi(60) // => 60\n */\nfunction midi (note) {\n  if ((typeof note === 'number' || typeof note === 'string') &&\n    note > 0 && note < 128) return +note\n  var p = Array.isArray(note) ? note : parse(note)\n  if (!p || p.length < 2) return null\n  return p[0] * 7 + p[1] * 12 + 12\n}\n\nif (typeof module === 'object' && module.exports) module.exports = midi\nif (typeof window !== 'undefined') window.midi = midi\n"
    },
    "name": "midi",
    "params": [
      {
        "title": "param",
        "description": "the note in string or array notation.\nIf the parameter is a valid midi number it return it as it.",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Integer"
            }
          ]
        },
        "name": "note"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the midi number",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> midi = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-midi'</span>)\nmidi(<span class=\"hljs-string\">'A4'</span>) <span class=\"hljs-comment\">// =&gt; 69</span>\nmidi(<span class=\"hljs-string\">'a3'</span>) <span class=\"hljs-comment\">// =&gt; 57</span>\nmidi([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// =&gt; 36 (C2 in array notation)</span>\nmidi(<span class=\"hljs-number\">60</span>) <span class=\"hljs-comment\">// =&gt; 60</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "midi"
    ]
  },
  {
    "description": "Get the pitch frequency in herzs (with custom concert tuning) from a midi number\n\nThis function is currified so it can be partially applied (see examples)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "midi.freq"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the frequency of A4 (null means 440)",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        },
        "name": "tuning"
      },
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      },
      {
        "title": "returns",
        "description": "the frequency of the note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        }
      },
      {
        "title": "example",
        "description": "var freq = require('midi-freq')\n// 69 midi is A4\nfreq(null, 69) // => 440\nfreq(444, 69) // => 444",
        "lineNumber": 12
      },
      {
        "title": "example",
        "description": "// partially applied\nvar freq = require('midi-freq')(440)\nfreq(69) // => 440",
        "lineNumber": 18
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 22,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 23,
          "column": 0
        },
        "end": {
          "line": 31,
          "column": 0
        }
      },
      "file": "./packages/midi-freq/index.js",
      "code": "module.exports = function freq (tuning, midi) {\n  tuning = tuning || 440\n  if (arguments.length > 1) return freq(tuning)(midi)\n\n  return function (m) {\n    return m > 0 && m < 128 ? Math.pow(2, (m - 69) / 12) * tuning : null\n  }\n}\n"
    },
    "name": "midi.freq",
    "params": [
      {
        "title": "param",
        "description": "the frequency of A4 (null means 440)",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        },
        "name": "tuning"
      },
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 9,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the frequency of the note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "Float"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> freq = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'midi-freq'</span>)\n<span class=\"hljs-comment\">// 69 midi is A4</span>\nfreq(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 440</span>\nfreq(<span class=\"hljs-number\">444</span>, <span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 444</span>",
      "<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> freq = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'midi-freq'</span>)(<span class=\"hljs-number\">440</span>)\nfreq(<span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 440</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "midi.freq"
    ]
  },
  {
    "description": "Get the note name (in scientific notation) of the given midi number\n\nIt uses MIDI's [Tuning Standard](https://en.wikipedia.org/wiki/MIDI_Tuning_Standard)\nwhere A4 is 69\n\nThis method doesn't take into account diatonic spelling. Always the same\npitch class is given for the same midi number.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 9,
        "name": "midi.note"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 10,
        "name": null
      },
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      },
      {
        "title": "returns",
        "description": "the pitch",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var note = require('midi-note')\nnote(69) // => 'A4'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 22,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 23,
          "column": 0
        },
        "end": {
          "line": 29,
          "column": 0
        }
      },
      "file": "./packages/midi-note/index.js",
      "code": "'use strict'\n\nvar CHROMATIC = [ 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B' ]\n\n/**\n * Get the note name (in scientific notation) of the given midi number\n *\n * It uses MIDI's [Tuning Standard](https://en.wikipedia.org/wiki/MIDI_Tuning_Standard)\n * where A4 is 69\n *\n * This method doesn't take into account diatonic spelling. Always the same\n * pitch class is given for the same midi number.\n *\n * @name midi.note\n * @function\n * @param {Integer} midi - the midi number\n * @return {String} the pitch\n *\n * @example\n * var note = require('midi-note')\n * note(69) // => 'A4'\n */\nmodule.exports = function (midi) {\n  if (isNaN(midi) || midi < 0 || midi > 127) return null\n  var name = CHROMATIC[midi % 12]\n  var oct = Math.floor(midi / 12) - 1\n  return name + oct\n}\n"
    },
    "name": "midi.note",
    "params": [
      {
        "title": "param",
        "description": "the midi number",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Integer"
        },
        "name": "midi"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the pitch",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> note = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'midi-note'</span>)\nnote(<span class=\"hljs-number\">69</span>) <span class=\"hljs-comment\">// =&gt; 'A4'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "midi.note"
    ]
  },
  {
    "description": "Get the interval between two pitches\n\nIf one or both are pitch classes, a simple ascending interval is returned\n\nThis function can be partially applied (see examples)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 7,
        "name": "note.interval"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 8,
        "name": null
      },
      {
        "title": "param",
        "description": "the first note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "from"
      },
      {
        "title": "param",
        "description": "the second note",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "to"
      },
      {
        "title": "returns",
        "description": "the interval between them",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "example",
        "description": "var interval = require('note-interval')\ninterval('C2', 'D3') // => '9M'\ninterval('D2', 'C2') // => '-2M'\ninterval('D', 'C') // => '7m'",
        "lineNumber": 14
      },
      {
        "title": "example",
        "description": "// partially applied\nvar fromC = interval('C')\nfromC('D') // => '2M'",
        "lineNumber": 20
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 28,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 29,
          "column": 0
        },
        "end": {
          "line": 37,
          "column": 0
        }
      },
      "file": "./packages/note-interval/index.js",
      "code": "var parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar notation = require('array-notation/operation')(parse, str)\n\n/**\n * Get the interval between two pitches\n *\n * If one or both are pitch classes, a simple ascending interval is returned\n *\n * This function can be partially applied (see examples)\n *\n * @name note.interval\n * @function\n * @param {String} from - the first note\n * @param {String} to - the second note\n * @return {String} the interval between them\n *\n * @example\n * var interval = require('note-interval')\n * interval('C2', 'D3') // => '9M'\n * interval('D2', 'C2') // => '-2M'\n * interval('D', 'C') // => '7m'\n *\n * @example\n * // partially applied\n * var fromC = interval('C')\n * fromC('D') // => '2M'\n */\nmodule.exports = notation(function (a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) return null\n  if (a.length === 1 || b.length === 1) {\n    var base = b[0] - a[0]\n    return [base, -Math.floor(base * 7 / 12)]\n  }\n  return [b[0] - a[0], b[1] - a[1]]\n})\n"
    },
    "name": "note.interval",
    "params": [
      {
        "title": "param",
        "description": "the first note",
        "lineNumber": 10,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "from"
      },
      {
        "title": "param",
        "description": "the second note",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "to"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the interval between them",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> interval = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-interval'</span>)\ninterval(<span class=\"hljs-string\">'C2'</span>, <span class=\"hljs-string\">'D3'</span>) <span class=\"hljs-comment\">// =&gt; '9M'</span>\ninterval(<span class=\"hljs-string\">'D2'</span>, <span class=\"hljs-string\">'C2'</span>) <span class=\"hljs-comment\">// =&gt; '-2M'</span>\ninterval(<span class=\"hljs-string\">'D'</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; '7m'</span>",
      "<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> fromC = interval(<span class=\"hljs-string\">'C'</span>)\nfromC(<span class=\"hljs-string\">'D'</span>) <span class=\"hljs-comment\">// =&gt; '2M'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.interval"
    ]
  },
  {
    "description": "Transpose a note by an interval.\n\nThis function is currified. The order of the parameters is indifferent.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "note.transpose"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the interval. If its false, the note is not\ntransposed.",
        "lineNumber": 8,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "interval"
      },
      {
        "title": "param",
        "description": "the note to transpose",
        "lineNumber": 10,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "note"
      },
      {
        "title": "returns",
        "description": "the note transposed",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        }
      },
      {
        "title": "example",
        "description": "var transpose = require('note-transpose')\ntranspose('3m', 'C4') // => 'Eb4'\ntranspose('C4', '3m') // => 'Eb4'\ntranpose([1, 0, 2], [3, -1, 0]) // => [3, 0, 2]\n['C', 'D', 'E'].map(transpose('3M')) // => ['E', 'F#', 'G#']",
        "lineNumber": 13
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 5,
        "column": 0
      },
      "end": {
        "line": 23,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 24,
          "column": 0
        },
        "end": {
          "line": 32,
          "column": 0
        }
      },
      "file": "./packages/note-transpose/index.js",
      "code": "var parse = require('array-notation/pitch/parse')\nvar str = require('array-notation/pitch/str')\nvar operation = require('array-notation/operation')(parse, str)\n\n/**\n * Transpose a note by an interval.\n *\n * This function is currified. The order of the parameters is indifferent.\n *\n * @name note.transpose\n * @function\n * @param {String|Array} interval - the interval. If its false, the note is not\n * transposed.\n * @param {String|Array} note - the note to transpose\n * @return {String|Array} the note transposed\n *\n * @example\n * var transpose = require('note-transpose')\n * transpose('3m', 'C4') // => 'Eb4'\n * transpose('C4', '3m') // => 'Eb4'\n * tranpose([1, 0, 2], [3, -1, 0]) // => [3, 0, 2]\n * ['C', 'D', 'E'].map(transpose('3M')) // => ['E', 'F#', 'G#']\n */\nvar transpose = operation(function (i, n) {\n  if (i === false) return n\n  else if (!Array.isArray(i) || !Array.isArray(n)) return null\n  else if (i.length === 1 || n.length === 1) return [n[0] + i[0]]\n  var d = i.length === 2 && n.length === 2 ? null : n[2] || i[2]\n  return [n[0] + i[0], n[1] + i[1], d]\n})\n\nif (typeof module === 'object' && module.exports) module.exports = transpose\nif (typeof window !== 'undefined') window.transpose = transpose\n"
    },
    "name": "note.transpose",
    "params": [
      {
        "title": "param",
        "description": "the interval. If its false, the note is not\ntransposed.",
        "lineNumber": 8,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "interval"
      },
      {
        "title": "param",
        "description": "the note to transpose",
        "lineNumber": 10,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        },
        "name": "note"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the note transposed",
        "lineNumber": 11,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            }
          ]
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> transpose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'note-transpose'</span>)\ntranspose(<span class=\"hljs-string\">'3m'</span>, <span class=\"hljs-string\">'C4'</span>) <span class=\"hljs-comment\">// =&gt; 'Eb4'</span>\ntranspose(<span class=\"hljs-string\">'C4'</span>, <span class=\"hljs-string\">'3m'</span>) <span class=\"hljs-comment\">// =&gt; 'Eb4'</span>\ntranpose([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>]) <span class=\"hljs-comment\">// =&gt; [3, 0, 2]</span>\n[<span class=\"hljs-string\">'C'</span>, <span class=\"hljs-string\">'D'</span>, <span class=\"hljs-string\">'E'</span>].map(transpose(<span class=\"hljs-string\">'3M'</span>)) <span class=\"hljs-comment\">// =&gt; ['E', 'F#', 'G#']</span>"
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "note.transpose"
    ]
  },
  {
    "description": "Decorate a function to work with intervals, notes or pitches in\n[array notation](https://github.com/danigb/tonal/tree/next/packages/array-notation)\nwith independence of string representations.\n\nThis is the base of the pluggable notation system of\n[tonal](https://github.com/danigb/tonal)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 8,
        "name": "operation"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 9,
        "name": null
      },
      {
        "title": "param",
        "description": "the parser",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "parse"
      },
      {
        "title": "param",
        "description": "the string builder",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "str"
      },
      {
        "title": "param",
        "description": "the operation to decorate",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "fn"
      },
      {
        "title": "example",
        "description": "var parse = require('array-notation/interval/parse')\nvar str = require('array-notation/interval/str')\nvar operation = require('array-notation/operation')(parse, str)\nvar add = operation(function(a, b) { return [a[0] + b[0], a[1] + b[1]] })\nadd('3m', '3M') // => '5P'",
        "lineNumber": 15
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 11,
        "column": 0
      },
      "end": {
        "line": 31,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 32,
          "column": 0
        },
        "end": {
          "line": 42,
          "column": 0
        }
      },
      "file": "./packages/array-notation/operation.js",
      "code": "'use strict'\n\nfunction curry (fn, arity) {\n  if (arity === 1) return fn\n  return function (a, b) {\n    if (arguments.length === 1) return function (c) { return fn(a, c) }\n    return fn(a, b)\n  }\n}\n\n/**\n * Decorate a function to work with intervals, notes or pitches in\n * [array notation](https://github.com/danigb/tonal/tree/next/packages/array-notation)\n * with independence of string representations.\n *\n * This is the base of the pluggable notation system of\n * [tonal](https://github.com/danigb/tonal)\n *\n * @name operation\n * @function\n * @param {Function} parse - the parser\n * @param {Function} str - the string builder\n * @param {Function} fn - the operation to decorate\n *\n * @example\n * var parse = require('array-notation/interval/parse')\n * var str = require('array-notation/interval/str')\n * var operation = require('array-notation/operation')(parse, str)\n * var add = operation(function(a, b) { return [a[0] + b[0], a[1] + b[1]] })\n * add('3m', '3M') // => '5P'\n */\nmodule.exports = function op (parse, str, fn) {\n  if (arguments.length === 2) return function (f) { return op(parse, str, f) }\n  return curry(function (a, b) {\n    var ac = parse(a)\n    var bc = parse(b)\n    if (!ac && !bc) return fn(a, b)\n    var v = fn(ac || a, bc || b)\n    return str(v) || v\n  }, fn.length)\n}\n"
    },
    "name": "operation",
    "params": [
      {
        "title": "param",
        "description": "the parser",
        "lineNumber": 11,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "parse"
      },
      {
        "title": "param",
        "description": "the string builder",
        "lineNumber": 12,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "str"
      },
      {
        "title": "param",
        "description": "the operation to decorate",
        "lineNumber": 13,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "fn"
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> parse = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'array-notation/interval/parse'</span>)\n<span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'array-notation/interval/str'</span>)\n<span class=\"hljs-keyword\">var</span> operation = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'array-notation/operation'</span>)(parse, str)\n<span class=\"hljs-keyword\">var</span> add = operation(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) </span>{ <span class=\"hljs-keyword\">return</span> [a[<span class=\"hljs-number\">0</span>] + b[<span class=\"hljs-number\">0</span>], a[<span class=\"hljs-number\">1</span>] + b[<span class=\"hljs-number\">1</span>]] })\nadd(<span class=\"hljs-string\">'3m'</span>, <span class=\"hljs-string\">'3M'</span>) <span class=\"hljs-comment\">// =&gt; '5P'</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "operation"
    ]
  },
  {
    "description": "Create a pitch set from a gamut and (optional) a tonic. A pitch set is a\ncollection of uniq notes or intervals sorted by frequency\n\nA source can be a list of intervals or notes.\n\nThe tonic can be a note (with or without octave), false to get the scale\nintervals or null to set the first note of the source as tonic\n\nThis function is currified, so you can partially apply the function passing\none parameter instead of two (see example)",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 12,
        "name": "pitchSet"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 13,
        "name": null
      },
      {
        "title": "param",
        "description": "the list of intervals or notes",
        "lineNumber": 15,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the scale",
        "lineNumber": 16,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "returns",
        "description": "the list of notes",
        "lineNumber": 17,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      },
      {
        "title": "example",
        "description": "var set = require('pitch-set')\n\n// uses first note of the source as tonic\nset('d2 c4 e3 f g6 a B c d5 e', null) // => ['D', 'E', 'F', 'G', 'A', 'B', 'C']\n\n// create scales\nset('1 2 3 5 6', 'G') // => ['G', 'A', 'B', 'D', 'E']\nset('1 2 3 5 6', false) // => ['1P', '2M', '3M', '5P', '6M']\n\n// partially applied\nvar dorian = set('D E F G A B C')\ndorian('C4') // => ['C4', 'D4', 'Eb4', 'F4', 'G4', 'A4', 'Bb4']",
        "lineNumber": 19
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 7,
        "column": 0
      },
      "end": {
        "line": 38,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 39,
          "column": 0
        },
        "end": {
          "line": 52,
          "column": 0
        }
      },
      "file": "./packages/pitch-set/index.js",
      "code": "'use strict'\n\nvar G = require('music-gamut')\nvar transpose = require('note-transpose')\nvar distanceTo = require('note-interval')\n\n/**\n * Create a pitch set from a gamut and (optional) a tonic. A pitch set is a\n * collection of uniq notes or intervals sorted by frequency\n *\n * A source can be a list of intervals or notes.\n\n * The tonic can be a note (with or without octave), false to get the scale\n * intervals or null to set the first note of the source as tonic\n *\n * This function is currified, so you can partially apply the function passing\n * one parameter instead of two (see example)\n *\n * @name pitchSet\n * @function\n * @param {Array} source - the list of intervals or notes\n * @param {String} tonic - the tonic of the scale\n * @return {Array} the list of notes\n *\n * @example\n * var set = require('pitch-set')\n\n * // uses first note of the source as tonic\n * set('d2 c4 e3 f g6 a B c d5 e', null) // => ['D', 'E', 'F', 'G', 'A', 'B', 'C']\n *\n * // create scales\n * set('1 2 3 5 6', 'G') // => ['G', 'A', 'B', 'D', 'E']\n * set('1 2 3 5 6', false) // => ['1P', '2M', '3M', '5P', '6M']\n *\n * // partially applied\n * var dorian = set('D E F G A B C')\n * dorian('C4') // => ['C4', 'D4', 'Eb4', 'F4', 'G4', 'A4', 'Bb4']\n */\nmodule.exports = function pitchSet (source, tonic) {\n  if (arguments.length === 1) return function (t) { return pitchSet(source, t) }\n  return G(source, function (gamut) {\n    var uniq = set(gamut)\n    if (uniq.length === 0) return uniq\n    var ordered = uniq[0].length !== 2 ? order(gamut[0], uniq) : uniq\n    if (tonic === null) return ordered\n    var intervals = ordered.map(distanceTo(ordered[0]))\n    if (tonic === false) return intervals\n    return intervals.map(transpose(tonic))\n  })\n}\n\nfunction simplify (p) {\n  return p.length === 2 ? [p[0], -Math.floor(p[0] * 7 / 12)] : [p[0]]\n}\nfunction equal (a, b) {\n  return a[0] === b[0] && a[1] === b[1]\n}\nfunction indexOf (p, g, l) {\n  for (var i = 0; i < l; i++) {\n    if (g[i][0] === p) return i\n  }\n}\n\nfunction order (first, uniq) {\n  var len = uniq.length\n  var firstNdx = indexOf(first[0], uniq, len)\n  return uniq.slice(firstNdx, len).concat(uniq.slice(0, firstNdx))\n}\n\nfunction set (gamut) {\n  var sorted = G.sort(gamut.map(simplify))\n  return sorted.reduce(function (uniq, value, index) {\n    if (index === 0 || !equal(sorted[index - 1], value)) uniq.push(value)\n    return uniq\n  }, [])\n}"
    },
    "name": "pitchSet",
    "params": [
      {
        "title": "param",
        "description": "the list of intervals or notes",
        "lineNumber": 15,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the tonic of the scale",
        "lineNumber": 16,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the list of notes",
        "lineNumber": 17,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'pitch-set'</span>)\n\n<span class=\"hljs-comment\">// uses first note of the source as tonic</span>\nset(<span class=\"hljs-string\">'d2 c4 e3 f g6 a B c d5 e'</span>, <span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// =&gt; ['D', 'E', 'F', 'G', 'A', 'B', 'C']</span>\n\n<span class=\"hljs-comment\">// create scales</span>\nset(<span class=\"hljs-string\">'1 2 3 5 6'</span>, <span class=\"hljs-string\">'G'</span>) <span class=\"hljs-comment\">// =&gt; ['G', 'A', 'B', 'D', 'E']</span>\nset(<span class=\"hljs-string\">'1 2 3 5 6'</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; ['1P', '2M', '3M', '5P', '6M']</span>\n\n<span class=\"hljs-comment\">// partially applied</span>\n<span class=\"hljs-keyword\">var</span> dorian = set(<span class=\"hljs-string\">'D E F G A B C'</span>)\ndorian(<span class=\"hljs-string\">'C4'</span>) <span class=\"hljs-comment\">// =&gt; ['C4', 'D4', 'Eb4', 'F4', 'G4', 'A4', 'Bb4']</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "pitchSet"
    ]
  },
  {
    "description": "A scale dictionary. Get scale from a scale name and a tonic.\n\nThe dictionary has a `names` property with all scale names.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 5,
        "name": "scale"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 6,
        "name": null
      },
      {
        "title": "param",
        "description": "the scale name",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      },
      {
        "title": "see",
        "description": "music-dictionary",
        "lineNumber": 9
      },
      {
        "title": "example",
        "description": "// get scale data\nvar scale = require('scale-dictionary')\nscale('Ab major') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\nscale('major', 'Ab') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\n// get scale intervals\nscale('major', false) // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]",
        "lineNumber": 11
      },
      {
        "title": "example",
        "description": "// get it from aliases, binary or decimal numbers\nscale('major') === scale('ionian') === scale('101011010101') === scale(2773)",
        "lineNumber": 19
      },
      {
        "title": "example",
        "description": "// get scale names\nscale.names // => ['major', 'dorian', ...]",
        "lineNumber": 23
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 6,
        "column": 0
      },
      "end": {
        "line": 31,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 32,
          "column": 0
        },
        "end": {
          "line": 33,
          "column": 0
        }
      },
      "file": "./packages/scale-dictionary/index.js",
      "code": "'use strict'\n\nvar scales = require('./scales.json')\nvar dictionary = require('music-dictionary')\n\n/**\n * A scale dictionary. Get scale from a scale name and a tonic.\n *\n * The dictionary has a `names` property with all scale names.\n *\n * @name scale\n * @function\n * @param {String} name - the scale name\n * @see music-dictionary\n *\n * @example\n * // get scale data\n * var scale = require('scale-dictionary')\n * scale('Ab major') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\n * scale('major', 'Ab') // => [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]\n * // get scale intervals\n * scale('major', false) // => [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]\n *\n * @example\n * // get it from aliases, binary or decimal numbers\n * scale('major') === scale('ionian') === scale('101011010101') === scale(2773)\n *\n * @example\n * // get scale names\n * scale.names // => ['major', 'dorian', ...]\n */\nmodule.exports = dictionary(scales)\n"
    },
    "name": "scale",
    "params": [
      {
        "title": "param",
        "description": "the scale name",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "name"
      }
    ],
    "examples": [
      "<span class=\"hljs-comment\">// get scale data</span>\n<span class=\"hljs-keyword\">var</span> scale = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'scale-dictionary'</span>)\nscale(<span class=\"hljs-string\">'Ab major'</span>) <span class=\"hljs-comment\">// =&gt; [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]</span>\nscale(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-string\">'Ab'</span>) <span class=\"hljs-comment\">// =&gt; [ 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G' ]</span>\n<span class=\"hljs-comment\">// get scale intervals</span>\nscale(<span class=\"hljs-string\">'major'</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; [ '1P', '2M', '3M', '4P', '5P', '6M', '7M' ]</span>",
      "<span class=\"hljs-comment\">// get it from aliases, binary or decimal numbers</span>\nscale(<span class=\"hljs-string\">'major'</span>) === scale(<span class=\"hljs-string\">'ionian'</span>) === scale(<span class=\"hljs-string\">'101011010101'</span>) === scale(<span class=\"hljs-number\">2773</span>)",
      "<span class=\"hljs-comment\">// get scale names</span>\nscale.names <span class=\"hljs-comment\">// =&gt; ['major', 'dorian', ...]</span>"
    ],
    "kind": "function",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "scale"
    ]
  },
  {
    "description": "Get a set from a binary set number and (optionally) a tonic. If the tonic is\na note, you get a pitch set. If its false you get a interval set.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "lineNumber": 4,
        "name": "set.fromBinary"
      },
      {
        "title": "function",
        "description": null,
        "lineNumber": 5,
        "name": null
      },
      {
        "title": "param",
        "description": "the gamut",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the first note of the set or false to get the intervals",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      },
      {
        "title": "returns",
        "description": "the set pitch classes (note names without octaves)",
        "lineNumber": 9,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        }
      },
      {
        "title": "example",
        "description": "var fromBinary = require('tonal.set/fromBinary')\n// use a 12 digit binary number:\nfromBinary('101011010101', 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n// or its decimal equivalent:\nfromBinary(2773, 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n// get the interval set by passing `false` as tonic:\nfromBinary(2773, false) // => ['1P', '2M', '3M', '4', '5', '6M', '7M']",
        "lineNumber": 11
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "bs"
      },
      {
        "title": "static"
      }
    ],
    "loc": {
      "start": {
        "line": 48,
        "column": 0
      },
      "end": {
        "line": 66,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 67,
          "column": 0
        },
        "end": {
          "line": 84,
          "column": 0
        }
      },
      "file": "./packages/binary-set/index.js",
      "code": "'use strict'\n\nvar G = require('music-gamut')\nvar transpose = require('note-transpose')\n\n/*\n */\nfunction bs () {\n\n}\n\n/**\n * Get a set binary number from a collection of notes or intervals\n *\n * A set binary number is a 12 digit binary, each digit representing a step\n * in the chromatic scale. For example, `101010000000` is `['1P', '2M', '3M']`\n *\n * The set binary number is very useful to check if two sets are equal or\n * contains same intervals (regarding of note names)\n *\n * @name binarySet.toBinary\n * @function\n * @param {String|Array|Array<Array>} source - a gamut\n * @return {String} the binary number\n *\n * @example\n * var binarySet = require('binary-set')\n * binarySet.toBinary('C2 E4 D3') // => '101010000000'\n */\nbs.toBinary = G.operation(function (gamut) {\n  var number = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  var intervals = G.set(G.harmonizer(gamut, false))\n  var semitones = intervals.map(height)\n  semitones.forEach(function (s) {\n    number[s] = 1\n  })\n  return number.join('')\n})\n\nfunction height (p) {\n  var f = p[0] * 7\n  var o = p[1] || p[1] === 0 ? p[1] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\nvar INTERVALS = ['1P', '2m', '2M', '3m', '3M', '4P', '4#', '5P', '6m', '6M', '7m', '7M']\n\n/**\n * Get a set from a binary set number and (optionally) a tonic. If the tonic is\n * a note, you get a pitch set. If its false you get a interval set.\n *\n * @name set.fromBinary\n * @function\n * @param {String|Array|Array<Array>} source - the gamut\n * @param {String} tonic - the first note of the set or false to get the intervals\n * @return {Array<String>} the set pitch classes (note names without octaves)\n *\n * @example\n * var fromBinary = require('tonal.set/fromBinary')\n * // use a 12 digit binary number:\n * fromBinary('101011010101', 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // or its decimal equivalent:\n * fromBinary(2773, 'C') // => ['C', 'D', 'E', 'F', 'G', 'A', 'B']\n * // get the interval set by passing `false` as tonic:\n * fromBinary(2773, false) // => ['1P', '2M', '3M', '4', '5', '6M', '7M']\n */\nbs.fromBinary = function (number, tonic) {\n  if (arguments.length === 1) return function (t) { return bs.fromBinary(number, t) }\n\n  if (/^1[01]{11}$/.test(number)) number = parseInt(number, 2)\n  else if (typeof number !== 'number') return []\n  var binary = ((number % 2048) + 2048).toString(2)\n\n  var set = []\n  for (var i = 0; i < 12; i++) {\n    if (binary.charAt(i) === '1') {\n      if (i === 6 && binary.charAt(5) === '1') set.push('5d')\n      else set.push(INTERVALS[i])\n    }\n  }\n  return tonic === false ? set : set.map(transpose(tonic))\n}\n\nmodule.exports = bs\n"
    },
    "name": "set.fromBinary",
    "params": [
      {
        "title": "param",
        "description": "the gamut",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "Array"
                }
              ]
            }
          ]
        },
        "name": "source"
      },
      {
        "title": "param",
        "description": "the first note of the set or false to get the intervals",
        "lineNumber": 8,
        "type": {
          "type": "NameExpression",
          "name": "String"
        },
        "name": "tonic"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the set pitch classes (note names without octaves)",
        "lineNumber": 9,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "String"
            }
          ]
        }
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> fromBinary = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'tonal.set/fromBinary'</span>)\n<span class=\"hljs-comment\">// use a 12 digit binary number:</span>\nfromBinary(<span class=\"hljs-string\">'101011010101'</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'D', 'E', 'F', 'G', 'A', 'B']</span>\n<span class=\"hljs-comment\">// or its decimal equivalent:</span>\nfromBinary(<span class=\"hljs-number\">2773</span>, <span class=\"hljs-string\">'C'</span>) <span class=\"hljs-comment\">// =&gt; ['C', 'D', 'E', 'F', 'G', 'A', 'B']</span>\n<span class=\"hljs-comment\">// get the interval set by passing `false` as tonic:</span>\nfromBinary(<span class=\"hljs-number\">2773</span>, <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// =&gt; ['1P', '2M', '3M', '4', '5', '6M', '7M']</span>"
    ],
    "kind": "function",
    "memberof": "bs",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "set.fromBinary"
    ]
  }
]